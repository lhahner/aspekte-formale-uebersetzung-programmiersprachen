--> Je Subsection Punkt Fragen formulieren.

\section{Theoretische Grundlagen}
	\subsection{Problemstellung}
	
	Es gibt zwei grundlegende Probleme die der PL/I zu Java Transpiler löst. 
	
	Einerseits das Kompatibiltätsproblem von PL/I-Programmen, die auf modernen Platformen laufen sollen. Beispiele für modernen Plattformen sind Cloud-Instanzen, oder Linux-Server. 
	
Andererseits die mit einem hohen Aufwand verbundene Wartung von PL/I Programmen. 
	
	Das Kompatbilitätsproblem ergibt sich aus dem bestehenden PL/I Compilerlösungen. Der PL/I Compiler, der auf den meisten Computer-Systemen im Einsatz ist wird von IBM entwickelt und vermarktet. Hierbei handelt es sich jedoch um einen Compiler der expilziet für z/Os geschrieben wurde. Dabei ist z/Os ein Betriebssystem welches für die von IBM vermarkteten Großrechner zum Einsatz kommt. Eine compilierung von PL/I auf einem herkömmlichen x86-Desktop Computer oder in der Cloud ist mit diesem Compiler nicht möglich. 
	(https://www.ibm.com/de-de/products/pli-compiler-family) 
	Eine Alternative bietet jedoch GNU mit ihrer GNU Compier Collection (GCC). Unter dieser Organisation hat der Entwickler Henrick Sorensen angefangen das Frontend für einen PL/I Compiler zu entwickeln und dabei auf das Backend der GCC zurückgegriffen um einen vollständigen Compiler zu entwicklen. Hingegen gab es bei diesem Projekt seit 2007 keine weiteren Neuerungen mehr und der Entwickler gibt selbst an das keine Zwischen-Code erzeugung bisher stattfindet, was diesen Compiler bisher unbrauchbar macht. 
	(https://pl1gcc.sourceforge.net/) 
	Somit ist auch das keine Alternative für moderne System-Architekturen. 
	
Weiterhin ist PL/I eine Altsprache, die seit den 1960er Jahren im Einsatz ist. 

(https://www.fruehes.berlin/wp-content/uploads/2011/02/PL-1-F-OS-360-V-4.0.pdf) 

Es ist also anzunehmen das diese Sprache heute zwar noch in Computer-Systemen zu finden ist, aber der Bestand an Entwicklern die die Software Warten können eher gering. Das führt dazu das die Wartung und Entwicklung, schwer durch Mangelnde Entwickler und kostspielig durch eine geringe Anzahl an Entwicklern werden kann.

Java hingegen ist auf nahezu allen erdenklichen System Kompilierbar, durch ihre Systemunabhängig JVM die sich um das Kompilierung des Programms kümmert. 

(https://medium.com/@etherservices.vimalraj/can-i-run-java-programs-on-any-device
a-comprehensive-guide-31f736ca6ab1) 

Dabei ist eine kompilierung auf Android Systemen, die einen weitaus weniger Komplexen RISC Befehlsatz als x86 Systeme mit einem CISC Befehlssatz haben möglich. 

(https://developer.android.com/codelabs/build-your-first-android-app) 
Zusätzlich ist eine Kompilierung wiederum, auch auf einem IBM-Großrechner möglich. 

(https://www.ibm.com/docs/en/zos-basic-skills?topic=zos-java)

Das macht Java sehr flexibel im Bezug auf die Kompatibiltät. 

Weiterhin is Java die mit am meisten verwendete Programmiersprache in der heutigen Zeit. Das führt zu einer höheren Anzahl an Entwickler die in der Lage sind Java Programme zu warten.
% Was ist ein Transpiler?
Um nun diese Probleme tatsächlich zu lösen braucht es ein Programm, welches PL/I Quellcode als Eingabe nimmt und ein leserliches und Funktionsfähiges Programm ausgibt. Dieses Programm is ein Transpiler, der PL/I Code so verarbeitet das aus diesem Java Code generiert werden kann. Ein Transpiler arbeitet ähnlich wie ein Compiler, es wird aus dem bestehenden Programm eine Zwischencode Darstellung erzeugt welche schlussendlich auch in Java Code dargestellt werden kann. Dabei ist es möglich das der Entwickler des Transpilers selbstwählen kann, wie er welche Ausdrück übersetzt, was viel Spielraum für Diksussion lässt. Ist der Programmcode erstmal Transpiliert kann dieser durch die JVM kompiliert werden. Somit wären auch die Eingangs beschriebenen Probleme mithilfe dieses Programms gelöst.
	 
     
% Cross Compiler? - Hat hier eig nix zu suchen, ist Thema für Boostrapping aber nicht für Transpiler
     
     
     
% 	 Welches Problem löst das Programm?
%	 Probleme 
%			 1. Nicht auf jedem System läuft PL/I, besonders nicht auf modernen x86 bzw. Cloud.
%			 2. PL/I ist eine weniger verwendete Sprache, Wartung teuer &  Schwer.

%	 (Hinführung zum Problem:
%	 Historisches Kompatibilitätsproblem -> Nicht auf jedem System lief jede Assambler Sprache, Problem: hoher Aufwand und Unflexibel
% 	 Deshalb -> Compiler mit Hochsprache, der Code für das Backend des Compilers, bspw. C's Gcc Compiler
%    in Assambler Sprache des Systems übersetzt.)? **Hier einen Cross Compiler erklären bzw. im Zusammenhang mit dem Historischen Problem.**

%	 Problem mit PL/I -> Pl/I Compiler rar bzw. nur für Großrechner Systeme vorhanden   
%	 Es gibt zwar einen GCC Pl/I Compiler, dieser wird aber seit 2007 nicht mehr weiterentwickelt. Eine Weiterentwiclung könnte auch Interessant %    sein, löst aber nicht das Problem der teuren Wartung von Programmen in PL/I.

% 	 
%	 Lösungsvorschlag zu 1 -> PL/I zu Java Transpiler bauen Java und JVM relativ System unabhängig und damit Ideale Zielsprache für eine 
%	 hohe Kompatibiltätsrate.Um zum Beispiel Pl/I Programm die auf einem Großrechner laufen auch auf einem x86 On-Prem Server oder einer Cloud
%    zu betreiben. **Hier die Frage klären was ein Transpiler ist**
%	 
%    Lösungsvorschlag zu 2 -> Java ist den großteil der Softwareentwickler bekannt und eine Wartung ist leichter.
%
    
	\subsection{Zielsetzung}
 - Wie eine Art JavaScript Minifier oder 
    Wer ist die Zielgruppe?
    - Junior Entwickler die gerade in PL/1 einsteigen.
    - Lernhilfe
    - Online-Smoketest von PL/I Code
    - Benutzbarkeit
    
	\subsection{Abgrenzung Interpreter und Transpiler}
    Warum ein Transpiler?
    - Erweiterung des Umfangs während der Laufzeit
    Was sind gemeinsamkeiten und unterschiede von Transpiler und interpreter?
    - Trennung Laufzeit/Konzeptionsphase
    - ...
    - ...
    
	\subsection{Formale Grammatiken / Wofür Formale Grammatiken}
     - Theoretischer Abriss
    - Einordnung der resultate der PA 4
	- PL/1 Syntax Wo zu finden? Welche Version der Sprache? 
     Wie kann JavaCC die formale Beschreibung der Grammatik in einen Parser Umsetzen?
	- Reguläre Ausdrücke Syntax, Beispiel einer Grammatik die ich mit verwende, Typ einer Grammatik
    - Literatur
	    - Chomsky Hierarchie Bücher
	    - https://www-igm.univ-mlv.fr/~berstel/LivreCodes/Codes.html
     - Woraus besteht eine Grammatik?
     - Wie lassen sich Grammatiken der Komplexität nach anordnen?
     - Chomsky Hierarchie
     Erst Chomsky Hierachier, dann nach Komplexität einordnen und am Beispiel von Regulären Ausdrücken und PL/I Grammatik einführen.
     
	\subsection{Anwendung in JavaCC / Verwendung von regulären Ausdrücken als Datentyp (Tokens)}
     - Beschreibung von formalen Grammatiken, als Input für den Compiler Compiler JavaCC.
     - Entwurf von Java Klassenhierachie für PL/I Datentypen
     - Übersetzung von Kontrollstrukturen und komplexeren Programmabläufen


\section{Technisches Vorgehen}
\subsection{Techstack}
Um den Transpiler weiter zu entwickeln sind Schritte notwendig die, die Qualität des bestehenden Projektes erhöhen. Diese Schritte sind einerseits die Verbesserung der Projektstruktur und andererseits die Handhabung von Bugs und Fehlern.

Die Ursprüngliche Version des Transpilers nahm die Native Projektstruktur von Eclipse als Vorlage. Diese Projektvorlage brachte jedoch einige negative Aspekte mit sich. Mit dieser Struktur war es schwer das Projekt zu importieren und erfolgreich PL/I-Code zu transformieren. Das erschwerte den Benutzern den Zugang zu dem eigentlichen Projekt. 
Zurückzuführen ist dies auf das fehlenden Dependency Management. In der Ursprünglichen Version des Transpilers musste der Benutzer selbst herausfinden welche Software dieser benötigt um das Programm zu starten. In den meisten Fällen durch Fehlermeldungen welche darauf schließen lassen konnten das eine Dependency fehlt. Dieser Umstand ergibt eine Hürde, welche den Einstieg in die Umwandlung erschwerte. 
Dieses Problem wurde gelöst in dem das Software Projektmanagement Werkzeug Maven eingesetzt wurde. Maven kann mithilfe des Project-Object-Model (POM) Dependecies lösen in dem benötigte Softwared beim kompilieren installiert wird. Der Benutzer kann nun entweder mithilfe des Maven Commandline-Interface (CLI) das Projekt aufbauen, oder einfach in Eclipse oder einer selbstgewählten IDE importieren.
Ein weiterer Vorteil den Maven liefert ist die vordefinierte Projektstruktur. Mavens Projektstruktur liefert zwei gespiegelte "src" Ordner, welche je den Quellcode enthalten und die dazugehörigen Tests. Diese Struktur wurde erweitert. Es wurde die Projektstruktur in Module unterteilt. Jeder Modul-Ordner beinhaltet Klassen in denen sich die funktionalität des Moduls wiederspiegelt. Die Module werden in den Basepackages Zusammengefasst. Bei der Auswahl der Module sollte der Prozess des Transformierens deutlich werden, entsprechend erfolgt die Namensgebung nach den Prozesschritten: Lexikalische Analyse, Syntaktische Analyse, Syntaktische Synthese. Neben den Hauptprozessschritten, sind die Nebenprozess die Verarbeitung der Symboltablle und die Fehlerbehandlung, welche Ebenfalls als Module geordnet sind. Diese Ordnung führt zu einer einfachen Übersicht der verschiedenen Prozesse.

- Maven -> Dependency Management
- Testing -> JUNit Tests
- Platform -> Spring
- Compiler Compiler -> JavaCC

\subsection{Architektur} 
--> UML Diagramm Zielbild einfügen, dynamisches Diagramm
- Wie sind die Module momentan gebaut
- Wie sind Module zueinander abhängig
- Wie wird es erweitert

Wie Benutze ich den Transpiler:
Bausteine
- Software Architektur
	- Planen mithilfe eines UML
	- UX Design 
        - zweite Diagramm, des Benutzerfluss
        - wie Benutzung abläuft
		- Website?
		- Docker Container?
- Fehlertracking
- Struktuierung des Programms, sodass ein Benutzer es selbständig erweitern kann

\subsection{Aspektorientierte Programmierung}
- Wie funktioniert Aspektorientiert Programmierung?
	- Wie Löse ich mit Aspektorientierter Programmierung konkrete Probleme?
- JavaBeans
- Spring
	- Wie setzt Spring Aspektorientierte Programmierkonzepte ein?
 
\subsection{Module des Transpilers}
\subsubsection{Compiler-Compiler}
\paragraph{Scanner}
\paragraph{Lexer}
\paragraph{Parser}
\subsubsection{Symboltable}

\subsubsection{Mapper}

\subsubsection{Error-Handling}

\subsection{Testing & Integration}
1. Transpiler wird getestet
1.1 Testen der Methoden von Lexer, Parser usw. (Bsp.: Kann dieses Zeichen verarbeitet werden?)
1.2 Baum testen auf Korrektheit

2. Transpilieren wird getestet
2.1 Output des transpilierten Pl/1 Codes im Verhältnis zum Pl/1 Code testen.

3. Der Transpilierte Code wird getestet
- Wie wird PL/1 Code Native getestet
- Funktioniert der Java Code richtig

4. Performance Test (erst am ende)

\subsection{Fehlerbehandlung}
Um dem Benutzer die Bediengung während der Laufzeit zu erleichtern, wurden Selbstgewählte Fehlermeldungen implementiert. Diese Fehlermeldungen sollen den Benutzer der Software in eine Feedback schleife bringe welche klare Anweisung zur Bediengung gibt. In der usprünglichen Version des Transpilers wurde dem Benutzer lediglich die von Java geworfenen Fehler in der Konsole ausgegeben. Die Fehlermeldung"IndexOutOfBounds", ließ dabei nicht darauf schließe das der Transpiler die PL/I Datei zum lesen nicht findet. Eine solche Fehlermeldung führt erneut dazu, dass der Benutzer sich selbst um die Lösung des Problems kümmern musste und somit einer weiteren Hürde begenete.
Eben für dan Fall das die Datei nicht gelesen werden kann, wurde eine Exception geschrieben. Die Exception "PliFileNotFound", beschreibt dem Benutzer die Ursache des Problems und nennt auch ein etwaaigen Lösungsvorschlag. Es exstieren in der neusten Version einige Exceptions die in der folgenden Tabelle näher Beschrieben werden.

...Tabelle mit Exceptions...

Fehlerbehandlung spielt besonder im Zusammenhang mit der Lexikalischen Analyse eine Rolle. Um zu gewährleisten das die Transformation korrekt albläuft braucht es der formalen PL/I Grammatik enstrpechend richtigen PL/I Code als Eingabe. Eine nicht behandlung hätte zur Folge das das Programm entweder eine Fehlerhafte Ausgabe produziert, oder Fehlschlägt. Dies soll vermieden werden.

\section{Technische Spezifikation}
	\subsection{Ausführung des Transpilers}
		\subsubsection{Transformationsmöglichkeiten}
		Toleranzspielräume:...Einfach, Genau, Präzisse
		\subsubsection{Umwandlung von Datentypen}
		\subsubsection{Umwandlung von Prozeduren}
	\subsection{Optimierung}
		\subsubsection{Performance & Benchmarks}
		\subsubsection{Testing}
