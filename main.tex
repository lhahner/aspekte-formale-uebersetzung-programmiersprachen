%--> Je Subsection Punkt Fragen formulieren.

%-------------------------------------------
% HEADER

% Roterfade der Einleitung:

% 1. Problem -> Kompatibilität
% 2. Ziel -> Lösung mit Übersetzungsprogramm
% 3. Abgrenzung Interpreter & Compiler -> Übersetzungsprogramm als Transpiler
% 4. Formale Grammatike -> Formale Grammatik als Vorrausetzung des Transpilers
% 5. JavaCC -> Implementierung der Formalen Grammtik mit JavaCC und damit des Transpilers

%-------------------------------------------

\section{Theoretische Grundlagen}
\subsection{Problemstellung}
	
Es gibt zwei Probleme die eine \ac{pli} zu Java Übersetzung lösen soll. 
Problem eins, ein Portabilitätsproblem von wartungsintensiven PL/I-Programmen, die auf modernen Plattformen laufen sollen, wie etwa Cloud-Instanzen oder Linux-Server.
	
Die bestehende Auswahl von PL/I Compilern führen zu einem Portabilitätsproblem. Der PL/I Compiler, der auf den meisten Computer-Systemen im Einsatz ist, wird von IBM entwickelt und vermarktet. Hierbei handelt es sich um einen Compiler der für das von IBM entwickelte Betriebssystem z/OS geschrieben wurde. Eine Kompilierung von PL/I auf einem herkömmlichen x86-Desktop Computer oder vergleichbar weit verbreiteten Rechnerarchitekturen ist mit diesem Compiler nicht möglich. \footcite[Vgl. ][]{plicomp}


Eine Alternative bietet die Organisation GNU mit der \ac{GCC}. Der Softwareentwickler Henrick Sorensen entwickelte Teile des Frontends für einen PL/I Compiler. Dabei verwendete er das Backend, das die \ac{GCC} zu Verfügung stellt. Jedoch gab es bei diesem Projekt seit 2007 keine weiteren Neuerungen mehr. Der Entwickler gibt an, das bisher keine Zwischencode Erzeugung stattfindet, was diesen Compiler bisher unbrauchbar macht. \footcite[Vgl. ][]{pligcc} 
Typischer wird heutzutage auf einen Endgerät ein IBM 3270 Terminal emuliert, dass eine Verbindung zu einem z/Os-System herstellt, um den PL/I-Code auf diesem zu kompilieren.

Problem zwei ist demografischer Herkunft. PL/I ist eine Altsprache, die seit den 1960er Jahren im Einsatz ist und durch den Generationenwechsel an Entwicklern verliert. Wartung und Entwicklung werden so häufig teuer.\footcite[Vgl. ][S. 227ff.]{histopli} 

Java hingegen ist auf nahezu allen modernen Systemen durch die plattformunabhängige Java Virtual Machine (JVM) kompilierbar. \footcite[Vgl. ][]{jvm}
Insbesondere ist eine Kompilierung auch auf einem IBM-Großrechner mit z/OS möglich. \footcite[Vgl. ][]{zos} 
Das macht Java zu einer flexibel einsetzbaren Sprache. 

Weiterhin ist Java heute eine beliebte Programmiersprache. \footcite[Vgl. ][]{tiobe} Das führt zu einer höheren Anzahl an Entwicklern, die in der Lage sind, Java Programme zu warten.

% Was ist ein Transpiler?
Um die Programmiersprache Java zur Lösung der eingangs beschriebenen Probleme zu verwenden, kann ein Transpiler benutzt werden um die Transformation des Quellcodes, teilweise automatisiert zu beschleunigen. 
Dabei hat der Benutzer die Möglichkeit, selbst zu bestimmen, wie bestimmte Ausdrücke übersetzt werden sollen. Sobald der Programmcode nach Java übersetzt ist, kann der Java-Zielcode von dem Java-Compiler kompiliert werden und auf der \ac{jvm} ausgeführt werden.

% @review: Begriffswahl
Diese Arbeit führt Eingangs in Kapitel eins, in die grundlegenden theoretischen Konzepte, wie Grammatiken von formalen Sprachen in Bezug auf die verwendete Compiler-Compiler Technologien ein. Darauffolgend werden weitere Technologie- und Design-Entscheidungen des Transpilers vorgestellt und diskutiert. In Kapitel drei werden dann die Verwendung des Transpilers, die Gestaltung der Übersetzungen, sowie die durchgeführten Tests beschrieben. Abschließend wird in Kapitel vier ein Ausblick auf die Weiterentwicklung gegeben.
In den folgenden Kapiteln wird zwischen dem Transpiler, dem Eingabeprogramm (PL/I-Quellcode) und dem Ausgabeprogramm (Java-Zielcode) unterschieden. Diese Begriffe helfen dabei, die verschiedenen Programme eindeutig zu identifizieren. 

%Anderseits auch die veränderte Laufzeit-Performance. Die Laufzeit-Performance kann durch eine Übersetzung verschlechtert, wie auch verbessert werden. Somit ist nicht nur die reine Übersetzung Teil der Problemstellung, sondern es gilt auch die Übersetzung zu beurteilen. 

     

% 	 Welches Problem löst das Programm?
%	 Probleme 
%			 1. Nicht auf jedem System läuft PL/I, besonders nicht auf modernen x86 bzw. Cloud.
%			 2. PL/I ist eine weniger verwendete Sprache, Wartung teuer &  Schwer.

%	 (Hinführung zum Problem:
%	 Historisches Kompatibilitätsproblem -> Nicht auf jedem System lief jede Assambler Sprache, Problem: hoher Aufwand und Unflexibel
% 	 Deshalb -> Compiler mit Hochsprache, der Code für das Backend des Compilers, bspw. C's Gcc Compiler
%    in Assambler Sprache des Systems übersetzt.)? **Hier einen Cross Compiler erklären bzw. im Zusammenhang mit dem Historischen Problem.**

%	 Problem mit PL/I -> Pl/I Compiler rar bzw. nur für Großrechner Systeme vorhanden   
%	 Es gibt zwar einen GCC Pl/I Compiler, dieser wird aber seit 2007 nicht mehr weiterentwickelt. Eine Weiterentwiclung könnte auch Interessant %    sein, löst aber nicht das Problem der teuren Wartung von Programmen in PL/I.

% 	 
%	 Lösungsvorschlag zu 1 -> PL/I zu Java Transpiler bauen Java und JVM relativ System unabhängig und damit Ideale Zielsprache für eine 
%	 hohe Kompatibiltätsrate.Um zum Beispiel Pl/I Programm die auf einem Großrechner laufen auch auf einem x86 On-Prem Server oder einer Cloud
%    zu betreiben. **Hier die Frage klären was ein Transpiler ist**
%	 
%    Lösungsvorschlag zu 2 -> Java ist den großteil der Softwareentwickler bekannt und eine Wartung ist leichter.
%
 \pagebreak
\subsection{Zielsetzung}
% Herleitung von der Problemstellung	
Allgemein soll ein plattformunabhängiger Transpiler entstehen, der die Entwicklung und Transformation von PL/I-Quellcode ermöglicht. Die zugrundeliegende Arbeit stellt die Entwicklung, sowie die Gestaltung der Software dar und diskutiert Gestaltungsentscheidungen. 

% @review: Referenz zur Begriffklärung
% Zielgruppen Zusammengefasst	
Diese Arbeit richtet sich  zuerst an juniore Anwendungsentwickler in den Sprachen PL/I bzw. Java. Für diese Nutzergruppe soll der Transpiler ein Hilfswerkzeug darstellen. Weiterführend werden diese als \emph{Benutzer} bezeichnet. Eine andere Nutzergruppe sind \emph{Administratoren}, die den Transpiler selbst anpassen und erweitern möchten. Ermöglicht wird dies durch eine modulare Architektur.
	
% Junior Entwickler die gerade in PL/1 einsteigen.
Juniore Entwickler profitieren von dieser Arbeit als Einstiegspunkt in die Programmiersprache PL/I. Beispielhaft könnten Entwickler den Transpiler als Test-Umgebung für den eigenen entwickelten PL/I-Quellcode verwenden. Für Benutzer, die mehr Erfahrung mit Java haben, eignet sich der Transpiler als Lernhilfe. Es wird ihnen so erleichtert, PL/I-Quellcode zu analysieren. Sie können bestehende Kenntnisse aus Java anwenden, um Muster in PL/I wiederzuerkennen. Dies kann den Lernprozess beschleunigen.

% Benutzbarkeit
Der Transpiler aus der Projektarbeit-IV konnte bisher über die Kommandozeile, sowie der IDE Eclipse verwendet werden. Diese ursprüngliche Benutzung des Transpilers führte zu einer hohen Fehleranfälligkeit und Dokumentationsbedarf. Die Komplexität der Benutzung wird durch ein Graphical-User-Inferface (GUI) vereinfacht.
%Das Konzept dieser GUI soll dem eines Übersetzers der natürlichen Sprache, wie etwa 'DeepL' oder 'Google-Translate', ähneln. Mit diesen Konzepten sind Benutzer vertraut, erleichtert den Einstieg in die Programmiersprache PL/I, das Testen des PL/I-Quellcode, sowie die schnelle Übersetzung.

%  Entwickler die das Programm eigenständig erweitern, verändern wollen.
Durch die modularisierte Gestaltung des Transpilers können Administratoren selbst Module austauschen und erweitern, 
etwa durch eine API-Schnittstelle. 

%  Zusammenfassung und hinführung zum nächsten zu dem Unterschied Interpreter und Compiler

Der Transpiler soll eine Transformation der grundlegende Sprachkonstrukte übersetzen. Die Variablendeklaration sowie -zuweisung, die Ein- und Ausgabesteuerung und allgemeine Kontrollflussanweisungen wurden im Zuge der Entwicklung implementiert. Der entstehende Java-Zielcode ist unter Verwendung einer Boiler-plate-Codebasis kompilierbar. Dabei sollen die PL/I-Konstrukte in dem Java-Zielcode erkennbar sein, sowie native Java Strukturen des Objektorientierten Programmierparadigma verdeutlicht werden.

% Aufteilung der Zielstellung:
% 1. Allgemein; Ableitung aus der Problemstellung
% 2. Zielgruppen spezfifisch
% 2.1 Einfache und unkomplizierte Lösung
%
% 2.2 Erweiterung des Transpilers bzw. ersetzen von Modulen	
	
% - Wie eine Art JavaScript Minifier oder 
%  Wer ist die Zielgruppe?
%  - Junior Entwickler die gerade in PL/1 einsteigen.
%   - Lernhilfe
%  - Online-Smoketest von PL/I Code
%   - Benutzbarkeit
%   - Entwickler die das Programm eigenständig erweitern, verändern wollen.
 
%  Ziele der Architektur (Zielgruppe Entwickler)
%  - Perspektive des Entwicklers
%  - Perspektive des Benutzers
    \pagebreak

\subsection{Abgrenzung Interpreter und Compiler}
  
% Wie arbeitet ein Compiler?
Ein Compiler besteht aus einem Frontend und einem Backend. Das Frontend umfasst die lexikalische, syntaktische, semantische Analyse und die Symboltabelle.
Das Ergebnis des Frontends ist eine Zwischencodedarstellung, die an das Backend übergeben wird, um daraus Maschinencode zu generieren. Der Maschinencode kann auf dem zugrundeliegenden System ausgeführt werden. \footcite[Vgl. ][S.106ff. ]{aho}
Abbildung \ref{fig:compiler} zeigt eine Übersicht und das Ergebnis der einzelnen Compiler-Phasen. Die Abbildung unterteilt den Ablauf wie eingangs beschrieben in Frontend und Backend.

% @todo: Quelle
\dhgefigure[h]{compiler-ablauf-diagramm.png}[scale=0.6]{Funktionsweise eines Compilers}{fig:compiler}[aho][S. 12]

In der ersten Phase teilt der Compiler den eingegebenen String in Token auf. Danach entsteht ein Syntaxbaum, der in diesem Beispiel die Zwischencodedarstellung repräsentiert. Ab diesem Punkt beginnt das Backend des Compilers. Zuerst erzeugt das Backend maschinenunabhängigen Code, meist in Assembler und anschließend maschinenabhängigen Code. Die Abhängigkeit zwischen der Maschine und dem Code, entsteht durch die Adressierung der Registeradressen.  \footcite[Vgl. ][S.30ff. ]{aho}
In jeder Phase wird aus der Symboltabelle gelesen und geschrieben.

%  Warum ein Transpiler?
Es gibt weitere Lösungen die auf einem ähnlichen Konzept basieren.
Ein One-Pass-Compiler etwa erzeugt keinen Zwischencode, sondern führt den Code direkt aus. Diese Methode wurde angewendet, um Speicherplatz zu sparen, da frühe Computer nur begrenzte Kapazitäten hatten und keine Zwischenergebnisse speichern konnten. Ein Beispiel für eine Sprache, die mit einem One-Pass-Compiler kompiliert wird, ist Turbo Pascal. \footcite[Vgl. ][]{onepass}

Eine weitere Ausprägung ist ein Source-to-Source Compiler.
Während ein C-Compiler den C-Code nach der Zwischencodeerzeugung in Assemblersprache und anschließend der Assembler den C-Quellcode in Maschinencode übersetzt, wandelt ein Source-to-Source-Compiler beispielsweise C-Quellcode in Java-Zielcode um. 
Ein Source-to-Source-Compiler wird im Zusammenhang dieser Arbeit als \emph{Transpiler} bezeichnet. Abbildung \ref{fig:transpiler} zeigt die Prozessschritte eines Transpilers.

\dhgefigure[h]{transpiler-diagramm.png}[scale=0.58]{Funktionsweise eines Transpilers}{fig:transpiler}[][]
\pagebreak

Ein Vergleich von Abbildung \ref{fig:compiler} mit Abbildung \ref{fig:transpiler} zeigt, dass die ersten Phasen bis zur Zwischencodeerzeugung gleich bleiben. In Abbildung \ref{fig:transpiler} sind jedoch die Prozesse des Frontends neben denen des Backends dargestellt. Während in Abbildung \ref{fig:compiler} diese untereinander angeordnet sind. Zurückzuführen ist diese Darstellung auf die verwendeten Sprachebenen.

Ein Compiler übersetzt den Quellcode einer Hochsprache in eine maschinennahe Sprache wie Assembler. Hingegen bleibt der Transpiler bei der Ein- und Ausgabe auf der Sprachebene der Quellsprache. In Abbildung \ref{fig:transpiler} werden zudem die Phasen des Backends reduziert, da keine Übersetzung in eine maschinenabhängige Sprache erfolgt.

% @review
Ein weiterer Unterschied ist die Art der Ausführung des übersetzten Zielcodes.
Das Ergebnis der Übersetzung eines Compilers ist Binärcode der auf einem Zielsystem ausgeführt werden kann. Um hingegen das Ergebnis eines Transpilers auszuführen,
braucht es einen weiteren Compiler. Dieser Compiler muss den Zielcode der Zielsprache in Binärcode übersetzen.
Bei der Übersetzung von PL/I-Quellcode nach Java-Zielcode bedarf es also eines weiteren Java-Compilers zum Ausführen des Zielcodes.

% @review: Cross Compiler? - Hat hier eig nix zu suchen, ist Thema für Boostrapping aber nicht für Transpiler
%Neben den Methoden der Konstruktion, gibt es auch unterschiedliche Verwendungen von Compilern. 
%Etwa existiert der Begriff der Cross-Kompilierung. Hierbei handelt es sich um die Möglichkeit einen Compiler, der sich auf einem externen Computersystem befindet zu verwenden um den Quellcode auf dem lokalen System in Binärcode zu übersetzen. \footcite[Vgl. ][]{guncross}

%Diese Verwendungsweise findet etwa Anwendung beim Bootstrapping. Liegt auf dem System noch kein Compiler für die Sprache vor, in der der Kernel geschrieben wurde, wird diese Methode verwendet um den Kernel-Code zu kompilieren. 
%In dieser Arbeit kommt ein solcher Ansatz bedingt zum Einsatz. Wird der Transpiler in einem Webinterface verwendet, ist die Verhaltensweise ähnlich.
%Da auch hier der Compiler auf einem anderen Host-Computer, den lokalen Quellcode übersetzt.

Zusammenfassend übersetzen sowohl One-Pass-Compiler, Transpiler bzw. Source-to-source Compiler als auch herkömmliche Compiler das Programm basierend auf einer Zwischencodeerzeugung. \footcite[Vgl. ][S. 18ff. ]{assambly}

Eine weitere Alternative ist der Interpreter. Dieser führt den Quellcode direkt Zeile für Zeile aus, ohne vorher eine Zwischencoderepräsentation zu erzeugen. In Abbildung \ref{fig:shell} ist der Verarbeitung des Bash Interpreters dargestellt.


\dhgefigure[h]{shell_interpreter.png}[scale=0.6]{Ablauf des Bash-Interpreters}{fig:shell}[][]
\pagebreak

Die Eingabe des Bash-Skripts wird zeilenweise gelesen.
Das Quoting folgt dem Prinzip der lexikalischen Analyse, bei der alle Sonderzeichen entfernt werden, wie zum Beispiel Kommentare oder Backslashes. Sobald das Quoting abgeschlossen ist, entsteht ein String, der nur aus den Tokens eines Ausdrucks besteht.

Anschließend beginnt das Parsing, das der syntaktischen Analyse im Kompilierprozess ähnelt, jedoch keine Zwischencodeerzeugung beinhaltet. Hier wird lediglich zwischen einfachen Bash-Befehlen wie \verb+wc+ und zusammengesetzten Befehlen wie einem \verb+if+-Ausdruck unterscheiden.

Der Verarbeitungsprozess setzt sich mit der Shell-Expansion fort, bei der in einem Befehl eingebettete Variablen und Pfade durch ihre absoluten Repräsentationen ersetzt werden.
Ab hier nimmt nun das Betriebssystem die Befehle des Shell-Skriptes entgegen und führt das entsprechende Programm, mithilfe der Pfade zu der Binärdatei aus. Dieser Prozess ist Vergleichbar mit der Adressierung von Registeradressen während der Kompilierung.
Schließlich wird das Ergebnis in der Standardausgabe ausgegeben. \footcite[Vgl. ][]{gnubash}

% Absatz: Zusammenfassende Unterscheidung zwischen Interpreter und Transpiler, Was sind gemeinsamkeiten und unterschiede von Transpiler und interpreter?

Zusammenfassend zeigen sich sowohl Ähnlichkeiten als auch Unterschiede zwischen einem Interpreter und einem Compiler bzw. Transpiler. Beide durchlaufen die Phasen der lexikalischen und syntaktischen Analyse, wobei sie den Quellcode zunächst um Kommentare, Leerstellen oder andere für die Übersetzung irrelevante Symbole bereinigen. Anschließend erfolgt entweder die direkte Ausführung des Quellcodes oder die Erzeugung einer unabhängigen Repräsentation.

% Wie sähe mein Programm als Interpreter aus:
Um den PL/I-Quellcode nach Java-Zielcode zu übersetzen eignet sich ein Interpreter weniger. Da ein Interpreter nur Zeilenweise den Quellcode verarbeitet, ist auch nur eine Zeilenweise Übersetzung denkbar. Jedoch bleiben dabei Syntaktische Zusammenhänge in dem PL/I-Quellcode Unberücksichtigt. Die etwa bei der Transformation von zusammengesetzten Datentypdeklarationen benötigt werden. Um die Syntaktischen Zusammenhänge erleichtert zu verarbeiten, eignet sich eine Zwischencodeerzeugung.
Auch wird durch eine Zwischencoderepräsentation, wie einem Syntaxbaum der Kontext zwischen verschiedenen Ausdrücken leichter berücksichtigt. Dadurch kann die Lesbarkeit des Java-Zielcodes erhöht werden.

%Um PL/I-Code korrekt in Java zu übersetzen, sind Verbindungen zwischen den Ausdrücken relevant. Diese Verbindungen können in einer Zwischencoderepräsentation des PL/I-Quellcodes, komprimiert dargestellt werden. Eine zeilenweise Übersetzung könnte zu einem Java-Programm führen, das den restlichen Kontext des Programms nicht weiter berücksichtigt.
%Ein Interpreter erreicht das Ziel einer objektorientierten Programmierung und eines wiedererkennbaren PL/I-Codes nicht. Verschachtelte Strukturen lassen sich schwer in Klassen umwandeln. Ein rekursiver Syntaxbaum unterstützt diese Transformation, während ein Interpreter nur statische Umsetzungen ermöglicht. Dies führt zu mehr Boilerplate-Code und geringerer Lesbarkeit. Daher ist ein Interpreter ungeeignet.
%Da eine Rekursive Verarbeitung, wie es etwa mit einem Syntaxbaum möglich ist, so nicht möglich ist. 
 
% Der entscheidende Unterschied liegt darin, dass der Interpreter den Quellcode lediglich zeilenweise direkt übersetzt, während der Compiler das Programm in eine andere Form transformiert und liest. Dabei stehen die verwendeten Ausdrücke des Eingabecodes in Beziehung zueinander, beispielsweise durch die Verschachtelung von Verzweigungen und Schleifen.



% - Erweiterung des Umfangs während der Laufzeit
% - Trennung Laufzeit/Konzeptionsphase

% - Hier erwähnen das eine geminsamkeit die definition von Grammatiken ist, dann überleiten zu Formale Grammatiken.
% - Auch Entscheidung treffen was genau der Transpiler ist, Compiler oder Interpreter
\pagebreak
   
   
\subsection{Formale Sprachen und ihre Grammatiken}
% Formale Sprachen - linearer Ausdruck
Formale Sprachen sind geeignet, Ausdrücke zu generieren, die als Anweisungen von einem Computer verarbeitet werden können und gleichzeitig dem Menschen verständlich sind. Dabei erfolgt das Schreiben von formalen Sprachen linear, das Lesen und Schreiben beginnt also von oben nach unten. Um diese lineare Form zu verarbeiten, braucht der Computer eine Regelung, die eine Verarbeitung der einzelnen Ausdrücke zulässt.

Auch wie andere Sprachen besteht eine formale Sprache aus Syntax und Lexemen. Der Syntax einer formalen Sprache kann durch eine Grammatik beschrieben werden.
Um eine generative Grammatik für eine formale Sprache zu definieren sind logische präzise Beschreibungen von Ausdrücken notwendig. \footcite[Vgl. ][S. 149ff. ]{automata} Zusammengefasst in:

\begin{center}
	\begin{equation}\label{eqn:grammar}
		G=(V,T,S,P)
	\end{equation}
\end{center}


Hierbei steht \verb+V+ für Variablen bzw. Nicht-Terminalsymbole, \verb+T+ für Terminale, \verb+S+ für Start und \verb+P+ für Produktionsregeln. Dabei ist \verb+S+ ein Teil von \verb+V+. Eine Produktion ergibt eine Syntaxregel für die Grammatik. Um eine Grammatik darzustellen, werden Ableitungen von Syntaxregeln zur Erzeugung verwendet. Hier wird durch eine Reduktion von Nicht-Terminalsymbolen in Terminalsymbole der eingegebene Ausdruck überprüft. In der Gleichung 2 bis 6 ist die Syntaxregel zur Erzeugung einer einfachen \verb+if+ und \verb+else+ Verzweigung dargestellt.

% @todo: PL/I Verwenden und Kontext herstellen
\begin{center}
	\begin{equation}\label{eqn:start}
		S \to \mathbf{if}\: expr\: \mathbf{then}\: stmt\: \mathbf{else}\: stmt\: | \mathbf{if}\: expr\: \mathbf{then}\: stmt;
	\end{equation}
	\begin{equation}
		expr \to expr\: op\: term\: | term
	\end{equation}
	\begin{equation}
		op \to \mathbf{>}\: |\: \mathbf{<}\: |\: \mathbf{=}\: |\: \mathbf{!}
	\end{equation}
	\begin{equation}
		term \to term\: multOp\: factor\:
	\end{equation}
	\begin{equation}
		factor \to \mathbf{id}\: |\: \mathbf{constant}
	\end{equation}
\end{center}

\pagebreak
Mit der beschriebenen Grammatik ist der PL/I-Quellcode in Listing \ref{lst:pliifstatement} zulässig.

\begin{lstlisting}[language=PL/I, caption=PL/I-Verzweigung, label={lst:pliifstatement}]
	IF A > B THEN
		CALL proc_1;
	ELSE
		CALL proc_2;
	END
\end{lstlisting}

Nicht zulässig ist hingegen der Ausdruck in Listing \ref{lst:pliwrongstatement}.

\begin{lstlisting}[language=PL/I, caption=Ungültiges PL/I, label={lst:pliwrongstatement}]
	CALL IF THEN A > B proc_1;
\end{lstlisting}

Damit der Computer nach einer Syntax-Regel wie in Gleichung 2 bis 6 formale Sprachen, bzw. PL/I, verarbeiten kann, müssen in einem Programm nach den Syntaxregeln der Grammatik die eingegebenen Ausdrücke verarbeitet werden. 
Das übernimmt der Parser. Ein Parser-Programm wird unter anderem nach der Richtung der Reduktion der Eingabe in einer Grammatik unterschieden.
Entweder erfolgt die Reduktion von Links (LR-Parser), oder von Rechts (LL-Parser).

Um Programmiersprachen mithilfe eines Parser zu verarbeiten und aus dem Eingegebenen-Quellcode Zwischencode zu erzeugen, ist es gängig einen LR-Parser zu verwenden.
Da dieser einen Großteil von kontextfreien Grammatiken syntaktisch analysieren kann.
Auch wird durch die Verarbeitung eine frühe Fehlererkennung möglich.

Je nach Einschränkung der formalen Sprache kann ein Parser sehr komplex sein. 
Grund dafür sind die unterschiedlichen Kombinationsmöglichkeiten von Ausdrücken, die das Programm berücksichtigen muss.

Entsprechend ist auch üblich den LR-Parser für eine Grammatik nicht manuell zu implementieren, denn dies bedarf einen hohen intellektuellen Aufwand. \footcite[Vgl. ][S. 27ff. ]{compibau}
Die verwendeten Algorithmen zur Syntaxanalyse sind häufig komplex, jedoch für jeden Parser verschiedener Programmiersprachen ähnlich. 
Zusätzlich kann die Grammatik von PL/I Mehrdeutigkeiten aufweisen, welche in den Compiler eingearbeitet werden müssen.
\footcite[Vgl. ][S. 262ff. ]{compibau}

Aus diesen Gründen wird in der Regel ein LR-Parser mit einem Compiler-Compiler erzeugt.
Der Entwickler implementiert lediglich eine kontextfreie Grammatik in der erwarteten Darstellung des Compiler-Compilers,
woraufhin der Parser aus dieser erzeugt werden kann. Der gesamte Ein- und Ausgabeverarbeitungsprozess ist in Abbildung \ref{fig:ausgabe} dargestellt.


\dhgefigure[h]{parser-generation.png}[scale=0.6]{Ein- und Ausgabeverarbeitungsprozess des Compiler-Compiler}{fig:ausgabe}[][]
\pagebreak

Auch in der Entwicklung des Transpilers kommt ein Compiler-Compiler zum Einsatz. In dem folgenden Kapitel wird der implementierte Compiler-Compiler beschrieben.

% Hier Grund aus Compilerbau Buch


% TODO Warum 
% Warum braucht ein Compiler eine Grammatik?
% In dem vorangegangen Kapitel wurden unterschiedliche Methoden, Anwendungsgebiete und Formen der Sprachinterpretation eines Computers vorgestellt. Damit die Interpretation von Sprachen korrekt erfolgt, braucht ein Computer Regeln. Grammatiken beinhalten diese Regeln. 

% - Theoretischer Abriss
% - Einordnung der resultate der PA 4
%- PL/1 Syntax Wo zu finden? Welche Version der Sprache? 
%	- Reguläre Ausdrücke Syntax, Beispiel einer Grammatik die ich mit verwende, Typ einer Grammatik
%  - Literatur
%    - Chomsky Hierarchie Bücher
%    - https://www-igm.univ-mlv.fr/~berstel/LivreCodes/Codes.html
%  - Woraus besteht eine Grammatik?
%   - Wie lassen sich Grammatiken der Komplexität nach anordnen?
%  - Chomsky Hierarchie
%  Erst Chomsky Hierachier, dann nach Komplexität einordnen und am Beispiel von Regulären Ausdrücken und PL/I Grammatik einführen.
     
\pagebreak
\subsection{Anwendung von formalen Grammatiken in JavaCC}
% 1. Was ist ein Compiler-Compiler? (Verbindung von formalen Grammatiken zu JavaCC)

Ein Compiler-Compiler wie JavaCC ist eine Technologie mit der aus einer formalen Beschreibung einer Grammatik ein Lexer und ein Parser erzeugt werden. 

Der Lexer und der Parser wenden die in der Grammatik-Datei definierten Regeln an und verarbeiten in einer Java-Klasse die übergebenen Ausdrücke.
Die Darstellung der Grammatik erfolgt in der Regel in einer Art \ac{ebnf}. 
Beispielhafte Compiler-Compiler sind neben JavaCC, Yacc, Antlr und Lexer.


In Kapitel 1.4 wurde bereits vereinfacht eine Syntaxregel aus der PL/I-Grammatik dargestellt. Ähnlich erfolgt auch die Darstellung in einer Grammatikdatei. Folgendes Beispiel zeigt die Darstellung eines \verb+IF ELSE+ Ausdrucks. 


\begin{lstlisting}[language=Java, caption=If Statement aus der Grammatikdatei, label={lst:ifstatement}]
	void if_statement() #BRANCH :
	{}
	{
		< IF >bool_expression()
		< THEN >proc_body()
		[else_statement()]
	}
\end{lstlisting}

In JavaCC besteht die Möglichkeit die Beschreibung von Syntaxregeln in Methoden zu Kapseln.
In Zeile 1 ist der Methodenkopf zu sehen. In diesem Fall erzeugt die Methode \verb+if_statement+ keinen Rückgabwert.
Das durch die Raute gekennzeichnete Symbol ist die Repräsentation im Syntaxbaum und zusätzlich auch die Darstellung im Zwischencode.
Im Körper der Methode wird der If-Ausdruck weiter definiert. Terminalsymbole werden in der JavaCC Grammatik mit den größer-als und kleiner-als Zeichen umrandet. Die Nicht-Terminalsymbole hingegen sind wie in Listing \ref{lst:ifstatement} dargestellt weitere Methoden, die wiederum weitere Ausdrücke beschreiben.

Ähnlich wird bei der Syntaxregel \ref{eqn:start}, so lange reduziert bis lediglich Terminalsymbole übrig bleiben.
Die Methode \verb+bool_expression+ beschreibt einen zulässigen Boolschen Ausdruck, der durch einen weiteren boolschen Operator mit einem weiteren booleschen Ausdruck verknüpft werden kann.

Weiterhin wird in der Methode \verb+proc_body+ beschrieben, welche Ausdrücke weiter zulässig sind. Dazu zählt bspw. auch eine weitere \verb+IF ELSE+ Verzweigung. 

 So werden aus der Grammatikdatei, durch den Compiler-Compiler, nach und nach Java-Klassen erzeugt die Programmroutinen zur Syntaktischen Verarbeitung von PL/I-Ausdrücken beinhalten.
Der Ausschnitt aus der Grammatikdatei in Listing \ref{lst:ifstatement} wird zu dem Java-Quellcode in Listing \ref{lst:ifstatementmethode}.


\begin{lstlisting}[language=Java, caption=Verkürzte If-Statement Methode aus dem Parser, label={lst:ifstatementmethode}]
 final public void if_statement() throws ParseException {
			SimpleNode jjtn000 = new SimpleNode(JJTBRANCH);
			boolean jjtc000 = true;
			jjtree.openNodeScope(jjtn000);
	try {
			jj_consume_token(IF);
			bool_expression();
			jj_consume_token(THEN);
			proc_body();
		
		if (jj_2_30(3)) {
				else_statement();
		} else {
			;
		}
	} catch (Throwable jjte000) {
		if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
		} else {
				jjtree.popNode();
		}
		if (jjte000 instanceof RuntimeException) {
				if (true) throw (RuntimeException)jjte000;
		}
		if (jjte000 instanceof ParseException) {
				if (true) throw (ParseException)jjte000;
		}
				if (true) throw (Error)jjte000;
	}
	//Rest ausgeschnitten
}	
\end{lstlisting}

In Listing \ref{lst:ifstatementmethode} ist zu erkennen, dass die ebenfalls definierten Methoden in der Grammatikdatei, die repräsentativ für die Nicht-Terminal-Symbole sind, auch in der Methode der generierten Parser-Klasse zu Methodenaufrufen führen. Dies ist in Zeile 7 zu sehen. Weiterhin werden Token, also die Repräsentationen der Terminalsymbole, durch die Methode \verb+jj_consume_token+ verarbeitet. Die restlichen Verzweigungen in der generierten Java-Methode prüfen die verarbeiteten Token auf Fehler.

Außerdem wird mit dem Objekt \verb+SimpleNode+ in der Java-Methode aus Listing \ref{lst:ifstatementmethode} ein Knoten im Syntaxbaum erzeugt. Diese Knoten ermöglichen die Verarbeitung des PL/I-Quellcodes durch die weiteren Module des Transpilers.

% Warum ein Compiler-Compiler verwenden?
 
Grammatiken für Cobol und Java sind bereits durch die JavaCC Community öffentlich zugänglich. \footcite[Vgl. ][]{javaccdoku}
Im Fall von PL/I ist keine Grammatik bekannt, weshalb bei der Entwicklung des Transpilers die IBM Language Reference für PL/I die Hauptquelle für die Grammatikdatei ist.   

% Wie wird JavaCC in die Entwicklung des Transpiler eingebunden ? (Hinleitung zur Architektur beschreibung)
Durch die Verwendung des JavaCC Jjtree-Moduls, kann global innerhalb des Projekts auf den Parse-Baum zugegriffen werden. 
Der Syntaxbaum wird unter anderem durch die Module verwendet, die die semantische-Analyse und -Synthese repräsentieren.
Erst durch diese wird der Java-Code erzeugt.
Die gesamte Architektur des Transpilers und dessen weitere Module wird in dem nachfolgenden Kapitel betrachtet. 

\section{Technisches Vorgehen}
\subsection{Verwendete Technologien}
%- Compiler Compiler -> JavaCC: Integration in das Projetk, Grund für die Wahl der Technologie
%In Kapitel 1.4 wurde bereits mit JavaCC eine verwendete Technologie vorgestellt. In diesem Kapitel werden die weiteren verwendeten Technologien vorgestellt.

%- Programmiersprache -> Java: Integration in das Projekt, Grund für die Wahl.
Der Transpiler wurde in der Programmiersprache Oracle-Java der Version 17 entwickelt. 
Java eignet sich als objekt-Orientierte Hochsprache gut für die Entwicklung des Transpilers, da so eine lose Kopplung der Klassen realisiert werden kann und damit eine modulare Bauweise des Softwareprojekts.
Weiterhin zählen die Vorteile die in Kapitel 1.1 für Java erwähnt wurden, ebenso in diesem Fall. Den Administratoren soll die Möglichkeit gegeben werden, Module einfach auszutauschen. 
Damit einhergehend fiel die Wahl auf JavaCC. Ein alternativer Compiler-Compiler für Java, ist Antlr. 

%- IDE -> Eclipse: Integration in das Projekt, Grund für die Wahl.
Der Java-Quellcode des Transpilers wurde in Eclipse geschrieben. Die \ac{ide} Eclipse ermöglicht eine kostenlose Entwicklung, Verwaltung, Überprüfung und Kompilierung von Java Software-Projekten. Weiterhin bietet Eclipse ein breites Software-Repository an Plugins um die Funktionalität der  \ac{ide} zu erweitern. Dadurch ist eine Integration von JavaCC in die  \ac{ide} möglich und erleichtert die Entwicklung des Parsers ebenfalls.

%- Maven -> Dependency Management: Integration in das Projetk, Grund für die Wahl der Technologie
Es wurde das Software-Projektmanagement-Werkzeug Maven eingesetzt. Maven löst mithilfe des \ac{pom} Abhängigkeiten. 
Dadurch werden Benutzer und Administratoren bei dem Build-Prozess entlastet.

%- Testing -> JUNit Tests: Integration in das Projetk, Grund für die Wahl der Technologie
Zum Testen der Anwendung wurde das Java-Test Framework JUnit 5 verwendet. Es wurde für nötige Klasse zugehörige Testklassen geschrieben. In den Testklassen wurde komplexere Methoden isoliert getestet.
Die Wahl von JUnit ist begründet durch die einfache Handhabung, der Kompatibilität mit der IDE Eclipse und dem Projektmanagement Werkzeug Maven. Weiterhin ist JUnit mit eines der bekanntesten Unit-Test-Frameworks für Java-Quellcode. Alternativen wären etwa gewesen TestNG \footcite[Vgl. ][]{testng} oder Mockito \footcite[Vgl. ][]{mockito}.

%- Platform -> Spring
Für die Entwicklung des Frontends wurde das Java Framework Spring-boot verwendet.
Dabei wurde das Web-Interface mit der CSS-Softwarebibliothek Bootstrap gestaltet.
Spring-Boot wird für das behandeln von REST-Anfragen verwendet und bindet über eine API Schnittstelle den Transpiler ein.
Dadurch wird eine Interaktion über den Browser möglich.

Die Entwicklungsphase folgte jedoch nach der Konzeptionsphase, in der die Architektur der Anwendung ausgearbeitet und später als Quellcode realisiert wurde. 
Im nächsten Kapitel wird dieses Architekturbild vorgestellt.

\pagebreak
\subsection{Architektur} 

In Abbildung \ref{fig:modules} ist eine Grob-Ansicht der Module des Transpilers dargestellt.

\dhgefigure[h]{AbstraktesUML_1.png}[scale=0.5]{Aufbau des Transpilers}{fig:modules}[][]

% Wie sind die Module momentan gebaut?
% App Modul
Die Verarbeitung des PL/I-Quellcodes beginnt mit dem App-Modul. Das App Modul ist die Schnittstelle für alle weiteren Module. Ein Modul kann durch die Instanziierung der Hauptklasse des zugehörigen Moduls eingefügt werden. Entfernt wird das Modul durch das Löschen der Instanz. Das App-Modul beinhaltet auch die \verb+main+ Methode und ist somit auch der Startpunkt der \ac{jvm}.

Der Scanner wird als erstes instanziiert. Dieser liest aus der Konfigurationsdatei den Pfad der zu übersetzenden PL/I Datei. Die Datei wird als \verb+InputStream+ an den Parser übergeben.
Der durch JavaCC erzeugte Parser wird ebenfalls im App-Modul instanziiert. Dieser behandelt den PL/I-Quellcode entsprechend der vorher definierten Grammatik.  Während des Parsings werden Variablen-, Prozeduren-, oder Packagebezeichner des PL/I-Quellcode in die Symboltabelle eingefügt. Das Ergebnis des Parsers ist ein Syntax-Baum. 
\pagebreak
In Abbildung \ref{fig:parsetree} ist exemplarisch ein Syntaxbaum des Transpilers abgebildet der eine Variablendeklaration und die Definition einer Prozedur darstellt.

\dhgefigure[h]{parsetree-example.drawio.png}[scale=0.65]{Beispielhafter Syntaxbaum des PL/I-Parsers}{fig:parsetree}[][]

Ist der Syntaxbaum entsprechend erzeugt, wird dieser durch das Checker-Modul weiterverarbeitet. In diesem Modul wird die semantische Analyse des Quellcodes durchgeführt. In der aktuellen Version erfolgt hauptsächlich eine Typ-Überprüfung der initialisierten Variablen.

% @review: Hier erwähnen wie Configdatei bzw. Scanner den Ausgabe Ordner beeinflussen wenn das implementiert wurde.
Das Mapper-Modul repräsentiert die Synthese des Syntaxbaums in Java-Zielcode. Der Syntaxbaum wird dazu Stück für Stück abgearbeitet und mit entsprechenden Javaausdrücken übersetzt.

% @todo: Wie sind Module zueinander abhängig?
Um einen Überblick über Abhängigkeiten der Module zu verschaffen, zeigt
Abbildung \ref{fig:modulesdep} aktuell die Beziehungen der Module untereinander.

\dhgefigure[h]{Beziehungen_Modules.png}[scale=0.65]{Die Abhängigkeiten der Module}{fig:modulesdep}[][]
\pagebreak

In Abbildung \ref{fig:modulesdep} ist zu erkennen, dass die Abhängigkeiten unter den Modulen eine kaskadierende Form aufweisen.
Diese Form hat den Vorteil, dass Module aus dieser Kette verändert werden können, ohne vertikal verlaufende Module direkt zu beeinträchtigen.
Dennoch ist an dieser Stelle zu erwähnen, dass kein Modul isoliert betrachtet werden darf. Denn eine Veränderung eines Moduls bedeutet, dass auf horizontaler 
Ebene die Verarbeitung verändert wird.

% Wie sind die Module momentan gebaut?
Jedes Modul gibt die Ergebnisse weiter in die Pfeilrichtung bis ein Zielcode entsteht oder eine Fehlermeldung.

% @todo: Wie wird es erweitert?
Der Administrator kann die Module erweitern oder ersetzen.
Dabei sollte jedoch die in Abbildung \ref{fig:modulesdep} dargestellte Kaskade der Module untereinander berücksichtigt werden.
Entscheidet sich der Administrator dazu, etwa eine Methode zu entfernen und ein selbst entwickeltes zu verwenden, ist lediglich die bisherige 
Referenz zu ersetzen.
%In der vorherigen Version des Transpilers wurde etwa die Lexer-Klasse entfernt und die Klassen des Compiler-Compilers verwendet.
%Der Quellcode des Lexer besteht jedoch und ist lediglich als Deprecated markiert. Die erneute Verwendung des Lexer würde über den Aufruf der Methode in Main erfolgen.
%Hingegen wären hier weitere Schritte notwendig, wie etwa das einfügen einer temporären Datei, die von dem Parser als InputStream entgegen genommen wird und weiter verarbeitet wird.

Nachdem nun ein Überblick über die Architektur gegeben wurde, soll in Kapitel 2.3 eine Detailansicht des Transpilers erfolgen.
Ab diesem Punkt soll genauer auf den Quellcode der einzelnen Module eingegangen werden, um nachzuvollziehen wie der Transpiler den PL/I-Quellcode
in Java-Zielcode umwandelt.

%Bausteine
%- Software Architektur
	%- Planen mithilfe eines UML
	%- UX Design 
    %    - zweite Diagramm, des Benutzerfluss
    %    - wie Benutzung abläuft
	%	- Website?
	%	- Docker Container?
%- Fehlertracking
%- Struktuierung des Programms, sodass ein Benutzer es selbständig erweitern kann

%\subsection{Aspektorientierte Programmierung}
%- Wie funktioniert Aspektorientiert Programmierung?
%	- Wie Löse ich mit Aspektorientierter Programmierung konkrete Probleme?
%- JavaBeans
%- Spring
%	- Wie setzt Spring Aspektorientierte Programmierkonzepte ein?
 \pagebreak
\subsection{Module des Transpilers}
%Wie in dem vorangegangen Kapitel schon dargestellt, werden in jedem Modul
%die Verarbeitungsschritte aus Abbildung \ref{fig:transpiler} implementiert.
%In diesem Kapitel sollen die Module nach ihrer Verarbeitungsreihenfolge vorgestellt werden.
%Dabei soll ein \ac{uml}-Diagramm je zu beginn der Unterkapitel verdeutlichen wie die Klassen
%in den Modulen zueinander aufgebaut sind. In jedem Diagramm wird auch auf die Einbindung in die App-Klasse eingegangen.
%Die Beschreibung beginnt mit dem Scanner.

\subsubsection{Der Scanner und Parser}
\paragraph{Scanner}
Wie Kapitel 1.5 eingeführt wird der Parser vollständig durch 
JavaCC generiert.
Damit der Parser den PL/I-Quellcode in die Zwischencode Darstellung übersetzen kann,
braucht dieser eine PL/I-Datei, die als Input-Stream übergeben wird.
Den Pfad zu der Datei gibt der Administrator in der Konfigurationsdatei an.
Das Modul Scanner liest die Konfigurationsdatei und versorgt den Parser mit notwendigen Ressourcen.
Abbildung \ref{fig:scannermodul} zeigt das UML-Diagramm des Scanner Moduls.

\dhgefigure[h]{scanner-klasse-uml.drawio.png}[scale=0.68]{Das Scanner-Modul}{fig:scannermodul}[][]

Das Scanner Modul besteht aus der Klasse \verb+InputReader+. 
Die \verb+InputReader+ Klasse liest und verarbeitet die Konfigurationsdatei. Die Methode \verb+getInputFilePath+ gibt den Pfad der PL/I-Quellcode Datei als String zurück.
Dieser String wird beim Aufruf der \path{getInputFile} Methode benötigt, um aus der Datei einen \verb+InputStream+ zu erzeugen.
Mithilfe des InputStreams kann die Datei als Parameter an den Parser in der Klasse \verb+App+ im Modul \verb+App+
übergeben werden. 

%\paragraph{Lexer}
%Die Klasse Lexer des Moduls Scanner enthält den ehemals selbst geschriebene Lexer für die lexikalische Analyse. Dadurch das dieser Prozess nun vollständig von dem JavaCC-Parser übernommen wird, wurde die Methode \verb+getToken+ überflüssig. Diese ist als veraltet mit der Kennung 'Deprecated' beschrieben, sie kann im Projekt noch verwendet werden, jedoch mit einem Risiko das die Ergebnisse der Methode nicht korrekt sind. 
%Zu einem späteren Zeitpunkt ist denkbar den selbstgeschriebenen Lexer zu optimieren und erneut einzubinden. Weshalb dieser nicht gelöscht wurde. 
%Weitere Methoden in dieser Klasse werden ebenfalls nicht länger von Klassen aus anderen Modulen verwendet. 

\paragraph{Parser}
Das Parser-Modul deckt die lexikalische und syntaktische Analyse des PL/I-Quellcodes ab.
Wie schon in Kapitel 1.4 erwähnt werden jegliche Klassen des Parsers durch die \verb+.jjt+ Grammatikdatei generiert. Da diese Klassen sehr umfangreich sind, werden diese in Abbildung \ref{fig:moduleparser} lediglich in abgekürzter Form dargestellt. 

\dhgefigure[h]{parser-module-uml.drawio.png}[scale=0.41]{Das Parser-Modul}{fig:moduleparser}[][]
\pagebreak

Der Parser wird über die Klasse \verb+Pl1Parser+ in dem App Modul instanziiert. In der Parser-Klasse sind auch jegliche manuell geschriebenen Methoden aus der Grammatikdatei integriert. 
Dazu gehören etwa die Methode \verb+installId+, sowie weitere. 

Die ebenfalls in der Grammatikdatei definierten Token, 
werden in \path{Pl1ParserConstants} als Konstanten definiert. 
Während der Lexikalischen Analyse wird die Klasse Token verwendet, um Terminalsymbole zu verarbeiten. 
Schlussendlich wird einhergehend mit der Klasse \verb+Pl1Parser+ geprüft, ob der PL/I-Quellcode zulässig ist. 
Diese beinhaltet die Methoden der in der Grammatikdatei definierten nichtterminalen Ausdrücke, wie zum Beispiel die Methode \verb+if-statement+. 
Hier ist auch der Großteil der Verarbeitungslogik des Parser-Moduls implementiert.

Wird ein Ausdruck während der Verarbeitung in der Pl1Parser-Klasse als nicht zulässig  interpretiert wird eine \verb+ParseException+ geworfen, die in der Klasse \verb+ParseException+ definiert ist.

Ein Knoten des Syntaxbaums wird durch ein Objekt der Klasse \verb+SimpleNode+ erzeugt. Durch die Methoden \verb+clearNodeScope+ und \verb+closeNodeScope+ wird der verarbeitete Ausdruck mit bspw. der Repräsentation \verb+VAR+ in den Syntaxbaum eingefügt. 
Siehe Abbildung \ref{fig:parsetree} So verarbeitet der Praser des Transpilers Knoten für Knoten den PL/I-Quellcode. 

Hat der Parser ein nichtterminalsymbol gefunden, wird die Methode \verb+installIds+ aufgerufen und der Bezeichner unter bestimmten Bedingungen in die Symboltabelle eingefügt. 
Ein Bezeichner wird nicht eingefügt, 
wenn dieser schon vorhanden ist und den selben Sichtbarkeitswert hat.

Dabei wird das Modul \verb+SymbolTable+ implementiert und mit der Methode \verb+insertId+ ein Bezeichner in die Symboltabelle eingefügt. Im folgenden Unterkapitel wird das Modul der Symboltabelle genauer beschrieben. 

\pagebreak
\subsubsection{Symboltable}
Die Symboltabelle speichert die PL/I-Symbole in einer Hashtable ab. Mit ihr sollen die anderen Module
erkennen können ob es sich bei dem ausgewählten Token um ein PL/I-Symbol handelt, oder um einen Bezeichner.
In Abbildung \ref{fig:symboltable} ist das Modul \verb+symboltable+ in \ac{uml} dargestellt.

\dhgefigure[h]{symboltable-module-uml.drawio.png}[scale=0.6]{Symboltabellen-Modul}{fig:symboltable}

Das Modul \verb+Symboltable+ enthält die Klasse \verb+SymbolTable+
sowie die Enums \verb+Pl1Symbols+ und \verb+Template+.

% Wie funktioniert SymbolTable und Pl1Smybols?
Die Klasse \verb+SymbolTable+ wird beim instanziieren des Objekts mit den Werten aus dem Enum \verb+Pl1Symbols+ initialisiert. Von der Symboltabelle soll während der Laufzeit nur eine Instanz existieren. 
Dazu wird in der Klasse Symboltable die Instanz symbols erzeugt. Falls diese nicht bereits instanziiert wurde, kann sie instanziiert werden. Falls sie hingegen bereits instanziiert ist, wird lediglich die Instanz zurückgegeben.
Über die Methode \verb+getInstance+ können andere Module auf diese Instanz zugreifen.

Wenn ein Bezeichner in die Symboltabelle eingefügt wird, wird ein String für den Bezeichner, ein String für den Typ, ein String für die Sichtbarkeit und ein String für die Hierarchiestufe der Variable hinterlegt. So können in darauffolgenden Arbeitsschritten wie in der semantischen Analyse, die Werte korrekt verarbeitet werden.

Die restlichen Methoden der Klasse \verb+SymbolTable+ dienen der dezidierten Abfrage von Werten. Die Methode \verb+getSymbolModifier+ wird dazu verwendet den Sichtbarkeitswert eines Bezeichners auszugeben.

% Wie funktioniert Template?
Der weitere Enum \verb+Template+ dient, im Prozessschritt der Synthese dazu, den Syntaxbaum in Java-Code umzuwandeln.
In diesem Enum sind Java-Quellcodeausschnitte hinterlegt, die PL/I-Quellcode repräsentieren können. Sie werden in dem Mapper Modul verwendet,
um nach und nach den Java-Zielcode zu erzeugen.

Um den Syntaxbaum zu verwenden muss der Syntaxbaum Stück für Stück überprüft werden. Dieser Prozess wird als semantische Analyse bezeichnet und erfolgt im Checker Modul.
 
 \pagebreak
\subsubsection{Checker}
Das Checker-Modul prüft die Semantik des PL/I-Quellcode.
Dieses Modul ist repräsentativ für die semantische Analyse. 
Eine Aufgabe des Checker-Moduls ist es die Typ-Definition von Variablen mit den Zuweisungen abzugleichen.
Wird beispielsweise dem Decimal-Typ ein alphanumerischer Wert zugewiesen, soll dieses Modul den Benutzer auf einen Syntaxfehler hinweisen. Um solche semantischen Fehler zu erkennen, wird das Checker-Modul nach dem Vorbild des Composite Design-Patterns implementiert. Dadurch kann mit einer Abstrakten Klasse, Objekte die diese Implementieren als auch ihre Kompositionen einheitlich behandelt werden.
In Abbildung \ref{fig:checker} ist das \ac{uml} des Checker Modul abgebildet.

\dhgefigure[h]{checker-module-uml.png}[scale=0.55]{UML des Checker Modul}{fig:checker}

Dabei hilft das Composite-Design Pattern für alle Typ-Klassen, einheitliche Validierungstrukturen zu definieren.
Etwa in Abbildung \ref{fig:checker} ist die Methode \verb+getType+ definiert, um die korrekte Zuweisung von Variablen zu erschließen. 

Weiterhin kann mit dem Design-Pattern die Speicherstruktur, also Variable, Array oder weitere die einer Überprüfung unterzogen wird, in der Composite-Klasse dargestellt werden.
In Abbildung \ref{fig:checker} repräsentiert die \verb+VarChecker+ Klasse das Composite.
Eine mögliche Erweiterung um weitere Speicherstruktur-Elemente wie einem Array ist somit denkbar.

In dem Checker-Modul wird zum ersten Mal auf den Syntaxbaum, das Ergebnis des Parser Moduls, zugegriffen.
Um auf alle Knoten des Syntaxbaums zuzugreifen, wird eine Methode definiert die zum iterieren des Syntaxbaums benötigt wird.
Diese Methode ist auch für weitere Module brauchbar, weil auch diese durch den Syntaxbaum iterieren sollen.
Dazu wurde in der \verb+DecimalChecker+ Klasse die Methode \verb+iterateTree+ implementiert.
Um den Syntaxbaum erfolgreich zu iterieren, wurde ein depth-first Suchalgorhitmus rekursiv in dieser Methode implementiert.
Die Iterationsweise des Algorhitmus im Zusammenhang mit dem Syntaxbaum ist in Abbildung \ref{fig:parsetreealgo} dargestellt.

\dhgefigure[h]{parsetree-example-searchalgo.png}[scale=0.6]{Beispielhafte Iteration des Syntaxbaums}{fig:parsetreealgo}[][]

So wird es möglich, gezielt nach Knoten zu suchen und die Attribute des Knotens auszulesen.
In dem Checker Modul wird dieser Algorithmus vor allem benutzt, um festzustellen, welche Variablen mit welchem Typ und welchem Bezeichner deklariert wurden und ob dieser Bezeichner in einem \verb+ASSIGN+ Knoten wiederverwendet wurde.

So kann der Syntaxbaum mit seinen Attributen vollständig überprüft werden.
Die Überprüfung ist dann abgeschlossen, wenn die Iteration des Suchalgorithmus wieder bei dem Ausgangspunkt angekommen ist. In Abbildung \ref{fig:parsetreealgo} ist das der Knoten \verb+PRORGRAM+.

Wurde kein Fehler entdeckt beginnt die Transformation des Syntaxbaums nach Java. Falls jedoch ein Fehler entdeckt wurde, wird eine entsprechende Fehlermeldung angezeigt.

Das Checker Modul bereitet den Syntaxbaum entsprechend so vor, dass dieser weiterhin in der Synthese verarbeitet werden kann.
Die Synthese wird durch das Mapper-Modul implementiert und ist Bestandteil des nächsten Kapitels.
 
 \pagebreak
\subsubsection{Mapper}
Das Mapper Modul transformiert die Zwischencode Repräsentation in den Java-Zielcode. Dazu wurde das Mapper-Modul nach dem Strategy Desgin-Pattern entworfen.
In Abbildung \ref{fig:mapper} ist das UML des Mapper Moduls zu sehen. 
Das Strategy-Design-Pattern ermöglicht die Zuweisung einer Klasse, die eine konkrete Strategie repräsentiert, über ein Interface. Unter bestimmten Bedingungen kann die deklarierte Variable mit einer anderen Strategie-Klasse gesetzt werden. Dadurch wird die Verwendung verschiedener Algorithmen zur Laufzeit ermöglicht. 

\dhgefigure[h]{mapper-module-uml.png}[scale=0.58]{UML des Mapper Moduls}{fig:mapper}

Die Klasse \verb+Mapper+ wird in der Main-Methode des Projektes instanziiert. Als Parameter wird der Wurzelknoten des Parssebaums übergegeben,
woraufhin mithilfe der \verb+iterateTree+ Methode erneut durch den Parsbaum iteriert wird. Hier wurde ebenfalls der Depth-first Suchalgorhitmus implementiert um jeden Knoten zu verarbeiten. 

Jeder Knoten wird über eine Konstante mit einer zugehörigen Identifizierungsnummer überprüft, die in dem Interface \verb+Pl1ParserTreeConstants+ des Parser Moduls definiert sind. 

In der Klasse \verb+AstMapper+ finden sich jegliche Identifikationsnummern der Knoten. Hier werden diese mit den zugehörigen Mapper-Klassen in einer HashMap gespeichert.

Die Mapper Klassen stellen die unterschiedlichen Vorgehensweisen in dem Strategy-Pattern dar. Sie implementieren alle das \path{ITranslationBehavior} interface und aufgrund dessen eine \verb+translate+ Methode, die den übersetzten Ausdruck zurückgibt. 

In der \verb+iterateTree+ Methode wird für jeden Knoten überprüft, ob eine solche Mapper-Klasse in der HashMap instanziiert wurde.
Falls eine Klasse vorhanden ist, wird in der TranslationBehavior Klasse das entsprechende Strategie-Objekt
des Typs \path{ITranslationBehavior} in der
Mapper Klasse gesetzt. So wird die Translate-Methode der aktuell gesetzten Klasse aufgerufen und der Syntaxbaum-Knote nach Java übersetzt.

% wie funktioniert der PicturemMapper
Eine exemplarische Mapper Klasse ist etwa die \verb+PictureMapper+ Klasse. Die Klasse PictureMapper enthält Zeichenkettenbeschränkungen des PL/I-Picture Typs und deren Übersetzung als Regulären Ausdruck.
Mit der \verb+getRegex+ Methode der \verb+PictureMapper+ Klasse wird der übersetzte Reguläre Ausdruck als String zurückgegeben.
Der PL/I-Ausdruck \verb+(4)A+ wird etwa zu dem Regulären Ausdruck \verb+[A-Za-z ]{4}+.   


Neben der PictureMapper Klasse erzeugen weitere Mapper Klassen Knoten für Knoten den Java-Zielcode. 
Alle Ausdrücke werden in einer Arraylist mit dem Namen \verb+javaExpression+ der Mapper Elternklasse  gespeichert.
Wenn über jeden Knoten des Parse-Baums iteriert wurde, ist das Programm vollständig übersetzt.


Dabei kann es jederzeit zu Fehlern durch eine Fehlerhafte Benutzereingabe kommen.
Entsprechend sollte der Benutzer auf die Probleme hingewiesen werden.
In dem Modul Errorhandling werden Fehlermeldungen definiert und von anderen Modulen implementiert. Kapitel 2.4 gibt eine Übersicht über die verwendeten Fehlermeldungen.

\pagebreak

\subsection{Fehlerbehandlung}
Die Fehlerbehandlung wird im Modul Errorhandling organisiert.
In diesem wurden Kind-Klassen der Exception Klasse der Java Standard Bibliothek implementiert.
Allgemein wurde versucht, möglichst wenig selbstdefinierte Exception Klassen zu erstellen.
In der Tabelle \ref{tab:exceptiontabel} sind die verwendeten Exceptions dargestellt.

\begin{table}[h]
	\centering
	
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		\textbf{Exception} & \textbf{Quelle}  \\
		\hline
		\verb+IncorretInputFileException+ & Errorhandling-Modul  \\
		
		\verb+LexicalErrorException+ & Errorhandling-Modul  \\
		
		\verb+TypeMappingException+ & Errorhandling-Modul \\
		
		\verb+ParseException+ & Parser-Modul \\
		
		\verb+MappingException+ & Errorhandling-Modul \\
		
		\verb+IOExcpetion+ & Java-IO-Package \\
		
		\verb+NumberFormateExcpetion+ & Java-Lang-Package \\
		
		\verb+IllegalArgumentException+ & Java-Lang-Package \\
		
		\verb+NullPointerException+ & Java-Lang-Package \\
		
		\verb+DuplicateRequestException+ & Jdi-Request-Package \\
		\hline
		
	\end{tabularx}
	
	\caption{Liste der verwendeten Exceptions \label{tab:exceptiontabel}}
\end{table}
Die \verb+IncorretInputFileException+ wird geworfen, wenn
es sich bei der Eingabedatei nicht um eine PL/I-Datei handelt.
Der Transpiler akzeptiert lediglich das Dateiformat \verb+.pli+.

Enthält dabei ein zu übersetzender Ausdruck eine Variable des Typs Picture, soll die LexicalErrorException verhindern, dass ein fehlerhafter Picture-Ausdruck übersetzt wird.
Diese Fehlermeldung eignet sich auch weiterhin um Lexikalische von Syntaktischen Fehlern zu unterscheiden. Da jedoch in der aktuellen Version des Transpilers die lexikalische Analyse und syntaktische Analyse von dem Parser-Modul übernommen werden, wird auch auf die ParseException zurückgegriffen.

Der Benutzer wird durch die \verb+ParseException+ darauf hingewiesen, wo ein Fehler auftritt und welche Schritte unternommen werden können um den Fehler zu beheben.
Wird etwa ein syntaktisch falscher Ausdruck an das Parser-Modul übergeben, verarbeitet dieser den Ausdruck
bis zu der Stelle, an der die definierte Grammatik nicht länger greift.
Der PL/I-Parser wirft die \verb+ParseException+ und gibt in dieser die Zeilen- und Spaltennummer des
entstanden Fehlers an.

Daraufhin überprüft das Checker-Modul nochmal die Zwischencode-Erzeugung des Parsers.
Da das Checker-Modul aktuell lediglich einen Typ-Checker implementiert, existiert aktuell nur eine \verb+TypeMappingException+.
Diese wird immer dann geworfen, wenn der Typ einer deklarierten Variable mit einem unpassenden zugewiesen wird.
Für weitere semantische Analyseschritte sind ebenfalls weitere Exceptions denkbar. Allgemein dient das Checker-Modul lediglich der Fehlererkennung und Unterbrechung des Transformationsprozesses.

Mithilfe der \verb+MappingException+ wird vor der Rückgabe der \verb+translate+ Methode des Mapper-Moduls überprüft ob 
die benötigten Werte die je nach übersetzten Ausdruck variieren, korrekt aus dem Syntaxbaum verarbeitet wurden.
Es ist zwar zu erwarten das der Parser einen solchen Fehler erkennt, dennoch soll nach Möglichkeit vermieden werden, dass ein fehlerhaftes Programm Transformiert wird. Die restlichen Standard Java-Exceptions werden auch in dem zu erwartenden Zusammenhang eingesetzt.

In der aktuellen Version des Transpilers werden nicht alle PL/I-Syntaxelemente eingebunden.
In der PL/I-Sprachreferenz werden mehr als 300 unterschiedliche Funktionalitäten der Sprache beschrieben. \footcite[Vgl. ][S. 5ff.]{pliref}
Davon wurden ca. 65 implementiert, und übersetzt nach Java wurden ca. 50.
Das hat zur Folge, dass es wahrscheinlich ist, dass der Benutzer auf eine ParseException stoßen wird.
Aufgrund der beschränkten Arbeitszeit wurden lediglich wesentliche Syntaxelemente der Programmiersprache implementiert.
Dazu zählen Deklarationen, Kontrollflussanweisungen, sowie Ein- und Ausgabeströme.
In dem nachfolgenden Kapitel werden diese Kernfunktionen vorgestellt und die Übersetzungsentscheidung
diskutiert. 

\pagebreak
\section{Technische Spezifikation}
\subsection{Ausführung des Transpilers}

% Importieren in Eclipse
Für die unterschiedlichen Benutzergruppen werden verschiedene Nutzungsmöglichkeiten des Transpilers angeboten. Diese umfassen die Verwendung über die \ac{ide} Eclipse und das Webinterface.

\paragraph{Eclipse}
Die \ac{ide} Eclipse kann verwendet werden, um den Transpiler zu nutzen. Diese Herangehensweise ist besonders interessant für Administratoren, die den Quellcode des Transpilers selbst erweitern möchten.
Zuerst sollte das Projekt aus dem GitHub-Repository mit Git in das lokale Verzeichnis geladen werden.
In Listing \ref{lst:gitclone} ist der Git-Befehl, zum laden des Remote-Repositories dargestellt. 

\begin{lstlisting}[language=bash, caption=Klonen des Transpiler Repositories, label={lst:gitclone}]
git clone https://github.com/lhahner/pl1-code-transpiler.git
\end{lstlisting}

Daraufhin ist es möglich, das Maven-Projekt in Eclipse zu importieren. Unter der Registerkarte "Datei", kann das Projekt importiert werden. Im nächsten Menüfenster sollte der Ordner ausgewählt werden, in dem die \verb+pom.xml+ Datei liegt. Ist der Ordner korrekt ausgewählt, wird das Projekt in Eclipse importiert. 

Das Verzeichnis \verb+src/main/java/res/pli+ ist das Standard-Eingabeverzeichnis. Hier kann eine PL/I-Datei abgelegt werden, die übersetzt werden soll. Es ist auch möglich, das Standard-Eingabeverzeichnis zu ändern. 

Im Ordner \path{src/main/java/res/config} liegt die Datei \verb+config.properties+. 
In dieser Datei kann die Variable \verb+PATH+ geändert werden, 
um PL/I-Quellcode aus einer anderen Projektstruktur zu transformieren.
\pagebreak
\paragraph{Webanwendung}
Um es dem Benutzer leicht zu gestalten den Transpiler zu verwenden wurde mithilfe des Spring-Boot Frameworks eine Webanwendung entwickelt.
Die Webanwendung enthält neben der Integration des Transpilers auch Dokumentationen der bisherigen Versionen.
Um die Webanwendung zu verwenden muss erneut eine GitHub-Repository geladen werden. Verwendet wird der Git-Befehl in Listing
\ref{lst:gitcloneweb}

\begin{lstlisting}[language=bash, caption=Klonen des Repositories der Webschnittstelle, label={lst:gitcloneweb}]
	git clone https://github.com/lhahner/plitra-web.git
\end{lstlisting}

Um die Anwendung zu starten sollte mit der Kommandozeile in den Projektordner navigiert werden.
Daraufhin kann das Spring-Boot Projekt gestartet werden. In Listing \ref{lst:springboot} ist der Befehl beschrieben um die Spring-Boot Anwendung lokal zu starten.

\begin{lstlisting}[language=bash, caption=Build Spring-Boot Projekt, label={lst:springboot}]
	.\mvnw spring-boot:run
\end{lstlisting}

Die Spring-Boot Anwendung ist unter Port 8080, lokal erreichbar.
Hier kann entweder unter "Documentation"  die Dokumentation der bisherigen Versionen eingesehen werden und unter "Transpile"
die eigentliche Anwendung aufgerufen werden.
Unter "Transpile"  öffnet sich die grafische Oberflächliche aus Abbildung \ref{fig:translator}.

\dhgefigure[h]{translate-view.png}[scale=0.5]{Grafische Oberfläche des Transpilers}{fig:translator}[][]
\pagebreak
Auf der rechten Seite der grafischen Oberfläche kann der PL/I-Quellcode eingefügt werden und auf der linken Seite erscheint dann entweder der übersetze Java-Zielcode oder eine Fehlermeldung.
Der Benutzer kann diese Schnittstelle benutzen um einfache PL/I-Programme zu übersetzen, oder um die Java-Repräsentation eines PL/I-Ausdruck anzusehen.

Die Syntaxhervorhebung soll dem Entwickler ein Vertrautes gefühl geben und das erkennen von Tippfehlern erleichtern.
Für die Syntaxhervorhebung wurde die Lösung Codemirror implementiert. Da Codemirror keine Unterstützung für PL/I bietet, wurde stattdessen die Syntax von PL/SQL verwendet. Die Java-Syntaxhervorhebung stammt ebenfalls von Codemirror. Wichtig ist an dieser Stelle anzumerken, dass die grafische Oberfläche derzeit nur lokal funktioniert und nach jeder Übersetzung neu gestartet werden muss. Die grafische Oberfläche wird in Zukunft verbessert und weiter angepasst.

In den nachfolgenden Kapiteln werden PL/I-Strukturen beschrieben und die Transformation nach Java diskutiert.
\pagebreak

\subsection{Transformationsstrategien}
\subsubsection{Deklarationen und Zuweisungen}
Die erste Version des Transpilers enthielt lediglich die Transformation von PL/I-Datentypen in nicht-primitive Java Datentypen wie etwa die Klasse \verb+DECIMAL+, \verb+CHAR+ oder \verb+PICTURE+.

%In der Version des Transpilers aus der Projektarbeit IV wurden selbst geschriebene, nicht-primitive Datentypen verwendet, um die PL/I-Datentypen in entsprechenden Java-Zielcode zu übersetzen. Dies ist für Deklarationen ausreichend.

Bei der Verwendung dieser Datentypen in einer Programmroutine wurden jedoch Mängel des Designs sichtbar. Ein Beispiel hierfür ist die \verb+DECIMAL+-Klasse.

Werden in dem PL/I-Quellcode etwa die deklarierten Variablen verwendet um mathematische Berechnungen zu erstellen, ist dies ohne Probleme mit den mathematischen Standard Operatoren wie Plus oder Minus möglich.

Um solche Ausdrücke auch in Java mit einem \verb+DECIMAL+-Objekt zu ermöglichen, muss die Klasse \verb+DECIMAL+ erweitert werden.
Denn in Java ist es nicht möglich, nicht-primitive Datentypen zu verrechnen, ohne vorher eine Methode zu schreiben, die diese Operation realisiert. 
Bei der Implementierung der Methoden können die Standard-Operatoren nicht überladen werden, wie es in C++ der Fall ist.

Listing \ref{lst:pliarithmeticexpression} soll demonstriert wie die Übersetzung eines arithmetischen Ausdrucks aussehen könnte.
Wäre in der Klasse \verb+DECIMAL+ für jede arithmetische Operation eine Methode definiert, wäre die Übersetzung wie in Listing \ref{lst:pliarithmeticexpression} denkbar.

%testing Side-by-side
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Transformation DECIMAL}, label={lst:pliarithmeticexpression}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DCL var_1 FIXED DECIMAL(3) INIT(2);
 DCL var_2 FIXED DECIMAL(3) INIT(2);
 DCL var_3 FIXED DECIMAL(5);
		
 proc_1: PROC;
	var_3 = var_1 + var_2;
 END proc_1;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DECIMAL var_1 = new DECIMAL(2).INIT(2);
 DECIMAL var_2 = new DECIMAL(2).INIT(2);
 DECIMAL var_3 = new DECIMAL(5);
		
 public void proc_1() {
	var_3.INIT(var_1.add(var_2));
 }
	\end{lstlisting}
\end{minipage}

Für die weitere Übersetzung syntaktischer PL/I-Strukturen könnte die Entscheidung für eine solche Lösung die Lesbarkeit des übersetzten Programms beeinflussen. Beispielsweise könnte die Verwendung sowohl arithmetischer als auch boolescher Operatoren in einer Verzweigung den Java-Zielcode komplex wirken lassen. 

Wenn das \verb+DECIMAL+-Objekt durch einen primitiven Datentyp ersetzt werden würde, ist eine eins-zu-eins Transformation des zugewiesenen arithmetischen Ausdrucks in Listing \ref{lst:pliarithmeticexpression} möglich. Um die Längenbeschränkung aus PL/I auch in Java zu berücksichtigen, könnte die Implementierung einer Validierungsannotation erwogen werden.

Mithilfe der Jarkarta-Validations Software-Bibliothek kann eine Annotation erzeugt werden, die mittels Java-Reflection überprüft wird. \footcite[Vgl. ][]{jakarta}
Dazu wird der Import als Boiler-Plate-Code  notwendig. 
Die Übersetzung des Ausdrucks ist in Listing \ref{lst:annotationdecimal} dargestellt.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Transformation DECIMAL}, label={lst:annotationdecimal},
		basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DCL var_1 FIXED DECIMAL(3) INIT(2);
 DCL var_2 FIXED DECIMAL(3) INIT(2);
 DCL var_3 FIXED DECIMAL(5);
		
 proc_1: PROC;
	var_3 = var_1 + var_2;
 END proc_1;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "},
		basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 public @Decimal(3) double var_1 = 2;
 public @Decimal(3) double var_2 = 2;
 public @Decimal(5) double var_3;
		
 public void proc_1() {
	var_3 = var_1 + var_2;
 }
	\end{lstlisting}
\end{minipage}

Durch diese Gestaltung ist auch die Einbindung und Erweiterung des übersetzen PL/I-Quellcode erleichtert. In diesem Zusammenhang wird in der weiterführenden Entwicklung die Beschränkung der Länge mit Annotationen gelöst. So kann eine semantische nähe zu Java hergestellt werden und gleichzeitig der Wiedererkennungswert von PL/I beibehalten werden.

Da auch weitere PL/I-Datentypen wie etwa der \verb+PICTURE+ oder \verb+BINARY+ Typ mit dieser Lösung leichter implementiert werden können, werden in zukünftigen Versionen des Transpilers auch hier die eigen definierten Klassen ersetzt.
Aktuell ist eine Zuweisung von Werten lediglich mit einer Variable des Typs \verb+CHAR+ und \verb+DECIMAL+ möglich.

Wie schon in Listing \ref{lst:annotationdecimal} und Listing \ref{lst:pliarithmeticexpression} zu sehen, werden in der aktuellen Version auch Prozeduren übersetzt.
Im folgenden Kapitel werden Übersetzungsentscheidungen dieser näher diskutiert.

\pagebreak
\subsubsection{Programmstruktur und Programmablauf}
\paragraph{Umwandlung von Programmstrukturen }\label{programstruct}

In PL/I werden Unterprogramm-Routinen in Block-Strukturen definiert. Eine mögliche Block Struktur ist die Prozedur. \footcite[Vgl. ][S. 97ff. ]{pliref}
Eine Prozedur wird durch den Bezeichner, das PL/I-Symbol \verb+PROCEDURE+ und einer Terminierung wie \verb+END+ beschrieben.
Zusätzlich können Parameter, Rückgabetypen und allgemeine Attribut Optionen definiert werden. In Listing \ref{lst:procchar} ist eine beispielhafte Prozedur gelistet.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Prozeduren}, label={lst:procchar},
		basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DCL Revenue FIXED DECIMAL(5);

 A10_Revenue: PROC(rev_1) RETURNS(DECIMAL(5)) OPTIONS(INLINE);
 	RETURN rev_1;
 END proc_1;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "},
		basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 public @Decimal(5) double Revenue;		
 
 public @Decimal(5) double A10_Revenue(Object rev_1) { 
		return (double)rev_1;
	}
	\end{lstlisting}
\end{minipage}

Die Prozedur \verb+A10_Revenue+ hat einen Parameter und gibt einen Wert des Typs \verb+DECIMAL+ der L\"ange 5 zur\"uck.
Weiterhin wird die Option \verb+INLINE+ definiert.

Um in Java Unterprogramm-Routinen zu definieren gibt es Methoden. 
Entsprechend sind Methoden ein mögliches äquivalent der Prozeduren. \footcite[Vgl. ][]{oracle}
Eine Methode hat ähnliche Bestandteile wie eine Prozedur.
Es wird ein Modifier, Rückgabetyp, Bezeichner und eine Parameterliste benötigt.
Einige dieser Attribute sind auch in einer Prozedur definiert.
Jedoch gibt es Unterschiede, die zu einer nicht eindeutigen Übersetzung führen können.

Wird etwa versucht, die in der PL/I-Prozedur definierten Parameter direkt zu übersetzen, fehlt die explizite Typisierung im Parameter. Dieser wird in PL/I implizit durch die Variablendeklaration definiert,
ist aber kein Bestandteil der Prozedurensignatur. 

Implizit wird hier der Typ \verb+DECIMAL+ zugewiesen. 
In Java muss hingegen explizit der Typ des Parameters in einer Methodensignatur angegeben werden.
Eine M\"oglichkeit die Parameterliste zu übersetzen, ist über den Typ \verb+Object+. \footcite[Vgl. ][]{objectdocs}

In Zeile 4 des Listing \ref{lst:procchar} wird etwa in den Typ \verb+double+ gecastet. Weiterhin wird in der Prozedur aus Listing \ref{lst:procchar} ein R\"uckgabewert des Typs \verb+DECIMAL+ der L\"ange f\"unf definiert.

Auch hier eignet sich die Verwendung der in Kapitel 3.2.1 beschriebenen Annotationslösung. Dazu wird in Listing \ref{lst:procchar} über die Annotation die Längenbeschränkung definiert und der native Java Typ double verwendet.
Die Validierung des Rückgabewertes erfolgt dann mithilfe von Boiler-plate Code der bei über die Codebasis bereitgestellt wird.

Ein weiteres Attribut das in der Prozedur in Listing \ref{lst:procchar} definiert ist, ist das \verb+OPTIONS+
Attribut.
In PL/I werden hier Compiler-Optionen definiert. So wird, wie in Zeile 3 gezeigt, die Option \verb+INLINE+ verwendet, um den Kontext einer Prozedur zu beschreiben. Ist die Prozedur etwa \verb+INLINE+, ruft der Compiler nicht die Prozedur auf, sondern ersetzt den Aufruf mit dem Body der Prozedur. \footcite[Vgl.][]{optionsstmt} Diese sogenannte Inline-Expansion ist eine Optimierungsanweisung an den Compiler. Mit solchen Optionen kann der PL/I-Programmierer direkten Einfluss auf die Kompilierung des PL/I-Programms nehmen.

In Java wird hingegen der Java-Quellcode und häufig aufgerufene Methoden durch die Inline-Expansion der \ac{JIT} optimiert. Entsprechend existiert derselbe Optimierungsschritt auch in Java, kann jedoch nur bedingt beeinflusst werden. Die Deaktivierung dieser Optimierung würde zu einer Manipulation der Arbeitsweise des Java-Compilers führen. Es ist fraglich, ob eine solche Anpassung sinnvoll ist, da der Java-Compiler selbst entscheidet, welche Methoden durch die Inline-Expansion optimiert werden sollen. Ein Eingriff entspricht für \verb+javac+ im Allgemeinen keinem Optimierungsprozess.
Aus diesem Grund wird in der Version des Transpilers die Übersetzung dieses Ausdrucks nicht weiter berücksichtigt.


\pagebreak
\paragraph{Umwandlung des Programmablaufs}

In PL/I werden Prozeduren unter anderem mithilfe des \verb+CALL+ Statements aufgerufen. \footcite[Vgl. ][S.133ff. ]{pliref} Um einen Programmfluss zu erzeugen, wie er auch in einem nativen Java-Programm vorhanden ist, wird der Call-Ausdruck in einen Methoden-Aufruf transformiert. 
Das Beispiel in Listing \ref{lst:callstatement} beschriebt ein Programm, in dem sich die Prozeduren \verb+proc_1+ und \verb+proc_2+ gegenseitig aufrufen, was in der Main-Prozedur eine Endlosschleife simuliert.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Prozeduraufruf}, label={lst:callstatement},
		basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
	main_proc: PROC;
		CALL proc_1;
	END main_proc;
		
	proc_1: PROC;
		CALL proc_2;
	END proc_1;
		
	proc_2: PROC;
		CALL proc_1;
	END proc_2;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "},
		basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
	public void main_proc(){
		proc_1 ();
	}
		
	public void proc_1(){
		proc_2 ();
	}
		
	public void proc_2(){
		proc_1 ();
	}
	\end{lstlisting}
\end{minipage}


Die gleiche Endlosschleife aus PL/I wird somit auch in Java erzeugt.
Dadurch kann ein einfacher Programmablauf von einem PL/I-Programm in ein Java-Programm transformiert werden.
Um nun ein PL/I-Programm mit zusätzlicher Logik zu transformieren, sollten Verzweigungen und Schleifen ebenfalls übersetzt werden.

\pagebreak
\subsubsection{Kontrollflussanweisungen}
\paragraph{Umwandlung von Boolesche Ausdrücke}
Für die Übersetzung von Kontrollflussanweisungen werden Boolesche Ausdrücke verwendet, um den Programmfluss basierend auf Wahrheitswerten zu verändern. Um sowohl Verzweigungen als auch Schleifen zu implementieren müssen die Booleschen Ausdrücke von PL/I nach Java überführt werden. Da es in PL/I leicht unterschiedliche Boolesche Operatoren im Vergleich zu Java gibt werden diese während der Übersetzung angepasst. In Tabelle \ref{tab:booloperator} sind die Booleschen Operatoren in PL/I sowie ihre Repräsentation in Java abgebildet.

% TODO Mappung Tabelle von boolesche Operationen, Tabelle: Boolesche-Operator -> PL/I-Symbol -> Java-Symbol

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{|X|X|X|}
		\hline
		\textbf{Boolescher-Operator} & \textbf{Symbol in PL/I} & \textbf{Symbol in Java}  \\
		\hline
		Gleich & = & ==  \\
		Und & \& & \&\& \\
		Nicht & ¬ & ! \\
		Oder & $\mid$ &	$\mid$$\mid$ \\
		Größer-als & $>$ & $>$ \\
		Kleiner-als & $<$ & $<$ \\
		Größer-Gleich & $<=$ & $<=$ \\
		Kleiner-Gleich & $<=$ & $<=$ \\
		\hline
		
	\end{tabularx}
	\caption{Boolesche Operatoren \label{tab:booloperator}}
\end{table}


% TODO (var_1 < 10) & ¬(var_2 > 5) übersetzen als Listing

Während in Java ein einfaches Ausrufezeichen eine Negation beschreibt, wird in PL/I das logische Negationszeichen (¬) verwendet. Bei der Transformation wird dieses Zeichen in ein Ausrufezeichen übersetzt.

Weiterhin wird in PL/I ein einzelnes Gleichheitszeichen als logischer Vergleichsoperator verwendet. Da in Java das einzelne Gleichheitszeichen der Zuweisung von Variablen dient, wird der PL/I-Vergleichsoperator mit den Java-Vergleichsoperator ersetzt.

Gleiches gilt für das logische-Und, in PL/I wird lediglich ein Et-Zeichen verwendet. Während in Java zwei als logisches-Und verwendet werden.

In Listing \ref{lst:branchmapping} ist die Übersetzung eines Booleschen-Ausdrucks dargestellt.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
	caption={Boolescher-Ausdruck}, label={lst:branchmapping}]	
	(var_1 < 10) & $\lnot$(var_2 > 5)
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
title={" "}]
	(var_1 < 10) && !(var_2 > 5)
	\end{lstlisting}
\end{minipage}
\pagebreak

\paragraph{Umwandlung von Verzweigungen}

In PL/I werden Verzweigungen mit den Symbolen \verb+IF+ und \verb+ELSE+ implementiert. 
Gepaart mit einem Booleschen Ausdruck kann so ein Wahrheitswert abgefragt werden.
Somit lässt sich der Ausdruck in Listing \ref{lst:branchmapping} in Java übersetzen.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Verzweigungen}, label={lst:branchmapping}]	
 IF (var_1 < var_2) THEN;
 	var_1 = 0;
 ELSE
	var_1 = var_2;
 END;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
 if(var_1 < var_2){
 	var_1 = 0;	
 } else {
	var_1 = var_2;
 }
	\end{lstlisting}
\end{minipage} 

Würden hier erneut der nichtprimitive Typ wie das \verb+DECIMAL+ Objekt verwendet, hätten die instanziierten Objekte erst mit einer Art \verb+toNumeric+ Methode in ein numerisches Format umgewandelt werden müssen. Was erneut zu mehr Quellcode als nötig führen würde. Alternativ könnte \verb+DEICMAL+ um eine \verb+compareTo(DECIMAL)+ Methode erweitert werden. In Java kann so das Interface \verb+Comparable+ implementiert werden. 

\paragraph{Umwandlung von While-Schleifen}
In PL/I wird in der aktuellen Version des Transpilers, die  While- und Until-Schleife übersetzt.
Weitere Schleifen wie \verb+UPTHRU+ oder \verb+DOWNTHRU+ wurden in dieser Version nicht implementiert.
Da Java ebenfalls eine While-Schleife implementiert, kann diese als Übersetzungsmuster verwendet werden. 


Listing \ref{lst:whilecomamnd} zeigt eine einfache While-Schleife in PL/I.
Dabei wird in PL/I das Symbol \verb+DO+ nicht wie in Java für eine Do-While
Schleife verwendet, sondern leitet lediglich einen Schleifen-Ausdruck ein.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={While-Schleife}, label={lst:whilecomamnd}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DCL var_1 DECIMAL(2) INIT(0);
 DCL var_2 DECIMAL(2) INIT(5);
 
 DO WHILE(var_1 < var_2);
 	var_1 = var_1 + 1;
 END;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 public @Decimal(2) double var_1 = 0;
 public @Decimal(2) double var_2 = 5;

 while(var_1 < var_2){
 	var_1 = var_1 + 1;
 }
	\end{lstlisting}
\end{minipage} 
\pagebreak
\paragraph{Umwandlung von Until-Schleifen}

Die While-Schleife kann mit der Until-Schleife kombiniert werden. Eine Until-Schleife prüft eine Bedingung, deren Eintreten zum Abbruch der Schleife führt. Diese Form der Schleife existiert in Java nicht. Stattdessen wurde die \verb+do while+-Schleife als Übersetzung gewählt. In Listing \ref{lst:untilwhile} ist die Übersetzung dargestellt.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
	caption={While-Until-Schleife}, label={lst:untilwhile}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DCL var_1 DECIMAL(2) INIT(0);
 DCL var_2 DECIMAL(2) INIT(5);
 
 DO WHILE(var_1 < var_2) 
 	UNTIL(var_1 = 10);
		var_1 = var_1 + 1;
 END;
 
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
	title={" "}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 public @Decimal(2) double var_1 = 0;
 public @Decimal(2) double var_2 = 5;
	
 while (var_1 < var_2) {
 	do {
 		var_1 = var_1 + 1;
 	} while(!(var_1 == 10));
 }
	\end{lstlisting}
\end{minipage} 

Um die Abbruchbedingung im Until-Teil der Schleife zu implementieren, wird die Boolesche Operation übersetzt und negiert. Dadurch kann die gleiche Laufzeit wie im PL/I-Programm erzeugt werden. Da der Do-Block mindesten einmal ausgeführt wird, jedoch nur einmal wenn die Bedingung im Fuß der Do-While-Schleife erfüllt ist.

\pagebreak
\subsubsection{Ein- und Ausgabe Befehle}
\paragraph{Konsolen Ein- und Ausgabe}
Um eine Benutzerinteraktion zu ermöglichen wird der Display-Ausdruck transformiert.
In PL/I gibt es sowohl die Möglichkeit mit dem Display-Ausdruck eine Text-Nachricht in der Konsole auszugeben, sowie eine Benutzereingabe abzufragen. \footcite[Vgl. ][S. 264ff.]{pliref}

% TODO Kürzer
In Java gibt es verschiedene Implementierungen einer Umleitung der Ausgabe in die Konsole.
Die gängige Methode ist die Verwendung des Ausdrucks \path{System.out.println()}. 
Alternativ könnte auch die Methode \verb+log.trace+ verwendet werden.
Jedoch wird hier eine Abhängigkeit zu der Software-Bibliothek \verb+logger+  erzeugt, weshalb sich gegen diese Methode entschieden wurde.
Eine weitere Alternative würde der \verb+PrintWriter+ bieten, hierbei müsste jedoch zuerst das Objekt \verb+PrintWriter+ erzeugt werden, was zusätzlichen Quellcode erzeugen würde. Diese könnte mit der Implementierung des Sysout-Befehls vermieden werden.
Somit wurde mit dem Sysout-Befehl die gängige Methode gewählt. Entsprechend wird der Ausdruck in Listing \ref{lst:display} übersetzt.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Standardausgabe}, label={lst:display}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DISPLAY ('Hello World');
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 System.out.println("Hello World");
	\end{lstlisting}
\end{minipage} 


Um den Display-Ausdruck ebenfalls für das Einlesen von Benutzereingaben zu verwenden, wird an den bekannten Display-Ausdruck ein \verb+REPLY+ angefügt. Siehe Listing \ref{lst:displayreply}.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Standardeingabe}, label={lst:displayreply}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DCL username CHAR(5);
 DISPLAY('Username') REPLY(username)
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,% 
	title={" "}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 public @Char(5) String username;
 username = System.console().readLine(); 
	\end{lstlisting}
\end{minipage} 

In dem Beispiel in Listing \ref{lst:displayreply} wird die Benutzereingabe in der
Variable \verb+username+ gespeichert.
In PL/I kann die Benutzereingabe nur in einem Bit, Widechar oder Char gespeichert werden. 
In Java gibt es die Möglichkeit über den Scanner oder BufferedReader eine Benutzereingabe Abzufragen.

Hier wird das Objekt System verwendet, welches auch bei der \verb+System.out.println+ verwendet wurde.
Mit \verb+System.console.readLine()+ wird die Benutzereingabe gelesen.

\pagebreak
\paragraph{Datei Eingabe}
In PL/I gibt es die Möglichkeit, über des \verb+READ+-Statement Dateien vom Dateisystem einzulesen.
In Kapitel 1.1 wurde bereits erwähnt das PL/I-Programme hauptsächlich auf einem Mainframe ausgeführt werden.
Auf einem z/Os Betriebssystem wird das Dateisystem \ac{zfs} verwendet.
Hier werden anders als bei den  Linux oder Windows \ac{hfs}, Ordner als Datasets und Dateien als Records gespeichert.
Ein Record kann dann von einem Programm, wie einem PL/I-Programm gelesen werden.

Ein PL/I Programm kann einen Record verarbeiten, sowie Ausgeben. In Java geschieht dies gewöhnlich über die Angabe eines Dateipfads.
In PL/I werden spezifische Dateien über die Batch-Verarbeitung definiert, weshalb im Quellcode selbst keine Referenz zu dem eigentlichen Record gegeben ist.

Um den durch die Batchverarbeitung definierten Record in einem PL/I-Programm zu verwenden, kann der Datentyp \verb+FILE+ in Listing \ref{lst:plifiletyp} definiert werden. Zusätzliche können Attribute angegeben werden, wie \verb+BUFFERED+ oder \verb+UNBUFFERED+ um dem Compiler exakt mitzuteilen wie dieser die Datei verarbeiten soll.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Dateityp}, label={lst:plifiletyp}]
 DCL file_1 FILE;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
 public File file_1 = new File("");
	\end{lstlisting}
\end{minipage}  

Bei dem Typ FILE handelt es sich um einen Buffer in dem der Inhalt einer Datei gelesen und für weitere Programmroutinen verfügbar wird. \footcite[Vgl. ][ S.305ff. ]{pliref}

In Java existiert ein ähnlicher nicht-primitiver File-Typ.
Java liest mit der Klasse File eine Datei direkt vom Betriebssystem ein und speichert den Inhalt in einem Buffer. 
Hingegen besteht in Java kaum die Möglichkeit, dabei direkt zu beeinflussen, wie die Datei eingelesen werden soll.


Bezüglich Listing \ref{lst:plifiletyp} ist anzumerken das bisher lediglich ein File-Objekt instanziiert wurde.
Es wurde kein Pfad übergeben und somit auch keine Datei eingelesen. 
Die Ausführung dieses Java-Codes wird zu einer Input-Output-Exception führen, da kein Pfad zu einer Datei übergeben wurde. Hier ist die eigentliche Übersetzung des PL/I-Programms abhängig von der Betriebssystemumgebung, in der das Java-Programm ausgeführt werden soll. Für den Transpiler ist ohne die Referenz auf die Batch-Verarbeitung eine Einbindung des Dateipfades nicht möglich.

Entsprechend wird in dieser Version des Transpilers dem Benutzer die Verantwortung übergeben, die Referenz zu den ursprünglichen Eingabedateien herzustellen.

In PL/I wird mit einem \verb+READ+-Ausdruck die definierte Datei gelesen und in einer Alphanumerischen-Variable gespeichert. Ein mögliches \verb+READ+-Statement aus einem PL/I-Programm ist in Listing \ref{lst:pliread} dargestellt.

Hierbei wird die in Listing \ref{lst:pliread} definierte Datei gelesen.
Transformiert wird diese Dateieingabe mit dem Scanner Objekt.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Dateieingabe}, label={lst:pliread}, basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 DCL var_1 CHAR(4);
 READ FILE(file_1) INTO (var_1); 
		
		
		
		
		
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "},  basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
 String @Char(4) var_1;
 Scanner readFile = new Scanner(file_1);
		
 while(readFile.hasNext()){
	var_1 = readFile.next();
 }
 readFile.close();
	\end{lstlisting}
\end{minipage}  


Mit dem Scanner Objekt kann die definierte Datei nun Wort für Wort in einen String gelesen werden.

\paragraph{Datei Ausgabe}

Neben dem Einlesen kann ein PL/I-Programm auch mit dem \verb+WRITE+ Befehl in eine Datei schreiben.
Auch hierbei ist zu erwähnen, dass die eigentliche Steuerung der Ausgabe durch das Batch-Programm vorgenommen wird.
Es wird der Buffer der vorher definierten Variable des Typs \verb+FILE+ benutzt, um in die Datei bzw. den Record
des Datasets zu schreiben. Dabei wird wie in diesem Fall der Inhalt des Strings \verb+var_1+ gelesen und entsprechend
in den Buffer geschrieben.
Die Übersetzung des PL/I-Quellcode führt zu der Ausgabe in Listing \ref{lst:javawriter}.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Dateiausgabe}, label={lst:javawriter},  basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
	WRITE FILE (file_1) FROM (var_1);	
	
	
	
	
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "},  basicstyle=\fontsize{9}{13}\selectfont\ttfamily]
	BufferedWriter writer = new BufferedWriter(
		new FileWriter(file_1)
	); 
	writer.write(var_1);
	\end{lstlisting}
\end{minipage}  

Hierbei wird ein \verb+BufferedWriter+-Objekt erzeugt, dem ein \verb+FileWriter+ übergeben wird. Dies ist eine mögliche Methode, um in Java eine Datei mit Inhalt zu füllen. Ähnlich wie bei der Standardeingabe können auch weitere Objekte aus ausgewählten Java-Bibliotheken verwendet werden, wie etwa der \verb+FileWriter+, \verb+PrintWriter+ oder beide in Kombination mit dem \verb+DataOutputStream+-Objekt. Bei den letztgenannten Lösungen werden mehr als zwei Objekte für das Schreiben in die Datei benötigt.
Zusammenfassend werden so die grundlegenden Anweisungen der Programmiersprache PL/I nach Java übersetzt. 

\pagebreak
\subsection{Test und Integration}
\subsubsection{Unit-Tests}

Um die in Kapitel 3.2 beschriebenen Übersetzungen zu testen, wurden Unit-Tests geschrieben. 
Diese Unit-Tests testen auf der Basis bisher vorgestellter Übersetzungen den Transpiler.

Die Vorgehensweise bei der Entwicklung des Transpilers orientiert sich am Test-Diven-Development. 
Der erste Schritt bestand in der Konzeption von Elementarübersetzungen wie in der technischen Spezifikation vorgestellt.
Für jede dieser Elementarübersetzungen wurde ein Unit-Test geschrieben. Diese werden mit dem Maven-Kommando \verb+mvn test+ als Teil des Buildprozesses durchgeführt. Daraufhin folgt die Implementation der Programmroutinen, um den PL/I-Quellcode nach Java zu übersetzen.
Beispielhaft ist in Listing \ref{lst:javaunittest} eine Test-Methode für das Transformieren von Variablen dargestellt.

\begin{lstlisting}[language=Java, caption=Arithmetic Node Unit-test, label={lst:javaunittest}]
@Test
void mapChildNodes_checkIdentifierMapping() {
	
	DeclarationMapper declarationMapper = new DeclarationMapper();
	String decimalExpression = 
		 "test_1_package: PACKAGE;" 
	   + "	DCL var_3 FIXED DECIMAL(5);" 
	   + "END test_1_package;";
	
	InputStream stream = new ByteArrayInputStream
	(decimalExpression
	.getBytes(StandardCharsets.UTF_8));
	
	Pl1Parser pl1parser = new Pl1Parser(stream);
	SimpleNode varNode = pl1parser.program().jjtGetChild(0)
	.jjtGetChild(1);
		
	declarationMapper.mapChildNodes(varNode);
	declarationMapper.mapArithmetic
	((SimpleNode)varNode
	.jjtGetChild(1).jjtGetChild(0));
		
	assertEquals("var_3", declarationMapper.getIdentifier());
	assertEquals("@Decimal(5) double", declarationMapper.getType());
}
\end{lstlisting} 

% Test-Coverage
In Listing \ref{lst:javaunittest}  wird der Typ \verb+DECIMAL+ getestet. Untersucht werden der resultierende Typ und Bezeichner, die durch die Methoden \verb+mapChildNodes+ und \verb+mapArithmetic+ gesetzt werden.Es wird erwartet, dass der Bezeichner der PL/I-Variable dem Inhalt der Variable identifier der Klasse \verb+DeclarationMapper+ entspricht.
Weiterhin wird erwartet, dass der Typ \verb+DECIMAL+ zu dem entsprechenden Typ aus Listing \ref{lst:annotationdecimal} übersetzt wird.
Mit jedem Test wird auch ein Parser-Objekt erzeugt, dadurch wird  mit einem Unit-Tests die geschriebene Grammatik überprüft.
Ähnlich wurden  für die weiteren Mapper-Klassen Test-Klassen erzeugt.
Für die restlichen Module, wie etwa der Symboltabelle, wurden ebenfalls Tests geschrieben.
Da die Symboltabelle bereits in der Version der Projektarbeit-IV integriert war, wurden hier  Tests nachträglich geschrieben. 

%Negative Tests
Bei der Implementierung der Tests wurden sowohl Negativ- als auch Positivtests geschrieben.
In Listing \ref{lst:javaunittest} handelt es sich um einen Positiven Test. 

Da die Methode \verb+mapArithmetic+ speziell für die Übersetzung von numerischen Typen geeignet ist, sollte die Methode eine Fehlermeldung ausgeben, wenn eine Übersetzung von einem alphanumerischen Datentyp verlangt wird.  In Listing \ref{lst:javanegativetest} wird dieser Umstand getestet. 

\begin{lstlisting}[language=Java, caption=Arithmetic Node Unit-test, label={lst:javanegativetest}]
@Test
void mapArithmetic_NegativeTest() {
	DeclarationMapper declarationMapper = new DeclarationMapper();
	
	String decimalExpression = 
	"test_1_package: PACKAGE;" 
	+ "	DCL var_3 CHAR(5)" 
	+ "END test_1_package;";
	
	InputStream stream
	= new ByteArrayInputStream(decimalExpression
	.getBytes(StandardCharsets.UTF_8));
		
	Pl1Parser pl1parser = new Pl1Parser(stream);
	SimpleNode program = pl1parser.program();
	SimpleNode varNode = 
	(SimpleNode) program
	.jjtGetChild(0)
	.jjtGetChild(1);
		
	assertThrows(TypeMappingException.class, () -> 
	{
		declarationMapper.mapArithmetic(
		(SimpleNode)varNode.jjtGetChild(1).jjtGetChild(0)
		);
	});
}
\end{lstlisting}

Auch für die restlichen Test-Klassen wurden solche Negativtests implementiert. 
Weiterhin wurden sowohl Negativ- als auch Positivtests für alle weiteren Mapper-Klassen geschrieben. Diese finden sich im Anhang 1-7 zu finden.
Zusammenfassend wurden so die kleinsten Programm-Einheiten des Transpilers überprüft. 
\pagebreak

\subsubsection{Integrationstests}
In diesem Kapitel wird die Durchführung eines Integrations-Tests aller Komponenten beschrieben. Der Integrations-Test ist so angelegt, dass im ersten Schritt der Transpiler kompiliert wird und danach ein Beispielprogramm damit übersetzt wird. Der übersetze Java-Code wird wiederum kompiliert und ein Test des Programms wird im Kapitel 3.4 durchgeführt.

In diesem Kapitel wird die vollumfängliche Implementation des Transpilers, mit dem Frontend und der zum Kompilieren benötigte Codebase protokolliert. Dazu wird ein Beispiel PL/I-Programm übersetzt. Für die Berechnung einer Primzahl wurde hier der Probedivisions Algorithmus implementiert. 
In Anhang \ref{lst:pliprobedivision} ist die Implementation des Algorithmus in PL/I zu sehen. Dieses Programm soll während des Integrations-Tests in Java-Zielcode übersetzt und durch den Java-Compiler kompiliert werden.
Eine Ausführung des Algorithmus ist nicht vorgesehen, lediglich die Transformation und das Kompilieren durch den PL/I-Transpiler sowie des Java-Compilers. Das System verwendet die Version 17.0.11 des Java-Compilers. Sowie Version 5.0 des Parser-Generators-JavaCC und Apache Maven der Version 3.6.3.

% Transpiler aus Github Repo holen
Der Integrationstest beginnt damit, das Transpiler-Projekt aus dem Remote-Repository zu laden.

\begin{lstlisting}[language=Bash, caption=Laden des Transpilers, label={lst:inttest1}]
git clone -b integration https://github.com/lhahner/pl1-code-transpiler.git
\end{lstlisting} 

Es wird in das Projektverzeichnis des Transpilers navigiert, woraufhin die JAR-Datei mit dem Maven-Kommando in \ref{lst:inttest2} Listing erzeugt wird.

% Transpiler kompilieren
\begin{lstlisting}[language=Bash, caption=Erzeugen der JAR, label={lst:inttest2}]
mvn install
\end{lstlisting}

% Frontend aus Github repo holen
Jetzt kann das Projekt in das Frontend eingebunden werden. Dazu wird erneut das Frontend-Projekt aus dem Remote-Repository geladen. In Listing \ref{lst:inttest3} ist der Befehl dazu gelistet.

\begin{lstlisting}[language=Bash, caption=Laden des Frontend-Projekts, label={lst:inttest3}]
git clone https://github.com/lhahner/plitra-web.git
\end{lstlisting}

% Server stareten
Nun wird in die Projektstruktur des Frontendprojektes navigiert. Der Spring-Boot-Server wird lokal mit dem Befehl in Listing \ref{lst:inttest4} gestartet.

\begin{lstlisting}[language=Bash, caption=Starten des Spring-Boot-Servers, label={lst:inttest4}]
mvn spring-boot:run
\end{lstlisting}

Die Adresse \path{http://localhost:8080/} wird in Firefox geöffnet. Es wird über den "Transpile"-Button auf die Seite \path{http://localhost:8080/trans} navigiert. Hier wird in das linke Testfeld der PL/I-Quellcode aus Anhang \ref{lst:pliprobedivision} eingefügt. In Anhang \ref{lst:javaprobedivision} ist das Ergebnis, welches auf der linken Seite ausgegeben wurde, dargestellt.

% Code base Repository aus Github holen
Um nun das ausgegebene Projekt zu kompilieren, sollte eine bereitgestellte Code-Basis verwendet werden. Es wird das Code-Basis-Projekt aus der Remote-Repository in Listing \ref{lst:inttest5} geladen.

\begin{lstlisting}[language=Bash, caption=Laden der Code-Basis, label={lst:inttest5}]
git clone https://github.com/lhahner/plitra-codebase.git
\end{lstlisting}

% Code integration des Übersetzen Codes in Repositry
Der Code innerhalb der Klasse aus Anhang \ref{lst:javaprobedivision} wurde kopiert und in die Klasse TranspiledExamplePliProgram eingefügt. Dazu wurde in den Ordner \path{/src/main/java/org/plitra/codebase} innerhalb des Codebasis-Projektes navigiert und mit Eclipse der Java-Zielcode eingefügt.

% kompilieren des Übersetzen Codes
Das Casten des Parameters wird aktuell nicht unterstützt, weshalb der Objekttyp händisch
in \verb+double+ geändert wurde. Weiterhin wurden alle Fehler, die von der \ac{ide} erkannt wurden, automatisch durch das Akzeptieren, des Änderungsvorschlags der  \ac{ide}  verbessert.
Das Projekt wird nun erneut mithilfe des in Listing \ref{lst:inttest6} dargestellten Maven-Kommandos kompiliert.

\begin{lstlisting}[language=Bash, caption=Kompilieren des Projekts, label={lst:inttest6}]
mvn install -Dmaven.test.skip=true
\end{lstlisting}

Das Projekt wurde erfolgreich kompiliert, womit der Integrations-Test erfolgreich war. Um nun weitergehend auch die Laufzeit des Java-Zielcodes zu überprüfen, wird in dem nächsten Kapitel die Performance des PL/I-Quellcodes und des Java-Zielcodes überprüft und verglichen. 
\pagebreak

% TODO Code in Textdatei speichern -> um Main-Methode anreichern -> mit Javac kompilieren -> Performance und Benchmark ausführen können

\subsection{Performance und Benchmarks}
Um vergleichen zu können, wie sich die Laufzeit der Implementierung des Probedivisions Algorithmus in PL/I und Java unterscheidet, wird in diesem Kapitel die Performance verglichen. 
Dazu wird den Beiden Programmen vier Primzahlen übergeben. Für die Berechnung wurde das Programm aus dem Anhang \ref{lst:pliprobedivision}, auf einem z/OS-Mainframe-System kompiliert und ausgeführt. 
Die allgemeinen System-Spezifikationen des Mainframes sind in Abbildung \ref{fig:mainframesysteminfo} dargestellt.

\dhgefigure[h]{mainframe-system-info.png}[scale=0.47]{Mainframe System Informationen}{fig:mainframesysteminfo}[][]

Unter CPU ist der Maschinen-Typ 3931 gelistet. Bei dem Mainframe, handelt es sich um einen IBM z16 A02, mit
einer maximalen Prozessorkern Kapazität von 16. Sowie Maximal 4 TB Arbeitsspeicher. \footcite{z16}
Damit wird das Programm auf der neusten Hardware von IBM kompiliert und ausgeführt.

% PL/I-Benchmark Test mit System Spezifikationen
Um ein PL/I-Programm auf einem z/Os Betriebssystem eines IBM-Mainframes zu starten, muss das Programm zuerst erfolgreich kompiliert und mit einem Batchjob-Programm
ausgeführt werden. Das Batchjob-Programm wurde in der Job-Control-Language (JCL) geschrieben.
Es wurde die Laufzeit für vier Primzahlen gemessen. Die erste Primzahl ist die 1772 von Leonhard Euler entdeckte Primzahl mit 10 Stellen; 2,147,483,647. Die nächstgrößere getestete Primzahl ist die 999.999.000.001. Darauf folgt die größte bekannte Primzahl, die nicht durch einen Computer bewiesen werden konnte: 67.280.421.310.721. Zuletzt wurde eine Primzahl verwendet, die bisher nur durch einen Computer bewiesen werden kann. \footcite[Vgl. ][]{prime}
In Tabelle \ref{tab:plibenchmark} sind alle Primzahlen mit ihrer Laufzeit zu sehen. 

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{|X|X|X|}
		\hline
		\textbf{Primzahl} & \textbf{Laufzeit}  \\
		\hline
		2,147,483,647 & 00:00:00,0 \\
		
		999,999,000,001 & 00:00:00,1  \\
		
		67,280,421,310,721 & 00:00:00,8 \\
		
		10,000,000,002,065,383 & 00:00:01,0 \\
		\hline
	\end{tabularx}
	\caption{PL/I-Programm Benchmarks, (Siehe Anhang 11-14) \label{tab:plibenchmark}}
\end{table}
\pagebreak

% Java-Benchmark Test mit System Spezifikationen
Das während des Integration-Test übersetzte Programm aus Anhang \ref{lst:javaprobedivision} wird ebenfalls für die Berechnung der Primzahlen 
getestet. Die Hardware-Spezifikationen des Systems, auf dem der Integrations-Test durchgeführt wird. Sind in Tabelle \ref{tab:hardwartable} beschrieben.

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{|X|X|X|}
		\hline
		\textbf{Spezfikation} & \textbf{Beschreibung}  \\
		\hline
		Betriebssystem & Ubuntu 20.04.6 LTS x86 64 \\

		Kernel & 5.15.0-113-generic  \\

		CPU & Intel i3-9100F (4) @ 3.600GHz \\

		GPU & NVIDIA GeForce GTX 970  \\

		Arbeitsspeicher & 8217MiB / 15932MiB \\
		\hline
		
	\end{tabularx}
	\caption{Hardwarespezifikation des Test-Systems \label{tab:hardwartable}}
\end{table}


Weiterhin sind die Testergebnisse des Java-Codes in \ref{tab:javabenchmark} gelistet.

\begin{table}[h]
	\centering
	\begin{tabularx}{\textwidth}{|X|X|X|}
		\hline
		\textbf{Primzahl} & \textbf{Laufzeit}  \\
		\hline
		2,147,483,647 & 00:00:00,2 \\
		
		999,999,000,001 & 00:00:01,2 \\
		
		67,280,421,310,721 & 00:00:05,9 \\
		
		10,000,000,002,065,383 & 00:01:27,9 \\
		\hline
	\end{tabularx}
	\caption{Java-Programm Benchmarks \label{tab:javabenchmark}}
\end{table}

% Umrechnung & Vergleich: TODO nicht nötig
Bei der Beurteilung sollten die Hardwareunterschiede berücksichtigt werden.
Während des Benchmarks wurde versucht, Primzahl 170,141,183,460,469,231,731,687,303,715,884,105,727
zu berechnen. Dabei musste der Java-Zielcode angepasst werden. Die maximale Anzahl an Ziffern, die in dem größtmöglichen
primitiven Datentyp gespeichert werden konnte, beträgt 64. Daher wurde stattdessen der nicht-primitive Datentyp \verb+BigDecimal+ verwendet. 
Ebenso mussten die Berechnungen im Algorithmus angepasst werden. Im Anhang \ref{lst:javaprobedivisionang} befindet sich das angepasste Programm.
Die Zahl wurde nicht weiter im Benchmark berücksichtigt, da das System aus Tabelle \ref{tab:hardwartable} für diese Operation zu lange bräuchte.
Dennoch zeigt sich hier eine Grenze auf. Um solche großen Zahlen zu berechnen, muss das Programm bzw. die Übersetzung angepasst werden,
da in Java die Behandlung solcher großen Zahlen nur mit nicht-primitiven Datentypen möglich ist.
Ein PL/I-Programm kann weiterhin die standardmäßig implementierten Datentypen wie \verb+DECIMAL+ oder \verb+BINARY+ verwenden, lediglich die Skalierung der Länge muss angepasst werden.
Im Zuge dieser Arbeit wurde diese Zahl nicht auf dem Mainframe getestet, da unbekannt wie hoch die \ac{MIPS} bei dieser Zahl sind.
Bedingt durch diese Ungewissheit, kann auch nicht genau gesagt werden wie viel eine solche Rechenoperation kosten würde. 
Zusammenfassend wird so eine schwäche des Transpilers deutlich. In dem folgenden Kapitel sollen weitere schwächen betrachtet und diese Arbeit evaluiert werden.

\section{Fazit}
% Erreichte Entwicklung
Auch nach dieser Arbeit wurde der Transpiler zwar erweitert, aber noch nicht fertiggestellt.
Das entwickelte Programm bietet lediglich die grundlegenden Voraussetzungen für die Übersetzung von PL/I-Strukturen.
Viele Konzepte aus der Projektarbeit IV mussten verbessert und angepasst werden, was dazu führte, dass nahezu 90\% des Transpilers
während dieser Arbeit geändert wurden. Dies hatte jedoch positive Auswirkungen, da die Entwicklung nun wesentlich leichter fortgeführt werden kann
und ein einfacher Überblick und Einstieg in die Erweiterung gegeben ist.
Zudem wurden während dieser Arbeit Ziele erreicht, die in der Projektarbeit IV verfehlt wurden. Dazu zählt etwa
die automatische Verarbeitung der Zwischencode-Erzeugung und die damit verbundene strukturierte Übersetzung jedes Knotens.
Weiterhin konnte die JavaCC-Grammatik stark vereinfacht werden, indem lediglich der JavaCC-Parser verwendet und der eigens geschriebene
Lexer entfernt wurde.
Es wurde auch automatisiertes Testing eingebunden, um die korrekte Übersetzung sicherzustellen, was die Qualität der Software verbessert hat.
Darüber hinaus ist es nun auch Benutzern möglich, den Transpiler in einer grafischen Oberfläche zu verwenden,
wobei diese in der aktuellen Version noch nicht vollständig ausgereift ist.
Der größte Vorteil gegenüber der Version der Projektarbeit IV ist, dass nun die Übersetzung von ganzen Programmen möglich ist, wie der Integrationstest zeigt.
Es bleiben jedoch auch noch einige Schwächen.

% Ausblick, Schwächen
Während der Entwicklung des Transpilers wurde immer wieder an Übersetzungslösungen gefeilt. Diese Lösungen wurden erweitert und mit der Implementierung von Java-Reflection und Annotationen wurde eine gut lesbare und fast schon native Java-Übersetzung der Datentypen gefunden. Leider ist noch nicht für jeden Datentyp eine solche Annotation implementiert.
Weiterhin blieben teilweise implementierte PL/I-Ausdrücke vollständig unberücksichtigt. So wird der Benutzer sehr schnell einen Ausdruck finden, der für einen vollumfänglichen Transpiler zu erwarten ist, jedoch in diesem nicht implementiert wurde.
Auch wird der Benutzer feststellen, dass der PL/I-Quellcode nicht vollumfänglich auf Fehler überprüft wird. Eine Mitübersetzung von Fehlern ist somit denkbar.

In den zukünftigen Versionen sollen diese Probleme gelöst werden und ein Transpiler entstehen, der dem Entwickler einen Großteil der Arbeit abnimmt.
Es ist auch geplant, den Transpiler öffentlich zugänglich zu machen, sodass jeder auf den Quellcode zugreifen und die Software verwenden kann.

