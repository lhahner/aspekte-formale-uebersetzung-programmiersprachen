%--> Je Subsection Punkt Fragen formulieren.

%-------------------------------------------
% HEADER

% Roterfade der Einleitung:

% 1. Problem -> Kompatibilität
% 2. Ziel -> Lösung mit Übersetzungsprogramm
% 3. Abgrenzung Interpreter & Compiler -> Übersetzungsprogramm als Transpiler
% 4. Formale Grammatike -> Formale Grammatik als Vorrausetzung des Transpilers
% 5. JavaCC -> Implementierung der Formalen Grammtik mit JavaCC und damit des Transpilers

%-------------------------------------------

\section{Theoretische Grundlagen}
\subsection{Problemstellung}
	
Es gibt zwei Probleme die eine PL/I zu Java Übersetzung lösen soll. 
Einerseits ein Portabilitätsproblem von PL/I-Programmen, die auf modernen Plattformen laufen sollen, wie etwa Cloud-Instanzen, oder Linux-Server. Andererseits die mit einem hohen Aufwand verbundene Wartung von bestehenden PL/I-Programmen. 
	
Die bestehende Auswahl von PL/I Compilern führen zu einem Portabilitätsproblem. Der PL/I Compiler, der auf den meisten Computer-Systemen im Einsatz ist, wird von IBM entwickelt und vermarktet. Hierbei handelt es sich um einen Compiler der für, dass von IBM entwickelte Betriebssystem z/Os geschrieben wurde. Eine Kompilierung von PL/I auf einem herkömmlichen x86-Desktop Computer oder ähnlichen ist mit diesem Compiler nicht möglich. \footcite[Vgl. ][]{plicomp}


Eine mögliche Alternative bietet die Organisation GNU mit der GNU Compier Collection \ac{GCC}. Der Softwareentwickler Henrick Sorensen entwickelte Teile des Frontends für einen PL/I Compiler. Dabei verwendete er das Backend, dass die \ac{GCC} zu Verfügung stellt. Jedoch gab es bei diesem Projekt seit 2007 keine weiteren Neuerungen mehr. Der Entwickler gibt an, das bisher keine Zwischencode Erzeugung stattfindet, was diesen Compiler bisher unbrauchbar macht. \footcite[Vgl. ][]{pligcc} 
Heutzutage ist die gängige Möglichkeit, ein IBM 3270 Terminal zu emulieren, das eine Verbindung zu einem z/Os System herstellt, und den PL/I Code auf diesem zu kompilieren.
Neben technischen Problemen, existieren auch ein Personalprobleme. PL/I ist eine Altsprache, die seit den 1960er Jahren im Einsatz ist und durch den Generationenwechsel an Entwicklern verliert. Wartung und Entwicklung werden so häufig schwer und teuer.\footcite[Vgl. ][S. 227ff.]{histopli} 

Java hingegen ist auf nahezu allen modernen Systemen durch die plattformunabhängige Java Virtual Machine (JVM) kompilierbar. \footcite[Vgl. ][]{jvm}
Insbesondere ist eine Kompilierung auch auf einem IBM-Großrechner mit z/Os möglich. \footcite[Vgl. ][]{zos} 
Das macht Java zu einer flexibel einsetzbaren Sprache. Weiterhin is Java die mit am meisten verwendete Programmiersprache in der heutigen Zeit. \footcite[Vgl. ][]{tiobe} Das führt zu einer höheren Anzahl an Entwickler, die in der Lage sind Java Programme zu warten.

% Was ist ein Transpiler?
Um die Programmiersprache Java zur Lösung der eingangs beschriebenen Probleme zu verwenden, wird ein Transpiler benötigt, der PL/I-Quellcode in Java-Zielcode übersetzt. Ein solcher Transpiler verarbeitet den Quellcode der Sprache PL/I und generiert daraus entsprechenden Quellcode in der Sprache Java. Dabei hat der Benutzer die Möglichkeit, selbst zu bestimmen, wie bestimmte Ausdrücke übersetzt werden sollen. Sobald der Programmcode in Java übersetzt ist, kann der Java-Zielcode von der Java Virtual Machine (JVM) kompiliert werden.

% Weiterführung
Erst ab diesem Punkt ist die Qualität des Transpilers zu erkennen. Faktoren wie Lesbarkeit und Erweiterbarkeit des Java-Zielcodes gehen in die Beurteilung mit ein. 
Die Beurteilung der Qualität des Transpilers ist auch von Zielaspekten der Benutzer abhängig. In dieser Arbeit wurden Zielgruppen definiert die im nachfolgenden Kapitel 1.2 weiter erläutert werden sollen. Diese Zielgruppen sind für weitere Gestaltungsentscheidungen in der Entwicklung des Transpilers wichtig.

% @review: Begriffswahl
In den folgenden Kapiteln wird zwischen dem Transpiler, dem Eingabeprogramm (PL/I-Quellcode) und dem Ausgabeprogramm (Java-Zielcode) unterschieden. Diese Begriffe helfen dabei, die verschiedenen Programme eindeutig zu identifizieren.

%Anderseits auch die veränderte Laufzeit-Performance. Die Laufzeit-Performance kann durch eine Übersetzung verschlechtert, wie auch verbessert werden. Somit ist nicht nur die reine Übersetzung Teil der Problemstellung, sondern es gilt auch die Übersetzung zu beurteilen. 

     

% 	 Welches Problem löst das Programm?
%	 Probleme 
%			 1. Nicht auf jedem System läuft PL/I, besonders nicht auf modernen x86 bzw. Cloud.
%			 2. PL/I ist eine weniger verwendete Sprache, Wartung teuer &  Schwer.

%	 (Hinführung zum Problem:
%	 Historisches Kompatibilitätsproblem -> Nicht auf jedem System lief jede Assambler Sprache, Problem: hoher Aufwand und Unflexibel
% 	 Deshalb -> Compiler mit Hochsprache, der Code für das Backend des Compilers, bspw. C's Gcc Compiler
%    in Assambler Sprache des Systems übersetzt.)? **Hier einen Cross Compiler erklären bzw. im Zusammenhang mit dem Historischen Problem.**

%	 Problem mit PL/I -> Pl/I Compiler rar bzw. nur für Großrechner Systeme vorhanden   
%	 Es gibt zwar einen GCC Pl/I Compiler, dieser wird aber seit 2007 nicht mehr weiterentwickelt. Eine Weiterentwiclung könnte auch Interessant %    sein, löst aber nicht das Problem der teuren Wartung von Programmen in PL/I.

% 	 
%	 Lösungsvorschlag zu 1 -> PL/I zu Java Transpiler bauen Java und JVM relativ System unabhängig und damit Ideale Zielsprache für eine 
%	 hohe Kompatibiltätsrate.Um zum Beispiel Pl/I Programm die auf einem Großrechner laufen auch auf einem x86 On-Prem Server oder einer Cloud
%    zu betreiben. **Hier die Frage klären was ein Transpiler ist**
%	 
%    Lösungsvorschlag zu 2 -> Java ist den großteil der Softwareentwickler bekannt und eine Wartung ist leichter.
%
    
\subsection{Zielsetzung}
% Herleitung von der Problemstellung	
Das Ziel dieser Arbeit leitet sich aus der eingeführten Problemstellung in Kapitel 1.1 ab. Allgemein soll ein plattformunabhängiger Transpiler entstehen, der die  Entwicklung und Transformation von PL/I-Quellcode ermöglicht. Die zugrundeliegende Arbeit stellt die Entwicklung, sowie die Gestaltung der Software dar und diskutiert Gestaltungsentscheidungen. 

% @review: Referenz zur Begriffklärung
% Zielgruppen Zusammengefasst	
Somit richtet sich diese Arbeit und der Transpiler an juniore Anwendungsentwickler in den Sprachen PL/I bzw. Java. Für diese Nutzergruppe soll der Transpiler ein Hilfswerkzeug darstellen. Weiterführend werden diese als Benutzer bezeichnet. Eine andere Nutzergruppe sind Administratoren, die den Transpiler selbst anpassen und erweitern möchten. Ermöglicht wird dies durch eine modulare Architektur.
	
% Junior Entwickler die gerade in PL/1 einsteigen.
Juniore Entwickler profitieren von dieser Arbeit als Einstiegspunkt in die Programmiersprache PL/I. Beispielhaft könnten Entwickler den Transpiler als Test-Umgebung für den eigenen entwickelten PL/I-Quellcode verwenden.

% Lernhilfe
Für Benutzer, die mehr Erfahrung mit Java haben, eignet sich der Transpiler als Lernhilfe. Es wird ihnen so erleichtert, PL/I-Quellcode zu analysieren. Sie können bestehende Kenntnisse aus Java anwenden, um gleiche Muster in PL/I wiederzuerkennen. Dies kann den Lernprozess beschleunigen.

% Benutzbarkeit
Der Transpiler aus der Projektarbeit-IV konnte bisher über die Kommandozeile, sowie der IDE Eclipse verwendet werden. Diese ursprüngliche Benutzung des Transpilers führte zu einer erhöhten Fehleranfälligkeit und Dokumentationsbedarf. Die Komplexität der Benutzung wird durch ein Graphical-User-Inferface (GUI) vereinfacht.
%Das Konzept dieser GUI soll dem eines Übersetzers der natürlichen Sprache, wie etwa 'DeepL' oder 'Google-Translate', ähneln. Mit diesen Konzepten sind Benutzer vertraut, erleichtert den Einstieg in die Programmiersprache PL/I, das Testen des PL/I-Quellcode, sowie die schnelle Übersetzung.

%  Entwickler die das Programm eigenständig erweitern, verändern wollen.
Durch die modularisierte Gestaltung des Transpilers können Administratoren selbst Module austauschen und erweitern, etwa durch eine API-Schnittstelle zu externen Übersetzungsbibliotheken und Services. 

%  Zusammenfassung und hinführung zum nächsten zu dem Unterschied Interpreter und Compiler
Neben den Nebenzielen der unterschiedlichen Zielgruppen, bleibt das Hauptziel die automatisierte Übersetzung von PL/I-Quellcode in Java Zielcode. Die Gestaltung des Transpilers erfolgt dabei unabhängig davon ob es sich um PL/-Quellcode und um Java-Zielcode handelt. 
Ein Transpiler kann sowohl als Interpreter und als Compiler gestaltet werden. In dem nachfolgenden Kapitel 1.3 werden die Begriffe voneinander abgegrenzt. 
	
% Aufteilung der Zielstellung:
% 1. Allgemein; Ableitung aus der Problemstellung
% 2. Zielgruppen spezfifisch
% 2.1 Einfache und unkomplizierte Lösung
%
% 2.2 Erweiterung des Transpilers bzw. ersetzen von Modulen	
	
% - Wie eine Art JavaScript Minifier oder 
%  Wer ist die Zielgruppe?
%  - Junior Entwickler die gerade in PL/1 einsteigen.
%   - Lernhilfe
%  - Online-Smoketest von PL/I Code
%   - Benutzbarkeit
%   - Entwickler die das Programm eigenständig erweitern, verändern wollen.
 
%  Ziele der Architektur (Zielgruppe Entwickler)
%  - Perspektive des Entwicklers
%  - Perspektive des Benutzers
    \pagebreak

\subsection{Abgrenzung Interpreter und Transpiler}
% Wie können Programme ausgeführt werden?
Für die nachfolgenden Kapitel soll in diesem Kapitel ein Compiler von einem Interpreter abgegrenzt werden.
  
% Wie arbeitet ein Compiler?
Ein Compiler besteht aus einem Frontend und einem Backend. Das Frontend umfasst die lexikalische, syntaktische, semantische Analyse und die Symboltabelle.
Das Ergebnis des Frontends ist eine Zwischencodedarstellung, die an das Backend übergeben wird, um daraus Maschinencode zu generieren. Der Maschinencode kann auf dem zugrundeliegenden System ausgeführt werden. \footcite[Vgl. ][S.106ff. ]{aho}
Um weiterhin den Prozess der Übersetzung mithilfe eines Compilers darzustellen, wird Abbildung \ref{fig:compiler} verwendet.

\pagebreak
% @todo: Quelle
\dhgefigure[h]{compiler-ablauf-diagramm.png}[scale=0.75]{Funktionsweise eines Compilers}{fig:compiler}[][]

\pagebreak
Abbildung \ref{fig:compiler} zeigt eine Übersicht und das Ergebnis der einzelnen Phasen. Die Abbildung unterteilt den Ablauf wie eingangs beschrieben in Frontend und Backend.

In der ersten Phase teilt der Compiler den eingegebenen String in Tokens auf. Danach entsteht ein Syntaxbaum, der in diesem Beispiel die Zwischencodedarstellung repräsentiert. Alternativ dazu wäre etwa der Drei-Adress-Code. Ab diesem Punkt beginnt das Backend des Compilers. Zuerst erzeugt das Backend maschinenunabhängigen Code und anschließend maschinenabhängigen Code. Dieser maschinenabhängige Code ist auf dem zugrundeliegenden System ausführbar. \footcite[Vgl. ][S.30 ]{aho}

%  Warum ein Transpiler?
Neben den Eingangs beschriebenen Compiler, gibt es weitere Lösungen die auf einem ähnlichen Konzept basieren.
Ein One-Pass-Compiler etwa erzeugt keinen Zwischencode, sondern führt den Code direkt aus. Diese Methode wurde angewendet, um Speicherplatz zu sparen, da frühe Computer nur begrenzte Kapazitäten hatten und keine Zwischenergebnisse speichern konnten. Ein Beispiel für eine Sprache, die mit einem One-Pass-Compiler kompiliert wird, ist Turbo Pascal. \footcite[Vgl. ][]{onepass}

Eine weitere Ausprägung ist ein Source-to-Source Compiler.
Während ein C-Compiler den C-Code nach der Zwischencodeerzeugung in Assemblersprache und anschließend der Assembler den C-Quellcode in Maschinencode übersetzt, wandelt ein Source-to-Source-Compiler beispielsweise C-Quellcode in Java-Zielcode um. 
Ein Source-to-Source-Compiler wird im Zusammenhang dieser Arbeit als Transpiler bezeichnet und ist deckungsgleich mit dem entwickelten Programm.

Abbildung \ref{fig:transpiler} zeigt die Prozessschritte eines Transpilers.

\pagebreak
\dhgefigure[h]{transpiler-diagramm.png}[scale=0.75]{Funktionsweise eines Transpilers}{fig:transpiler}[][]
\pagebreak

Ein Vergleich von Abbildung \ref{fig:compiler} mit Abbildung \ref{fig:transpiler} zeigt, dass die ersten Phasen bis zur Zwischencodeerzeugung gleich bleiben. In Abbildung \ref{fig:transpiler} sind jedoch die Prozesse des Frontends neben denen des Backends dargestellt. Während in Abbildung \ref{fig:compiler} diese untereinander angeordnet sind. Zurückzuführen ist diese Darstellung auf die verwendeten Sprachebenen.

Ein Compiler übersetzt den Quellcode einer Hochsprache in eine maschinennahe Sprache wie Assembler. Hingegen bleibt der Transpiler auf der Sprachebene der Quellsprache. In Abbildung \ref{fig:transpiler} werden zudem die Phasen des Backends reduziert, da keine Übersetzung in eine maschinenabhängige Sprache erforderlich ist.

% @review
Ein weiter Unterschied zu einem herkömmlichen Compiler ist die Art der Ausführung des übersetzten Zielcodes.
Das Ergebnis der Übersetzung eines Compilers ist Binärcode der auf einem Zielsystem ausgeführt werden kann. Um hingegen das Ergebnis eines Transpilers auszuführen,
braucht es einen weiteren Compiler. Dieser Compiler muss den Zielcode der Zielsprache in Binärcode übersetzen.
Bei der Übersetzung von PL/I-Quellcode zu Java-Zielcode, bedarf es also einen weiteren Java-Compiler zum ausführen des Zielcodes.

% @review: Cross Compiler? - Hat hier eig nix zu suchen, ist Thema für Boostrapping aber nicht für Transpiler
Neben den Methoden der Konstruktion, gibt es auch unterschiedliche Verwendungen von Compilern. 
Etwa existiert der Begriff der Cross-Kompilierung. Hierbei handelt es sich um die Möglichkeit einen Compiler, der sich auf einem externen Computersystem befindet zu verwenden um den Quellcode auf dem lokalen System in Binärcode zu übersetzen. \footcite[Vgl. ][]{guncross}

%Diese Verwendungsweise findet etwa Anwendung beim Bootstrapping. Liegt auf dem System noch kein Compiler für die Sprache vor, in der der Kernel geschrieben wurde, wird diese Methode verwendet um den Kernel-Code zu kompilieren. 
In dieser Arbeit kommt ein solcher Ansatz bedingt zum Einsatz. Wird der Transpiler in einem Webinterface verwendet, ist die Verhaltensweise ähnlich.
Da auch hier der Compiler auf einem anderen Host-Computer, den lokalen Quellcode übersetzt.

Zusammenfassend übersetzen sowohl One-Pass-Compiler, Transpiler bzw. Source-to-source Compiler als auch herkömmliche Compiler das Programm basierend auf einer Zwischencodeerzeugung. \footcite[Vgl. ][S. 18ff. ]{assambly}
Eine Alternative ist der Interpreter. Dieser führt den Quellcode direkt Zeile für Zeile aus.

% Wie arbeitet ein Interpreter?
Im Vergleich zu einem Compiler hat der Interpreter weder ein Frontend noch ein Backend. Es gibt keine klare Trennung zwischen einem Frontend, das eine unabhängige Repräsentation des Codes erzeugt, und einem Backend, das diese Repräsentation interpretiert. 

Ein Interpreter wird etwa durch die Shell verwendet um Benutzerbefehle zu verarbeiten. 
In Abbildung \ref{fig:shell} ist der Verarbeitung des Bash Interpreters dargestellt.


\dhgefigure[h]{shell_interpreter.png}[scale=0.75]{Ablauf der Interpretation eines Shell Programms}{fig:shell}[][]
\pagebreak

Die Eingabe des Bash-Skripts wird zeilenweise gelesen.
Das Quoting folgt dem Prinzip der lexikalischen Analyse, bei der alle Sonderzeichen entfernt werden, wie zum Beispiel Kommentare oder Backslashes. Sobald das Quoting abgeschlossen ist, entsteht ein String, der nur aus den Tokens eines Ausdrucks besteht.

Anschließend beginnt das Parsing, das der syntaktischen Analyse im Kompilierprozess ähnelt, jedoch keine Zwischencodeerzeugung beinhaltet. Hier wird lediglich zwischen einfachen Bash-Befehlen wie \verb+wc+ und zusammengesetzten Befehlen wie einem \verb+if+-Ausdruck unterscheiden.

Der Verarbeitungsprozess setzt sich mit der Shell-Expansion fort, bei der in einem Befehl eingebettete relative Ausdrücke durch ihre absoluten Repräsentationen ersetzt werden.
Schließlich wird das Ergebnis in der Kommandozeile ausgegeben. \footcite[Vgl. ][]{gnubash}

% Absatz: Zusammenfassende Unterscheidung zwischen Interpreter und Transpiler, Was sind gemeinsamkeiten und unterschiede von Transpiler und interpreter?

Zusammenfassend zeigen sich sowohl Ähnlichkeiten als auch Unterschiede zwischen einem Interpreter und einem Compiler bzw. Transpiler. Beide durchlaufen die Phasen der lexikalischen und syntaktischen Analyse, wobei sie den Quellcode zunächst um Kommentare, Leerstellen oder andere für die Übersetzung irrelevante Symbole bereinigen. Anschließend erfolgt entweder die direkte Übersetzung des Quellcodes oder die Erzeugung einer unabhängigen Repräsentation.

Um PL/I-Code korrekt in Java zu übersetzen, sind Verbindungen zwischen den Ausdrücken relevant. Eine zeilenweise Übersetzung könnte zu einem Java-Programm führen, das den restlichen Kontext des Programms nicht weiter berücksichtigt. Der Transpiler sollte eine solche Repräsentation berücksichtigen können.

Um eine solche Zwischencodeerzeugung zu generieren wird ein Frontend benötigt. Wie schon in den Abbildungen \ref{fig:transpiler} dargestellt sind die ersten Arbeitsschritte des Frontends die lexiklaische und syntaktische Analyse. Für beide Prozessschritte werden ein Parser und Lexer benötigt. Mit einem Compiler-Compiler können automatisiert Programme erzeugt werden die einen PL/I-Quellcode in eine Zwischencodedarstellung transformieren.
Das folgende Kapitel beleuchtet Grammatiken formaler Sprachen wie PL/I und Java genauer um auf die Verwendung eines Compiler-Compilers vorzubereiten.
% Der entscheidende Unterschied liegt darin, dass der Interpreter den Quellcode lediglich zeilenweise direkt übersetzt, während der Compiler das Programm in eine andere Form transformiert und liest. Dabei stehen die verwendeten Ausdrücke des Eingabecodes in Beziehung zueinander, beispielsweise durch die Verschachtelung von Verzweigungen und Schleifen.



% - Erweiterung des Umfangs während der Laufzeit
% - Trennung Laufzeit/Konzeptionsphase

% - Hier erwähnen das eine geminsamkeit die definition von Grammatiken ist, dann überleiten zu Formale Grammatiken.
% - Auch Entscheidung treffen was genau der Transpiler ist, Compiler oder Interpreter
\pagebreak
   
   
\subsection{Formale Sprachen und ihre Grammatiken}
% Warum braucht ein Compiler eine Grammatik?
% In dem vorangegangen Kapitel wurden unterschiedliche Methoden, Anwendungsgebiete und Formen der Sprachinterpretation eines Computers vorgestellt. Damit die Interpretation von Sprachen korrekt erfolgt, braucht ein Computer Regeln. Grammatiken beinhalten diese Regeln. 

Damit der Transpiler korrekt arbeitet wird eine definierte Grammatik benötigt. Nur so können die Prozessschritte der Lexikalischen- und der Syntaktischen Analyse korrekt erfolgen. Denn diese Schritte prüfen den eingegeben Quellcode auf seine grammatikalische Richtigkeit. Bevor also die Sprachliche Analyse erfolgen kann, sollte eine Grammatik definiert und angewendet werden. Um eine Grammatik für eine formale Sprache, wie einer Programmiersprache zu definieren sind logische präzise Beschreibungen von Ausdrücken notwendig. \footcite[Vgl. ][S. 149ff. ]{automata} 
Eine Grammatik einer formalen Sprache besteht aus Variablen, Terminalsymbolen, einen Startsymbol und einer Produktion. Zusammengefasst in:

\begin{center}
\begin{equation}\label{eqn:grammar}
G=(V,T,S,P)
\end{equation}
\end{center}

Hierbei \verb+V+ für Variablen bzw. Nicht-Terminalsymbole, \verb+T+ für Terminale, \verb+S+ für Start und \verb+P+ für Produktion steht. Dabei ist \verb+S+ ein Teil von \verb+V+.  \footcite[Vgl. ][S. 31ff. ]{automata}

% @review: Keine Hierachie Einordnung, ledilgich nennen das es sie gibt.
% Welche Typen von Grammatiken gibt es? Chomsky Hierarchie
Grammatiken lassen sich weiter durch die Chomsky Hierarchie spezifizieren. Noam Chomsky unterteilt Grammatiken in vier Ebenen. Ebene null beschreibt unbeschränkte-, Ebene eins kontextsensitive-, Ebene zwei kontextfreie- und Ebene drei reguläre Grammatiken.\footcite[Vgl. ][]{chomsky}

\pagebreak

Um eine Grammatik darzustellen werden Ableitungen von Produktionen verwendet. In Listing \ref{eqn:start} ist die Produktion einer einfachen \verb+if+ und \verb+else+ Verzweigung dargestellt.

% @todo: PL/I Verwenden und Kontext herstellen
\begin{center}
\begin{equation}\label{eqn:start}
S \to \mathbf{if}\: expr\: \mathbf{then}\: stmt\: \mathbf{else}\: stmt\: | \mathbf{if}\: expr\: \mathbf{then}\: stmt;
\end{equation}
\begin{equation}
expr \to expr\: op\: term\: | term
\end{equation}
\begin{equation}
op \to \mathbf{>}\: |\: \mathbf{<}\: |\: \mathbf{=}\: |\: \mathbf{!}
\end{equation}
\begin{equation}
term \to term\: multOp\: factor\:
\end{equation}
\begin{equation}
factor \to \mathbf{id}\: |\: \mathbf{constant} 
\end{equation}
\end{center}
 
Mit der beschriebenen Grammatik ist folgender Ausdruck zulässig.

\begin{lstlisting}[language=PL/I, caption=If Statement PL/I, label={lst:pliifstatement}]
IF A > B THEN 
	CALL proc_1;
ELSE 
	CALL proc_2;
END
\end{lstlisting}

Nicht zulässig ist hingegen.

\begin{lstlisting}[language=PL/I, caption=Wrong Statement PL/I, label={lst:pliwrongstatement}]
CALL IF THEN A > B proc_1;
\end{lstlisting}

Weil das Wort \verb+CALL+ in Listing \ref{lst:pliwrongstatement} nicht in dem Kontext stehen darf.

% @todo: Beispiel-Parsebaum analyse, https://en.wikipedia.org/wiki/LR_parser 
	
% Wie werden Grammtiken in einem Transpiler Programm verwendet?
Grammatiken sind für den Transpiler von Bedeutung, weil die Lexikalische und Syntaktische Analyse aus einer solchen Grammatik erzeugt werden. Mithilfe eines Compiler-Compilers kann aus einer Repräsentation einer formalen Grammatik ein Parser definiert werden.
 
Die aktuellste Grammatik wird durch IBM, in der PL/I Language Referenz definiert. Aus dieser wird mithilfe von JavaCC ein Parser erzeugt. Weshalb in dem folgenden Kapitel 1.5 der Compiler-Compiler und die dazugehörige Grammatik näher beschrieben wird.

% - Theoretischer Abriss
% - Einordnung der resultate der PA 4
%- PL/1 Syntax Wo zu finden? Welche Version der Sprache? 
%	- Reguläre Ausdrücke Syntax, Beispiel einer Grammatik die ich mit verwende, Typ einer Grammatik
%  - Literatur
%    - Chomsky Hierarchie Bücher
%    - https://www-igm.univ-mlv.fr/~berstel/LivreCodes/Codes.html
%  - Woraus besteht eine Grammatik?
%   - Wie lassen sich Grammatiken der Komplexität nach anordnen?
%  - Chomsky Hierarchie
%  Erst Chomsky Hierachier, dann nach Komplexität einordnen und am Beispiel von Regulären Ausdrücken und PL/I Grammatik einführen.
     
\subsection{Anwendung von Formalen Grammatiken in JavaCC}
% 1. Was ist ein Compiler-Compiler? (Verbindung von formalen Grammatiken zu JavaCC)

In Kapitel 1.3 wurde bereits in die Thematik der formalen Grammatiken eingeführt, in diesem Kapitel wird nun die praktische Implementation dieser Grammatiken im Zusammenhang mit dem Transpiler beschrieben.
Ein Compiler-Compiler wie JavaCC ist eine Technologie mit der aus einer formalen Beschreibung einer Grammatik ein Lexer und ein Parser erzeugt werden. 
Der Lexer und der Parser wenden die in der Grammatik definierten Regeln an und verarbeiten entsprechend die übergebenen Ausdrücke.
Die Darstellung der Grammatik erfolgt in der Regel in einer Art \ac{ebnf}. 
Beispielhafte Compiler-Compiler sind neben JavaCC, Yacc, Antlr und Lexer.
In Kapitel 1.3 wurde bereits vereinfacht eine Produktion aus der PL/I-Grammatik dargestellt. Ähnlich erfolgt auch die Darstellung in einer Grammatikdatei. Folgendes Beispiel zeigt die Darstellung eines \verb+IF ELSE+ Ausdrucks. 
\footcite[Vgl. ][]{javaccdoku}


\begin{lstlisting}[language=Java, caption=If Statement aus der Grammatikdatei, label={lst:ifstatement}]
	void if_statement() #IF :
	{}
	{
		< IF > bool_expression() (bool_operation() bool_expression() )*
		< THEN >proc_body()
		[< ELSE >
		proc_body()]
		
	}
\end{lstlisting}

In JavaCC besteht die Möglichkeit die Beschreibung von Produktionen in Methoden zu Kapseln.
In Zeile 1 ist der Methodenkopf zu sehen. In diesem Fall erzeugt die Methode \verb+if_statement+ keinen Rückgabwert.
Das durch die Raute gekennzeichnete Symbol ist die Repräsentation im Parsebaum und zusätzlich auch die Darstellung im Zwischencode.
Im Körper der Methode wird der If-Ausdruck weiter definiert. Terminalsymbole werden in der JavaCC Grammatik mit den größer-als und kleiner-als Zeichne umrandet. Die Nicht-Terminalsymbole hingegen sind wie in Listing \ref{lst:ifstatement} dargestellt weitere Methoden, die wiederum weitere Ausdrücke beschreiben.

Ähnlich wie bei der Produktion aus Listing \ref{lst:ifstatement}, so lange bis lediglich Terminalsymbole übrig bleiben.
Die Methode \verb+bool_expression+ etwa, beschreibt einen zulässigen Boolschen Ausdruck, der durch einen weiteren boolschen Operator mit einem weiteren booleschen Ausdruck verknüft werden kann.

Weiterhin wird in der Methode \verb+proc_body+ beschrieben welche Ausdrücke weiter zulässig sind. Dazu zählt bspw. auch eine weitere \verb+IF ELSE+ Verzweigung. So werden auch verschachtelte Ausdrücke möglich.
Werden nach und nach die Methoden durch den Compiler-Compiler aufgerufen, ergibt sich eine Regel für Verzweigungen. Nach diesem Prinzip ist die gesamte Grammatik für PL/I gestaltet. 
Die Wurzel aller Methoden, die einen Ausdruck beschreiben, die Methode \verb+program+, welche das gesamte Programm darstellt.
Aus dem definierten Ausdruck aus Listing \ref{lst:ifstatement} wird schlussendlich ein Parsebaum erzeugt, der durch die Module des Transpilers weiter verarbeitet wird.

% Warum ein Compiler-Compiler verwenden?

Ein Compiler-Compiler generiert somit einen fertigen Parser. Nun gibt es auch die Möglichkeit einen Parser und Lexer selbst zu programmieren. In der Version aus der Projektarbeit-IV wurde ursprünglich ein selbstgeschriebener Lexer verwendet.

Jedoch birgt dieses Vorgehen einen Nachteil. Die Grammatik für den Transpiler ist an zwei stellen definiert und muss somit auch an zwei Stellen gewartet werden.
Wird in die Grammatikdatei für den Parser ein neuer Ausdruck hinzugefügt, muss dieser Ausdruck auch durch den Lexer verarbeitet werden können.
Ursprünglich musste so der Lexer angepasst werden und die Grammatikdatei für den Parser. 
Das führte zu einem erhöhten Arbeitsaufwand und Fehleranfälligkeit. Schlussendlich wurde der selbstgeschriebene Lexer entfernt und der von JavaCC definierte Lexer verwendet.
Somit ist ein Compiler-Compiler gut dazu geeignet den Arbeitsaufwand für die Entwicklung eines Compilers, bzw. eines Transpilers zu reduzieren. 
Es lohnt sich auch bei der Entwicklung eines Parser für andere Sprachen auf bereits definierte Ressourcen zurückzugreifen. 
Grammatiken für Cobol und Java wurden bereits von der JavaCC Community bereitgestellt. \footcite[Vgl. ][]{javaccdoku}
Im Fall von PL/I ist keine Grammatik vorhanden. Weshalb bei der Entwicklung des Transpilers, die IBM Language Reference für PL/I die Hauptquelle für die Grammatikdatei ist.   

% Wie wird JavaCC in die Entwicklung des Transpiler eingebunden ? (Hinleitung zur Architektur beschreibung)
Durch die Verwendung des JavaCC Jjtree-Moduls, kann global innerhalb des Projekts auf den Parse-Baum zugegriffen werden. 
Der Prase-Baum wird unteranderem durch die Module verwendet, die die Semantische-Analyse und -Synthese repräsentieren.
Erst durch diese wird der Java-Code erzeugt.

Ebenfalls wird für den Parser ein File-Stream benötigt, ein Scanner liefert solchen.
Neben den Parser werden also weitere Module verwendet um schlussendlich den Java-Code für den Benutzer bereitzustellen.
Die gesamte Architektur des Transpilers und dessen weitere Module wird in dem nachfolgenden Kapitel betrachtet. 
Hier werden auch die Technologien vorgestellt die neben JavaCC verwendet werden. 

\section{Technisches Vorgehen}
\subsection{Techstack}
%- Compiler Compiler -> JavaCC: Integration in das Projetk, Grund für die Wahl der Technologie
In Kapitel 1.4 wurde bereits mit JavaCC eine verwendete Technologie vorgestellt. Neben JavaCC kommen auch weitere Technologien während der Entwicklung zum Einsatz. In dem folgenden Kapitel werden die weiteren verwendeten Technologien vorgestellt.

%- Programmiersprache -> Java: Integration in das Projekt, Grund für die Wahl.
Allgemein wurde der Transpiler in der Programmiersprache Java entwickelt. 
Java eignet sich für die Entwickelung da sie eine Hochsprache ist, die ebenfalls explizite Handhabung zulässt. 
Weiterhin zählen die Vorteile die in Kapitel ?.? für Java erwähnt wurden, ebenso in diesem Fall.

Den Administratoren soll auch die Möglichkeit gegeben werden, Module einfach auszutauschen. Mithilfe von Objektorientierten Programmier- Paradigmen, lässt sich eine lose Kopplung der Klassen realisieren und damit eine Modulare Bauweise des Software Projekts.
Einhergehend fiel die Wahl auf JavaCC aufgrund der Entscheidung für die Entwicklung des Transpilers in Java. Eine alternativer Compiler-Compiler für Java, ist Antlr. 

%- IDE -> Eclipse: Integration in das Projekt, Grund für die Wahl.
Der Java-Quellcode des Transpilers wurde in Eclipse geschrieben. Die \ac{ide} Eclipse ermöglicht eine kostenlose Entwicklung, Verwaltung, Überprüfung und Kompilierung von Java Software-Projekten. Weiterhin bietet Eclipse eine breite Software-Repository an Plugins um die Funktionalität der  \ac{ide} zu erweitern. Dadurch ist eine Integration von JavaCC in die  \ac{ide} möglich und erleichtert die Entwicklung des Parser ebenfalls.

%- Maven -> Dependency Management: Integration in das Projetk, Grund für die Wahl der Technologie
Die Version aus der Projektarbeit-IV des Transpilers verwendete die Native Projektstruktur von Eclipse als Vorlage. Diese Projektvorlage brachte jedoch negative Aspekte mit sich. Es war nötig JavaCC manuell zu installieren und einzurichten. Zusätzlich mussten Pfad variablen im Quellcode angepasst werden. 
Das erschwerte den Benutzern den Zugang zu dem eigentlichen Projekt.
Zurückzuführen ist dies auf die fehlenden Software-Abhängigkeitsverwaltung. In der Ursprünglichen Version des Transpilers musste der Benutzer selbst herausfinden welche Software dieser benötigt um das Programm zu starten

Dieses Problem wurde gelöst in dem das Software-Projektmanagement-Werkzeug Maven eingesetzt wurde. Maven löst mithilfe des \ac{pom} Abhängigkeiten. 
Dadurch werden Benutzer und Administratoren bei dem Build-Prozess entlastet.
Ein weiterer Vorteil den Maven liefert ist die vordefinierte Projektstruktur, in den sich vertraute Administratoren zurecht finden.

%- Testing -> JUNit Tests: Integration in das Projetk, Grund für die Wahl der Technologie
Zum Testen der Anwendung wurde das Java-Testing Framework JUnit 5 verwendet. Es wurden für jede Klasse zugehörige Test-Klassen geschrieben. In den Test-Klassen wurde komplexere Methoden isoliert getestet.
Die Wahl von JUnit ist begründet durch die einfache Handhabung, der Kompatibilität mit der IDE Eclipse und dem Projektmanagement Werkzeug Maven. Weiterhin ist JUnit mit eines der bekanntesten Unit-Testing-Frameworks für Java-Quellcode. Alternativen wären etwa gewesen TestNG \footcite[Vgl. ][]{testng} oder mockito \footcite[Vgl. ][]{mockito}.

%- Platform -> Spring
Für die Entwicklung des Frontends wurde das Java Framework Spring-boot verwendet.
Dabei wurde das Web-Interface mit der CSS-Softwarebibliothek Bootstrap gestaltet.
Spring-Boot wird für das behandeln von REST-Anfragen verwendet und bindet über eine API Schnittstelle den Transpiler ein.
Dadurch wird eine Interaktion über den Browser möglich.

Mithilfe der, in diesem Kapitel genannten Software-Werkzeuge, wurde der Transpiler entwickelt. Die Entwicklungsphase folgte jedoch nach der Konzeptionsphase.
In der Konzeptionsphase wurde die Architektur der Anwendung ausgearbeitet und später als Quellcode realisiert. 
In dem nächsten Kapitel soll dieses Architekturbild vorgestellt werden.

\subsection{Architektur} 

Die Architektur des Transpiler wurde nachdem Vorbild eines \ac{mvc} Konzepts entworfen. 
% Wie benutze ich den Transpiler?
Das Model der Anwendung wird durch die gespeicherten Symbole in den Symboltabellen integriert.
Der Controller beinhaltet alle Module, die den PL/I-Quellcode analysieren, verarbeiten und in den Java-Zielcode übersetzen.
Eine Schnittstelle für die Interaktion ist entweder die \ac{ide} in der das Projekt importiert wird, die Kommandozeile oder die Webseite. Diese umfassen somit den View Teil der Architektur.

In Abbildung \ref{fig:modules} sind die Module in den Arbeitsprozess des Transpilers dargestellt.

\dhgefigure[h]{AbstraktesUML_1.png}[scale=0.5]{Der Aufbau des Transpiler}{fig:modules}[][]

% Wie sind die Module momentan gebaut?
% App Modul
Die Verarbeitung des PL/I-Quellcodes beginnt mit dem App-Modul. Das App Modul ist die Schnittstelle für alle weiteren Module. Ein Modul kann durch die Instanziierung der Hauptklasse eingefügt werden. Entfernt wird das Modul durch das Löschen der Instanz. Das App-Modul beinhaltet auch die \verb+main+ Methode und ist somit auch der Startpunkt des Java-Compilers.

Der Scanner wird als erstes Instanziiert. Dieser liest aus der Konfigurations-Datei den Pfad der PL/I Datei, die übersetzt werden soll. Die Datei wird als \verb+InputStream+ an den Parser übergeben.

Der durch JavaCC erzeugte Parser wird ebenfalls in dem App-Modul instanziiert. Dieser behandelt den PL/I-Quellcode entsprechend der vorher definierten Grammatik. 

Während des parsings werden Variablen-, Prozeduren-, oder Packagebezeichner des PL/I-Quellcode, in die Symboltabelle eingefügt. 

Das Ergebnis des Parsers ist ein Parse-Baum. 
In Abbildung \ref{fig:parsetree} is exemplarisch ein Parsebaum des Transpilers abgebildet der eine Variablen Deklaration und eine Definition einer Prozedur darstellt.

\dhgefigure[h]{parsetree-example.drawio.png}[scale=0.5]{Beispielhafter Parsebaum des PL/I Parser}{fig:parsetree}[][]

Ist der Parsebaum entsprechend erzeugt, wird dieser weiterhin durch das Checker-Modul verarbeitet. In diesem Modul wird die semantische Analyse des Quellcodes durchgeführt. Dabei wird auch die Symboltabelle verwendet um die Referenzen der Bezeichner im Quellcode auf Korrektheit zu überprüfen.

% @review: Hier erwähnen wie Configdatei bzw. Scanner den Ausgabe Ordner beeinflussen wenn das implementiert wurde.
Das Mapper-Modul repräsentiert die Synthese des PL/I-Quellcodes in Java-Zielcode. Der Parsebaum wird hier Stück für Stück abgearbeitet und mit entsprechenden Java-Ausdrücken übersetzt.

% @todo: Wie sind Module zueinander abhängig?
Die Kopplung der Module sollte lose sein, um dem Administrator eine leichte Erweiterung der Anwendung zu ermöglichen.

Um einen Überblick über Abhängigkeiten zu verschaffen, zeigt
Abbildung \ref{fig:modulesdep} aktuell die Beziehungen der Module untereinander.

\dhgefigure[h]{Beziehungen_Modules.png}[scale=0.5]{Die Abhängigkeiten der Module}{fig:modulesdep}[][]
\pagebreak

Zu erkennen ist in Abbildung \ref{fig:modulesdep} das die Abhängigkeiten unter den Modulen eine Kaskade Form aufweisen.
Diese Form hat den Vorteil das Module aus dieser Kette verändert werden können ohne Vertikal verlaufende Module direkt zu beeinträchtigen.
Dennoch ist an dieser Stelle zu erwähnen das kein Modul isoliert betrachtet werden darf. Denn eine Veränderung eines Moduls bedeutet das auf Horizontaler 
Ebene die Verarbeitung verändert wird.

% Wie sind die Module momentan gebaut?
Jedes Modul gibt die Ergebnisse weiter an das nächste bis ein Zielcode entsteht, oder eine Fehlermeldung.

% @todo: Wie wird es erweitert?
Der Administrator kann die Module erweitern oder ersetzen.
Dabei sollte jedoch die in Abbildung \ref{fig:modulesdep} dargestellte Kaskade der Module untereinander berücksichtigt werden.
Entscheidet sich der Administrator dazu etwa eine Methode zu entfernen und eine selbst entwickelte zu verwenden, ist lediglich die bisherige 
Referenz zu ersetzen.
%In der vorherigen Version des Transpilers wurde etwa die Lexer-Klasse entfernt und die Klassen des Compiler-Compilers verwendet.
%Der Quellcode des Lexer besteht jedoch und ist lediglich als Deprecated markiert. Die erneute Verwendung des Lexer würde über den Aufruf der Methode in Main erfolgen.
%Hingegen wären hier weitere Schritte notwendig, wie etwa das einfügen einer temporären Datei, die von dem Parser als InputStream entgegen genommen wird und weiter verarbeitet wird.

Nachdem nun ein Überblick über die Architektur gegeben wurde, soll nun in Kapitel ?.? eine Detailansicht des Transpilers erfolgen.
Ab diesem Punkt soll genauer auf den Quellcode der einzelnen Module eingegangen werden um nachzuvollziehen wie der Transpiler den PL/I-Quellcode
in Java-Zielcode umwandelt.

%Bausteine
%- Software Architektur
	%- Planen mithilfe eines UML
	%- UX Design 
    %    - zweite Diagramm, des Benutzerfluss
    %    - wie Benutzung abläuft
	%	- Website?
	%	- Docker Container?
%- Fehlertracking
%- Struktuierung des Programms, sodass ein Benutzer es selbständig erweitern kann

%\subsection{Aspektorientierte Programmierung}
%- Wie funktioniert Aspektorientiert Programmierung?
%	- Wie Löse ich mit Aspektorientierter Programmierung konkrete Probleme?
%- JavaBeans
%- Spring
%	- Wie setzt Spring Aspektorientierte Programmierkonzepte ein?
 
\subsection{Module des Transpilers}
%Wie in dem vorangegangen Kapitel schon dargestellt, werden in jedem Modul
die Verarbeitungsschritte aus Abbildung \ref{fig:transpiler} implementiert.
%In diesem Kapitel sollen die Module nach ihrer Verarbeitungsreihenfolge vorgestellt werden.
%Dabei soll ein \ac{uml}-Diagramm je zu beginn der Unterkapitel verdeutlichen wie die Klassen
%in den Modulen zueinander aufgebaut sind. In jedem Diagramm wird auch auf die Einbindung in die App-Klasse eingegangen.
%Die Beschreibung beginnt mit dem Scanner.

\subsubsection{Der Scanner und Parser}
\paragraph{Scanner}
Wie Kapitel 1.? eingeführt wird der Parser vollständig durch JavaCC generiert.
Damit der Parser den PL/I-Quellcode in die Zwischencode Darstellung übersetzen kann,
braucht dieser eine PL/I-Datei, die als Stream Übergeben wird.
Den Pfad zu der Datei gibt der Administrator in der Konfigurationsdatei an.
Das Modul Scanner liest die Konfigurationsdatei und versorgt den Parser mit notwendigen Ressourcen.
Abbildung \ref{fig:scannermodul} zeigt das UML-Diagramm des Scanner Moduls.

\dhgefigure[h]{scanner-klasse-uml.drawio.png}[scale=0.5]{Das Scanner Modul}{fig:scannermodul}[][]

Das Scanner Modul besteht aus den Klassen \verb+InputReader+ und \verb+Lexer+. 
Die \verb+InputReader+ Klasse liest und verarbeitet die Konfigurationsdatei. Ein Ausschnitt einer möglichen Konfigurationsdatei ist in Listing ?.? hinterlegt.

\begin{verbatim}
	PATH=./src/main/java/res/pli/NPP1NFG.pli;
\end{verbatim}

Die Methode \verb+getInputFilePath+ gibt den Pfad der PL/I-Quellcode Datei als String zurück.
Dieser String wird beim Aufruf der \verb+getInputFile+ Methode benötigt, um aus der Datei einen \verb+InputStream+ zu erzeugen.
Mithilfe des InputStreams kann die Datei als Parameter an den Parser in der Klasse \verb+App+ im Modul \verb+App+
übergeben werden. 

%\paragraph{Lexer}
%Die Klasse Lexer des Moduls Scanner enthält den ehemals selbst geschriebene Lexer für die lexikalische Analyse. Dadurch das dieser Prozess nun vollständig von dem JavaCC-Parser übernommen wird, wurde die Methode \verb+getToken+ überflüssig. Diese ist als veraltet mit der Kennung 'Deprecated' beschrieben, sie kann im Projekt noch verwendet werden, jedoch mit einem Risiko das die Ergebnisse der Methode nicht korrekt sind. 
%Zu einem späteren Zeitpunkt ist denkbar den selbstgeschriebenen Lexer zu optimieren und erneut einzubinden. Weshalb dieser nicht gelöscht wurde. 
%Weitere Methoden in dieser Klasse werden ebenfalls nicht länger von Klassen aus anderen Modulen verwendet. 

\paragraph{Parser}
Das Parser-Modul deckt die lexikalische und syntaktische Analyse des PL/I-Quellcodes ab.
Wie schon in Kapitel 1.4 erwähnt werden jegliche Klassen des Parsers durch die \verb+.jjt+ Grammatikdatei generiert. Da diese Klassen sehr umfangreich sind, werden diese in Abbildung \ref{fig:moduleparser} lediglich in Abgekürzter Form dargestellt. 

\dhgefigure[h]{parser-module-uml.drawio.png}[scale=0.4]{Das Parser Module}{fig:moduleparser}[][]
\pagebreak

Der Parser wird über die Klasse \verb+Pl1Parser+ in dem App Modul instanziiert. In der Parser-Klasse sind auch jegliche manuell geschriebenen Methoden aus der Grammatikdatei integriert. 
Dazu gehören etwa die Methode \verb+installId+, sowie weitere. 

Die ebenfalls in der Grammatikdatei definierten Tokens werden in der Klasse \verb+Pl1ParserConstants+ als Konstanten definiert. Wobei während der Lexikalischen Analyse, die Klasse Token verwendet wird um Terminalsymbole zu verarbeiten. 
Schlussendlich wird einhergehend mit der Klasse \verb+Pl1Parser+ geprüft ob der PL/I-Quellcode zulässig ist. 
Diese beinhaltet die Java Repräsentation der in der Grammatikdatei definierten Methoden. Hier ist auch der großteils der Verarbeitungslogik des Parser-Moduls implementiert.

Wird ein Ausdruck während der Verarbeitung in Pl1Parser-Klasse als nicht zulässig  interpretiert wird eine \verb+ParseException+ geworfen, die in der Klasse \verb+ParseException+ definiert ist.

Um den Ausdruck in einem Parsebaum zu repräsentieren wird ein Objekt der Klasse \verb+SimpleNode+ erzeugt. Durch die Methoden \verb+clearNodeScope+ und \verb+closeNodeScope+ der Klasse \verb+JJTPl1ParserState+ wird der verarbeitete Ausdruck mit bspw. der Repräsentation \verb+PROC+ in den Prasebaum eingefügt. 

So verarbeitet der Praser des Transpilers Stück für Stück den PL/I-Quellcode. Hat der Parser ein Nicht-Terminalsymbol gefunden, wird die Methode \verb+installIds+ aufgerufen und der Bezeichner unter bestimmten Bedingungen in die Symboltabelle eingefügt. 
Ein Bezeichner wird nicht eingefügt, 
wenn dieser schon vorhanden ist und den selben Sichtbarkeitswert hat.

Dabei wird das Modul \verb+SymbolTable+ implementiert und mit der Methode \verb+insertId+ ein Bezeichner in die Symboltabelle eingefügt. In dem folgenden Unterkapitel wird das Modul der Symboltabelle genauer beschrieben. 

\subsubsection{Symboltable}
Die Symboltabelle speichert die PL/I-Symbole in einem Hashtable ab. Mit ihr sollen die anderen Module
erkennen können ob es sich bei einem ausgewählten Token um ein PL/I-Symbol handelt, oder um ein Bezeichner.
In Abbildung \ref{fig:symboltable} ist das Modul \verb+symboltable+ als \ac{UML} dargestellt.

\dhgefigure[h]{symboltable-module-uml.drawio.png}[scale=0.5]{Symboltabelle Modul}{fig:symboltable}
\pagebreak

Das Modul \verb+Symboltable+ enthält die Klassen \verb+SymbolTable+, \verb+Pl1Symbols+ und \verb+PictureMapper+.
Zusätzlich enthält das Modul die Enums \verb+Pl1Symbols+ und \verb+Template+.

% Wie funktioniert SymbolTable und Pl1Smybols?
Die Klasse \verb+SymbolTable+ wird beim instanziieren des Objekts mit den Werten aus dem Enum \verb+Pl1Symbols+ initialisiert. 

Wenn ein Bezeichner in die Symboltabelle eingefügt wird müssen, ein String für den Bezeichner, ein String für den Typ, ein Integer für die Sichtbarkeit und ein Integer für die Hierarchiestufe der Variable hinterlegt sein. Nur so kann in darauffolgenden Arbeitsschritten wie in der semantischen Analyse, die Werte korrekt verarbeiten.

Die Methoden sind hauptsächlich dazu da, Symbole oder Attribute von Symbolen gezielt abzufragen oder in der Konsole auszugeben.

Etwa die \verb+getSymbolScope+ Methode wird dazu verwendet den Sichtbarkeitswert eines Bezeichners auszugeben.

% Wie funktioniert Template?
Der weitere Enum \verb+Template+ dient, in dem Prozessschritt der Synthese den Parsebaum in Java-Code umzuwandeln.
In diesem Enum sind Java-Quellcode Ausschnitte hinterlegt die PL/I-Quellcode repräsentieren können. Sie werden in dem Mapper Modul verwendet
um nach und nach den Java-Zielcode zu erzeugen.

Um den Parsebaum zu erzeugen muss der Parsebaum Stück für Stück überprüft werden. Dieser Prozess wird als semantische Analyse bezeichnet und erfolgt im Checker Modul.
 
\subsubsection{Checker}
Das Checker-Modul prüft den PL/I-Quellcode auf seine Korrektheit. 
Dieses Modul ist repräsentativ für die Semantische-Analyse. 
Eine Aufgabe des Checker-Moduls ist es die Typ-Definition von Variablen mit den Zuweisungen abzugleichen.
Wird beispielsweise dem Decimal-Typ ein Alphanumerischer Wert zugewiesen, soll dieses Modul den Benutzer auf einen Syntaxfehler hinweisen.
Der Ausdruck in Listing \ref{lst:depthin} wird fälschlicherweise von dem Parser verarbeitet.

\begin{lstlisting}[language=PL/I, caption=Deklaration einer Varibale des Typs Decimal, label={lst:decimal}]
DCL var_1 DECIMAL(5);

var_1 = 'Hello';
\end{lstlisting}

Um solche Semantischen Fehler zu erkennen, wird das Checker-Modul nach dem Vorbild des Composite Design-Patterns implementiert.

In Abbildung \ref{fig:checker} ist das \ac{uml} des Checker Modul abgebildet.

\dhgefigure[h]{checker-module-uml.png}[scale=0.4]{Checker Modul}{fig:checker}
\pagebreak

Entsprechend des Composite Design-Patterns, wird der Component \verb+ITypeExpression+, das Composite \verb+VarChecker+ und mehrere leafs wie etwa die \verb+DecimalChecker+ Klasse, definiert.
Bei den Leafs wurde sich nach den PL/I-Datentypen orientiert, die überprüft werden sollen.
Dabei hilft das Composite-Design Pattern für alle Typ-Klassen, einheitliche Validierungstrukturen zu definieren.
Etwa in Abbildung \ref{fig:checker} die Methode \verb+getType+ um die korrekte Zuweisung von Variablen zu erschließen. 
Weiterhin kann mit dem Design-Pattern die Speicherstruktur, die einer Überprüfung unterzogen wird, in der Composite-Klasse dargestellt werden.
Eine mögliche Erweiterung um weiter Speicherstruktur-Elemente wie einem Array ist somit denkbar.

In dem Checker-Modul wird zum ersten Mal auf den Parsebaum, das Ergebnis des Parser Moduls, zugegriffen.
Um auf alle Knoten des Parsebaums zuzugreifen, wird eine Methode definiert die zum iterieren des Parsebaums benötigt wird.
Diese Methode ist auch für weitere Module brauchbar, weil auch diese durch den Parsebaum iterieren sollen.
Dazu wurde in der \verb+DecimalChecker+ Klasse die Methode \verb+iterateTree+ implementiert.
Um den Parsebaum erfolgreich zu iterieren wurde der Depth-in-first Suchalgorhitmus rekursiv in dieser Methode implementiert.
Die Iterationsweise des Algorhitmus im Zusammenhang mit dem Parsebaum ist in Abbildung \ref{fig:parsetreealgo} dargestellt.

\dhgefigure[h]{parsetree-example-searchalgo.png}[scale=0.5]{Beispielhafte Iteration des Parsebaums}{fig:parsetreealgo}[][]
\pagebreak

So wird es möglich gezielt nach Knoten zu suchen und die Attribute des Knotens auszulesen.
In dem Checker Modul wird dieser Algorithmus vor allem benutzt um festzustellen welche Variablen, mit welchem Typ und welchen Bezeichner deklariert wurde und ob dieser Bezeichner in einem \verb+ASSIGN+ Knoten wiederverwendet wurde.

So kann der Parsebaum mit seinen Attributen vollständig iteriert und überprüft werden.
Die Überprüfung ist dann abgeschlossen, wenn die Iteration des Suchalgorithmus wieder bei dem Ausgangspunkt angekommen ist. In Abbildung \ref{fig:parsetreealgo} ist das der Knoten \verb+PRORGRAM+.

Wurde kein Fehler entdeckt beginnt die Transformation des Parsebaums in Java. Falls jedoch ein Fehler entdeckt wurde, wird eine entsprechende Fehlermeldung angezeigt.
Mehr bezüglich Fehlermeldungen und allgemeine Fehlerbehandlung in dem Kapitel ?.?.

Das Checker Modul bereitet den Parsebaum entsprechend so vor, dass dieser weiterhin in der Synthese verarbeitet werden kann.
 
\subsubsection{Mapper}
Das Mapper Modul transformiert die Zwischencode Repräsentation in den Java-Zielcode. Dazu wurde das Mapper-Modul nach dem Strategy Desgin-Pattern entworfen.
In Abbildung \ref{fig:mapper} ist das UML des Mapper Moduls zu sehen. 

\dhgefigure[h]{{mapper-module-uml.png}[scale=0.4]{Mapper Modul}{fig:mapper}
\pagebreak

Die Klasse \verb+Mapper+ wird in der Main-Methode des Projektes instanziiert. Als Parameter wird der Wurzelknoten des Parssebaums übergegeben.
Woraufhin mithilfe der \verb+iterateParsetree+ Methode erneut durch den Parsbaum iteriert wird. Hier wurde ebenfalls der Depth-in-first Suchalgorhitmus implementiert um jeden Knoten zu verarbeiten. Jeder Knoten wird über eine Konstante die eine zugehörige Identifizierungsnummer überprüft. Die in dem interface \verb+Pl1ParserTreeConstants+ des Parser Moduls definiert sind. 
In der Klasse \verb+AstMapper+ finden sich jegliche Identifikations-variablen der Knoten. Hier werden diese mit den zugehörigen Mapper-Klasse in einer HashMap gespeichert.
Die Mapper Klassen stellen die unterschiedlichen Vorgehensweisen in dem Strategy-Pattern dar. Sie implementieren alle das \verb+ITranslationBehavior+ interface und aufgrund dessen eine \verb+translate+ Methode die den übersetzten Ausdruck zurückgibt. 

In der \verb+iterateParseTree+ Methode wird für jeden Knoten, überprüft ob eine solche Mapper-Klasse in der HashMap instanziiert wurde.
Falls eine Klasse vorhanden ist, wird in der TranslationBehavior Klasse das entsprechende Strategie-Objekt des Typs \verb+ITranslationBehavior+ in der
Mapper Klasse gesetzt. So wird die Translate-Methode der aktuell gesetzten Klasse aufgerufen und der Parsebaum-Knote in Java übersetzt.

% wie funktioniert der PicturemMapper
Eine exemplarische Mapper Klasse ist etwa die \verb+PictureMapper+ Klasse.
Die Klasse \verb+PictureMapper+ enthält Zeichenkettenbeschränkungen des PL/I-Picture Typs und deren Übersetzung als Regulären Ausdruck.
Da die Zeichenkettenbeschränkung aus PL/I nicht in dem Java Zielcode angewendet werden kann, werden die Beschränkungen des Picture-Typs entsprechend in Reguläre Ausdrücke übersetzt.
Mit der \verb+getRegex+ Methode der \verb+PictureMapper+ Klasse wird der übersetzte Reguläre Ausdruck als String zurückgegeben.
Der PL/I-Ausdruck \verb+(4)A+ wird etwa zu dem Regulären Ausdruck \verb+(A-Za-z ){4}+.   
Neben der PictureMapper Klassen, erzeugen weitere Mapper Klassen Stück für Stück den Java-Zielcode. 
Jegliche Ausdrücke werden am Ende in einer Arraylist mit dem Namen \verb+javaExpression+ der Mapper Eltern-Klasse  gespeichert.
Wenn über jeden Knoten des Parse-Baums iteriert wurde, ist das Programm vollständig übersetzt.
Während der Synthese und semantischen Analyse des PL/I-Quellcodes kann es zu Fehlern kommen.
Zu den Fehlermeldungen soll im folgenden Kapitel das Modul Errorhandling vorgestellt werden.
Dieses dient hauptsächlich der Fehlerbehandlung und -information für den Anwender.

\subsubsection{Error-Handling}

\subsection{Testing und Integration}
%1. transpiler wird getestet
%1.1 testen der methoden von Lexer, Parser usw. (Bsp.: Kann dieses Zeichen verarbeitet werden?)
%1.2 baum testen auf Korrektheit

%2. transpilieren wird getestet
%2.1 output des transpilierten Pl/1 Codes im Verhältnis zum Pl/1 Code testen.

%3. der transpilierte Code wird getestet
%- wie wird pl/1 Code Native getestet
%- funktioniert der Java Code richtig

%4. performance test (erst am ende)

\subsection{Fehlerbehandlung}
um dem Benutzer die Bediengung während der Laufzeit zu erleichtern, wurden Selbstgewählte Fehlermeldungen implementiert. Diese Fehlermeldungen sollen den Benutzer der Software in eine Feedback schleife bringe welche klare Anweisung zur Bediengung gibt. In der usprünglichen Version des Transpilers wurde dem Benutzer lediglich die von Java geworfenen Fehler in der Konsole ausgegeben. Die Fehlermeldung"IndexOutOfBounds", ließ dabei nicht darauf schließe das der Transpiler die PL/I Datei zum lesen nicht findet. Eine solche Fehlermeldung führt erneut dazu, dass der Benutzer sich selbst um die Lösung des Problems kümmern musste und somit einer weiteren Hürde begenete.
eben für dan fall das die Datei nicht gelesen werden kann, wurde eine Exception geschrieben. Die Exception "PliFileNotFound", beschreibt dem Benutzer die Ursache des Problems und nennt auch ein etwaaigen Lösungsvorschlag. Es exstieren in der neusten Version einige Exceptions die in der folgenden Tabelle näher Beschrieben werden.

...tabelle mit exceptions...

fehlerbehandlung spielt besonder im Zusammenhang mit der Lexikalischen Analyse eine Rolle. Um zu gewährleisten das die Transformation korrekt albläuft braucht es der formalen PL/I Grammatik enstrpechend richtigen PL/I Code als Eingabe. Eine nicht behandlung hätte zur Folge das das Programm entweder eine Fehlerhafte Ausgabe produziert, oder Fehlschlägt. Dies soll vermieden werden.

\section{Technische Spezifikation}
\subsection{Ausführung des Transpilers}

% Importieren in Eclipse
Um den Transpiler zu benutzen gibt es drei Möglichkeiten.
Einerseits über die \ac{ide} Eclipse, über die Kommandozeile und über das Webinterface.
Bei der Benutzung des Transpilers werden erstmals Übersetzungsentscheidungen sichtbar.
In diesem Kapitel sollen alle Möglichkeiten und Spezifikationen des Transpilers näher beschrieben werden.

\paragraph{Eclipse}
Wie schon erwähnt kann die \ac{ide} Eclipse dazu verwendet werden den Transpiler zu benutzen. 
Interessant ist diese Herangehensweise für Administratoren, die den Quellcode selbst erweitern möchten. Hierfür wird neben Eclipse auch Git benötigt.

Zuerst sollte das Projekt aus der GitHub-Repository mit Git in das lokale Verzeichnis geladen werden.

\begin{lstlisting}[language=PL/I, caption=Deklaration einer Varibale des Typs Decimal, label={lst:decimal}]
git clone https://github.com/lhahner/pl1-code-transpiler.git
\end{lstlisting}

Daraufhin ist das importieren des Maven Projekts in Eclipse möglich.
Unter der Registerkarte Datei gibt es die Möglichkeit ein Maven-Projekt in Eclipse zu importieren.
Es erscheint das Men\"ufenster aus Abbildung \ref{fig:importproject}.

\dhgefigure[h]{import-maven-project.png}[scale=0.5]{Importieren eines Maven Projekts}{fig:importproject}
\pagebreak

Hier sollte im n\"achsten Men\"u Fenster der Ordner ausgew\"ahlt werden, in dem die pom.xml liegt.
Ist der Ordner korrekt ausgewählt wird das Projekt in Eclipse importiert.
Nun kann das Projekt benutzt werden. Das Verzeichnis \verb+src/main/java/res/pli+
ist das Standard Eingabe-Verzeichnis. Hier kann eine PL/I-Datei abgelegt werden die übersetzt werden soll. 
Andererseits ist es auch möglich das Standard Eingabeverzeichnis zu verändern. In dem Ordner \verb+src/main/java/res/config+¸ befindet sich die Konfigurationsdatei \verb+config.propreties+.
In dieser kann die Variable \verb+PATH+ geändert werden, um so auch von einer anderen Projektstruktur PL/I-Quellcode zu transformieren.

\paragraph{Internet Schnittstelle}
%...

\subsubsection{Umwandlung von Datentypen}
Es wurden in Projektarbeit-IV selbstgeschriebene nicht-Primitive Datentypen verwendet um die PL/I Datentypen, 
in entsprechenden Java-Zielcode zu übersetzen. Dies ist wie für den Umfang von Deklarationen ausreichend.

Wird jedoch der Transpiler erweitert und eine Abfrage der eigentlichen
Numerischen Werte notwendig um Werte miteinander zu vergleichen, oder
Werte miteinander zu verrechnen, reicht diese Implementation nicht mehr aus.

Es bedarf einer Erweiterung oder Neu-Gestaltung der Nicht-Primitiven Datentypen.
Eine mögliche Erweiterung der bestehenden Transformation des \verb+DECIMAL+ Typs, ist die Implementation einer Methode die den Numerischen Inhalt des Objektes zurückgibt.

Um dies zu erreichen wurde  den bisher verwendeten Typ BigDecimal eine Klasse gebaut
mit der initialisieren bzw. Zuweisung und Ausgabe des Inhalts möglich werden.

In Listing \ref{lst:decimalclass} ist die DECIMAL Klasse zu sehen.

\begin{lstlisting}[language=Java, caption=Die DECIMAL Klasse, label={lst:decimalclass}]
import java.math.BigDecimal;

public class DECIMAL {
	
	BigDecimal content;
		
		public DECIMAL() {
		
	}
	public DECIMAL(int integer, int factorial) {
		String length = Integer.valueOf(factorial) == null ? integer + \"\" : integer + \".\" + factorial;
		this.content = new BigDecimal(length);
		
	}
	
	public DECIMAL(int integer) {
		String length = integer + \"\";
		this.content = new BigDecimal(length);
	}

	public DECIMAL init(int value) {
		this.content.valueOf((double)value);	
		return this;
	}

	private double toNumeric() {
		return this.content.doubleValue();
	}
}
\end{lstlisting}

In Ziele ?-? ist die Methode \verb+toNumeric()+ zu sehen. Diese Methode 
gibt den Inhalt eines DECIMAL Objekts als Double zurück. Dadurch ist eine Referenzierung im Quellcode möglich
und ebenso eine Boolesche und eine Arithmetische Operation.
Hingegen würde für jede zusätzliche Funktionalität eine Methode erstellt, die die Funktionalität 
...

% TODO Spring-Annotaion Lösung hier...
...

\subsubsection{Programmstruktur und Programmablauf}
\paragraph{Umwandlung von Programmstrukturen }\label{programstruct}

Mit dieser Version des Transpilers ist es möglich Prozeduren umzuwandeln.
In PL/I werden Unterprogramm-Routinen in Block-Strukturen definiert. Eine mögliche Block Struktur ist die Prozedur. \footcite[Vgl. ][S. 97ff. ]{pliref}
Eine Prozedur wird durch den Bezeichner, das PL/I-Symbol \verb+PROCEDURE+ und einer Terminierung wie \verb+END+ beschrieben.
Zusätzlich können Parameter, Rückgabetypen und allgemeine Attribut Optionen definiert werden.

In Listing \ref{lst:procchar} ist eine beispielhafte Prozedur gelistet.

\begin{lstlisting}[language=PL/I, caption=Deklaration einer Prozedur des Typs Char, label={lst:procchar}]
empty_proc: PROC(para_1, para_2) RETURNS(CHAR(5)) OPTION(INLINE);
	...
END empty_proc;
\end{lstlisting}

Die Prozedur \verb+empty_proc+ hat zwei Parameter und gibt einen Wert des Typs \verb+CHAR+ der L\"ange 5 zur\"uck.
Weiterhin wird die Option \verb+INLINE+ definiert.

Um in Java Unterprogramm-Routinen zu definieren gibt es Methoden. 
Entsprechend sind Methoden ein mögliches äquivalent der Prozeduren. \footcite[Vgl. ][]{oracle}
Eine Methode hat ähnliche Bestandteile wie eine Prozedur.
Es wird ein Modifier, Rückgabetyp, Bezeichner und eine Parameterliste benötigt.
Einige dieser Attribute sind auch in einer Prozedur definiert.
Jedoch gibt es Unterschiede, die zu einer nicht eindeutigen Übersetzung führen können.

Wird etwa versucht die in der PL/I-Prozedur definierten Parameter direkt zu übersetzen, fehlt die explizite Angabe des Typs im Parameter.

Dieser wird in PL/I implizit durch die Zuweisung definiert, etwa wie in Listing \ref{lst:procassign} dargestellt

\begin{lstlisting}[language=PL/I, caption=Zuweisung von Variablen in einer Prozedur, label={lst:procassign}]
empty_proc: PROC(para_1, para_2) RETURNS(CHAR(5)) OPTION(INLINE);
	para_1 = 'foo';
	para_2 = 'baa';
END empty_proc;
\end{lstlisting}

Implizit wird hier der Typ \verb+CHAR+ zugewiesen. 
In Java muss hingegen explizit der Typ des Parameter definiert werden.
Eine Möglichkeit die Parameterliste zu transformieren, ist über den Typ \veb+Object+.
Da Object die Elternklasse aller Klassen ist, kann während der Zuweisung des Parameters beliebig in den gewünschten Typ umgewandelt werden. \footcite[Vgl. ][]{objectdocs}

In Listing \ref{lst:metassign} ist die Prozedur aus Listing \ref{lst:procassign} als Methode dargestellt.

\begin{lstlisting}[language=Java, caption=\"Ubersetzung der Prozedur, label={lst:metassign}]
public CHAR empty_proc(Object, para_1, Object para_2){
	para_1 = "foo";
	para_2 = "baa";
	return new CHAR(5);
}
\end{lstlisting} 

Weiterhin wird in der Prozedur aus Listing \ref{lst:procassign} ein R\"uckgabewert des Typs \verb+CHAR+ der L\"ange f\"unf definiert.
Aktuell wird \"uber eine Objektinstantiierung des Typs \verb+CHAR+ im Return Ausdruck die L\"ange definiert.
Dadurch kann die L\"angen Beschr\"ankung und die implizierte Typ-Zuweisung des Parameters erfolgen.

Ein weiteres Attribut das in der Prozedur in Listing \ref{lst:procassign} definiert ist, ist das \verb+OPTIONS+
Attribut.
In PL/I werden hier Compiler Optionen definiert. So wird wie in Listing \ref{lst:procassign}, die Option \verb+INLINE+ verwendet um den Kontext einer Prozedur zu beschreiben. \footcite[Vgl. ][]{optionsstmt}

In der Version des Transpilers wird die Übersetzung dieses Ausdrucks nicht weiter berücksichtigt.
Es ist auch fraglich ob eine solche Option in Java emuliert werden kann, da so das verhalten der \ac{jvm} beeinflusst werden müsste.

Neben Prozeduren die in einem Programm direkt nachdem Package definiert werden,
gibt es auch die Möglichkeit in PL/I Subroutinen einzubinden, bei denen 
eine Prozedur etwa weitere Prozeduren beinhaltet.

%TODO ...Übersetzung von Subroutinen

\paragraph{Umwandlung des Programmablaufs}

In PL/I werden Prozeduren unter anderem mithilfe des \verb+CALL+ Statements aufgerufen. \footcite[Vgl. ][S.133ff. ]{pliref}
Wie schon in dem vorangegangen Kapitel \ref{programstruct} beschrieben, werden Prozeduren in Java als
Methode übersetzt.
Um einen Programmfluss, wie er auch in einem nativen Java-Programm, vorhanden ist zu erzeugen wird der Call-Ausdruck in einen Methoden-Aufruf transformiert.

Wird also das Programm aus Listing \ref{lst:callsproc} dem Transpiler übergeben.

\begin{lstlisting}[language=PL/I, caption=\"Ubersetzung der Prozedur, label={lst:callsproc}]

	main_proc: PROC;
		CALL proc_1;
	END main_proc;

	proc_1: PROC;
		CALL proc_1;
	END proc_1;

	proc_2: PROC;
		CALL proc_2;
	END proc_2;

\end{lstlisting} 

Übersetzt in Java ergibt das aus Listing \ref{lst:callsproc} 
das Programm in Listing \ref{lst:javacallsproc}

\begin{lstlisting}[language=Java, caption=\"Ubersetzung des Call-Statments, label={lst:javacallsproc}]
	public void main_proc (){
		proc_1();
	}

	public void proc_1 (){
		proc_2();
	}
	public void proc_2 (){
		proc_1();
	}
\end{lstlisting} 

Die gleiche Endlosschleife aus PL/I wird somit auch in Java erzeugt.
Dadurch kann ein einfacher Programmablauf von einem PL/I-Programm in ein Java-Programm transformiert werden.

\subsubsection{Verzweigungen und Schleifen}
\paragraph{Umwandlung von Verzweigungen}

In PL/I werden Verzweigungen mit den Symbolen \verb+IF+ und \verb+ELSE+ implementiert. 
Gepaart mit einem Booleschen Ausdruck kann so ein Wahrheitswert abgefragt werden.
Dabei gibt es Boolesch Operatoren die in Java mit einem anderen Zeichen dargestellt werden.
Während in Java ein einfaches Ausrufezeichen eine Negation beschreibt, wird in PL/I das logische Negationszeichen (¬) verwendet.

Dieses ist nicht UTF-8 Codiert und wird in Java nicht verwendet. Bei der Transformation wird dieses Zeichen in ein Ausrufezeichen übersetzt.

Weiterhin wird in PL/I ein einzelnes Gleichheitszeichen als logischer Vergleichsoperator verwendet. Da in Java das Gleichheitszeichen der Zuweisungsoperator ist, sollte der PL/I-Vergleichsoperator mit den Java-Vergleichsoperator ersetzt werden.

Gleiches gilt für das logische-Und. In PL/I wird lediglich ein Et-Zeichen verwendet. Während in Java zwei als logisches-Und verwendet werden.

Werden diese Zeichen korrekt übersetzt, können Boolesche Ausdrücke in Java überführt werden.
Somit lässt sich der Ausdruck in Listing \ref{lst:label} in PL/I übersetzen.

\begin{lstlisting}[language=PL/I, caption=\"PL/I if-statements, label={lst:javacallsproc}]
IF (x < y ) THEN;
	DISPLAY('smaller');
ELSE
	DISPLAY('Not smaller');
END;
\end{lstlisting} 

Bei der Transformation des Verzweigungskörpers erfolgt die Orientierung an dem \verb+THEN+ und \verb+END+.
So entsteht der Java Ausdruck in Listing \ref{lst:javaifstatement}.

\begin{lstlisting}[language=Java, caption=\"Java if-statements, label={lst:javaifstatement}]
if (var_1.toNumeric () < var_2.toNumeric()) {
	System.out.println ("smaller");
}
else {
	System.out.println ("Not smaller");
}
\end{lstlisting} 

Eine Else-if Verzweigung existiert in PL/I der Form eines verschachtelten If-Else Ausdrucks wie es in Listing \ref{lst:javaelseifstatement} dargestellt ist.

\begin{lstlisting}[language=PL/I, caption=\"PL/I IF-Else Statement, label={lst:javaelseifstatement}]
IF (x < y ) THEN;
	DISPLAY('smaller');
ELSE
	IF (x = y) THEN;
		DISPLAY('Not smaller');
	END;
END;
\end{lstlisting} 
 
 Entsprechend wird in Java auch nur ein verschachtelter If-Else Ausdruck, wie Listing \ref{lst:javaelseifstatement} dargestellt übersetzt.
 
 \begin{lstlisting}[language=Java, caption=\"Java If´-Else Statement, label={lst:javaelseifstatement}]
 if (var_1.toNumeric() < var_2.toNumeric()){
 	System.out.println ("smaller");
 } else {
 	if(var_1.toNumeric() == var_2.toNumeric()){
 		System.out.println("Not smaller");
 	}
 }
 \end{lstlisting} 

In Zukunft ist hier denkbar einen if-else Ausdruck als Übersetzung in Java zu erwägen.
Aktuell ändert dieser Umstand jedoch nichts an der bestehenden Programmlogik des PL/I Programms. %TODO Wirklihc?

\paragraph{Umwandlung von Schleifen}
In PL/I wird in der aktuellen Version des Transpilers, die  While- und Until-Schleife übersetzt.
Da Java ebenfalls eine While-Schleife implementiert, kann diese als Übersetzungsmuster verwendet werden.

\begin{lstlisting}[language=PL/I, caption=\"PL/I IF-Else Statement, label={lst:whilecomamnd}]
DO 
	WHILE(var_1 < var_2);
		DISPLAY('smaller');
END;
\end{lstlisting} 

Listing \ref{lst:whilecomamnd} zeigt eine einfache While-Schleife in PL/I.
Dabei wird in PL/I das Symbol \verb+DO+ nicht wie in Java für eine Do-While
Schleife verwendet, sondern leitet lediglich einen Schleifen-Ausdruck ein.

Die Übersetzung der Schleife folgt in Listing \ref{lst:javawhilecommand}.

\begin{lstlisting}[language=Java, caption=\"Java If´-Else Statement, label={lst:javaelseifstatement}]
while(var_1.toNumeric() < var_2.toNumeric()){
	System.out.println("smaller");
}
\end{lstlisting} 

Wird nun in PL/I eine \verb+UNTIL+ Beschränkung definiert, wie etwa in Listing
\ref{lst:untilwhile}.

\begin{lstlisting}[language=PL/I, caption=\"PL/I IF-Else Statement, label={lst:untilwhile}]
DO 
	WHILE(var_1 < var_2) UNTIL(var_1 = var_2);
		DISPLAY('smaller');
END;
\end{lstlisting} 

Muss in Java eine äquivalente Abbruchbedingung erzeugt werden.
In der aktuellen Version des Transpilers wurde sich für das Einfügen einer If-Verzweigung entschieden, die bei Eintritt die Schleife mit einem \verb+break+ beendet. Diese Lösung folgt in Listing \ref{lst:javauntilwhile}.

\begin{lstlisting}[language=Java, caption=\"Java Until Statement, label={lst:javauntilwhile}]
while (var_1.toNumeric() < var_2.toNumeric())){
	if (var_1.toNumeric () == var_2.toNumeric()){
		break; 
	}
	System.out.println ("smaller");
}

\end{lstlisting} 

Wobei zu erwähnen ist das hier Java Bad-Practices angewendet werden. Ein \verb+break+ in einer While-Schleife macht in den meisten Fällen den Quellcode schwerer Lesbar, je nach Komplexität der Codestruktur.
In diesem Zusammenhang ist die Verwendung des \verb+break+ Befehls weniger komplex. 

Da in Java kein Muster existiert, welches das äquivalent zu dem \verb+UNTIL+ bietet, ist die Definition einer zusätzlichen Verzweigung mit einer Abbruchbedingung die bisher einzige Lösung.

Weiterhin ist auch die Position der Verzweigung fraglich. Genauso kann die Abbruchbedingung im Fuß der Schleife definiert werden. Dieser Umstand führt zu einer weiteren Iteration des Schleifenkörpers. 

Da in PL/I die Bedingung jedoch am Schleifen-Kopf definiert wird, wurde in Java eine Prüfung des Abbruchbedingung ebenfalls im Kopf implementiert. 


\subsubsection{Ein- und Ausgabe Operationen}
\paragraph{Konsolen Ein- und Ausgabe}
Um auch eine Benutzerinteraktion zu ermöglichen wird ebenfalls der Display-Ausdruck transformiert.
In PL/I gibt es sowohl die Möglichkeit mit dem Display-Ausdruck eine Text-Nachricht in der Konsole auszugeben, sowie eine Benutzereingabe abzufragen. \footcite[Vgl. ][S. 264ff.]{pliref}

In Java gibt es verschiedene Implementierungen einer Umleitung des Ausgabe in die Konsole.
Die gängige Methode ist die Verwendung des Ausdrucks \verb+System.out.println()+. 
Alternativ könnte auch die Methode \verb+log.trace+ verwendet werden.
Jedoch wird hier eine Abhängigkeit zu der Software-Bibliothek \verb+logger+  erzeugt, weshalb sich gegen diese Methode entschieden wurde.
Eine weitere Alternative würde der \verb+PrintWriter+ bieten, hierbei müsste jedoch zuerst das Objekt \verb+PrintWriter+ erzeugt werden, was zusätzlichen Quellcode erzeugen würde. Diese könnte mit Implementierung des Sysout-Befehls vermieden werden.
Somit wurde die gängige Methode gewählt und der Ausdruck \verb+System.println.out+ gewählt.

Entsprechend wird der Ausdruck in Listing \ref{lst:display}

\begin{lstlisting}[language=PL/I, caption=\"Display-Statments, label={lst:diplay}]
DISPLAY('Hello World');
\end{lstlisting} 

Zu Listing \ref{lst:sysout}

\begin{lstlisting}[language=Java, caption=\"Ubersetzung des Display-Statments, label={lst:sysout}]
System.out.println("Hello World");
\end{lstlisting} 

Um eine Eingabe des Benutzers zu verwenden wird das Symbol \verb+REPLY+ verwendet.

\begin{lstlisting}[language=PL/I, caption=\"Display-Statments, label={lst:diplay}]
DISPLAY('Username') REPLY(var_1)
\end{lstlisting} 

In dem Beispiel in Listing \ref{lst:diplay} wird die Benutzereingabe in der
Variable \verb+var_1+ gespeichert.
In PL/I kann die Benutzereingabe nur in einen Bit, Widechar, oder Char gespeichert
werden. 
In Java gibt es verschiedene Lösungen um die Benutzereingabe Abzufragen.
Einerseits über das Scanner oder BufferedReader Objekt.
Jedoch würden beide Lösungen eine Instanziierung der zugehörigen Objekte benötigen und ebenfalls mehr Zeilen Quellcode inanspruchnehmen als nötig.

Stattdessen wird das System Objekt verwendet, welches auch bei der \verb+System.out.println+ verwendet wurde.
Mit \verb+System.console.readLine()+ wird die Benutzereingabe gelesen.
Listing \ref{javadisplay} zeigt die Übersetzung des PL/I Ausdrucks aus Listing \ref{lst:diplay}.

\begin{lstlisting}[language=Java, caption=\"Java übersetzung des Display-Statments, label={lst:javadisplay}]
username.init(System.console().readLine()); 
\end{lstlisting} 

Gepaart mit dem Programmfluss, Verzweigungen und schleifen ist die Transformation von einfachen PL/I-Programm denkbar.
Etwa kann ein einfaches Login-Programm mit den transformierten PL/I-Strukturen übersetzt werden. 

\paragraph{Datei Ein- und Ausgabe}

\subsection{Optimierung}
% online-Smoketest von PL/I Code -> %todo: Verschieben nach Erweiterbarkeit (Schlusskapitel), weil momentan noch nicht vollstaendige Grammatik realisiert.

\subsubsection{Performance und Benchmarks}
\subsubsection{Testing}
\section{Fazit}