%--> Je Subsection Punkt Fragen formulieren.

%-------------------------------------------
% HEADER

% Roterfade der Einleitung:

% 1. Problem -> Kompatibilität
% 2. Ziel -> Lösung mit Übersetzungsprogramm
% 3. Abgrenzung Interpreter & Compiler -> Übersetzungsprogramm als Transpiler
% 4. Formale Grammatike -> Formale Grammatik als Vorrausetzung des Transpilers
% 5. JavaCC -> Implementierung der Formalen Grammtik mit JavaCC und damit des Transpilers

%-------------------------------------------

\section{Theoretische Grundlagen}
\subsection{Problemstellung}
	
Es gibt zwei Probleme die eine PL/I zu Java Übersetzung lösen soll. 
Einerseits ein Portabilitätsproblem von PL/I-Programmen, die auf modernen Plattformen laufen sollen, wie etwa Cloud-Instanzen oder Linux-Server, andererseits die mit hohen Aufwand verbundene Wartung von bestehenden PL/I-Programmen. 
	
Die bestehende Auswahl von PL/I Compilern führen zu einem Portabilitätsproblem. Der PL/I Compiler, der auf den meisten Computer-Systemen im Einsatz ist, wird von IBM entwickelt und vermarktet. Hierbei handelt es sich um einen Compiler für das von IBM entwickelte Betriebssystem z/OS geschrieben wurde. Eine Kompilierung von PL/I auf einem herkömmlichen x86-Desktop Computer oder ähnlichen ist mit diesem Compiler nicht möglich. \footcite[Vgl. ][]{plicomp}


Eine mögliche Alternative bietet die Organisation GNU mit der \ac{GCC}. Der Softwareentwickler Henrick Sorensen entwickelte Teile des Frontends für einen PL/I Compiler. Dabei verwendete er das Backend, dass die \ac{GCC} zu Verfügung stellt. Jedoch gab es bei diesem Projekt seit 2007 keine weiteren Neuerungen mehr. Der Entwickler gibt an, das bisher keine Zwischencode Erzeugung stattfindet, was diesen Compiler bisher unbrauchbar macht. \footcite[Vgl. ][]{pligcc} 
Heutzutage ist eine gängige Möglichkeit, ein IBM 3270 Terminal zu emulieren, das eine Verbindung zu einem z/OS System herstellt, um den PL/I Code auf diesem zu kompilieren.


Neben technischen Problemen, existieren auch Personalprobleme. PL/I ist eine Altsprache, die seit den 1960er Jahren im Einsatz ist und durch den Generationenwechsel an Entwicklern verliert. Wartung und Entwicklung werden so häufig teuer.\footcite[Vgl. ][S. 227ff.]{histopli} 

Java hingegen ist auf nahezu allen modernen Systemen durch die plattformunabhängige Java Virtual Machine (JVM) kompilierbar. \footcite[Vgl. ][]{jvm}
Insbesondere ist eine Kompilierung auch auf einem IBM-Großrechner mit z/OS möglich. \footcite[Vgl. ][]{zos} 
Das macht Java zu einer flexibel einsetzbaren Sprache. 

Weiterhin ist Java heute eine beliebte Programmiersprache. \footcite[Vgl. ][]{tiobe} Das führt zu einer höheren Anzahl an Entwickler, die in der Lage sind Java Programme zu warten.

% Was ist ein Transpiler?
Um die Programmiersprache Java zur Lösung der eingangs beschriebenen Probleme zu verwenden, wird ein Transpiler benötigt, der PL/I-Quellcode in Java-Zielcode übersetzt. Dabei hat der Benutzer die Möglichkeit, selbst zu bestimmen, wie bestimmte Ausdrücke übersetzt werden sollen. Sobald der Programmcode in Java übersetzt ist, kann der Java-Zielcode von dem Java-Compiler kompiliert werden und auf der \ac{jvm} ausgeführt werden.

% Weiterführung
Ab diesem Punkt spielen Anforderungen an das Ergebnisses des Transpilers eine Rolle. Faktoren wie Lesbarkeit und Erweiterbarkeit des Java-Zielcodes gehen in die Beurteilung mit ein. 
Die Beurteilung der Ausgabe des Transpiler ist auch von Zielaspekten der Benutzer abhängig. In dieser Arbeit wurden Zielgruppen definiert die im nachfolgenden Kapitel 1.2 weiter erläutert werden sollen. Diese Zielgruppen sind für weitere Gestaltungsentscheidungen in der Entwicklung des Transpilers wichtig.

% @review: Begriffswahl
In den folgenden Kapiteln wird zwischen dem Transpiler, dem Eingabeprogramm (PL/I-Quellcode) und dem Ausgabeprogramm (Java-Zielcode) unterschieden. Diese Begriffe helfen dabei, die verschiedenen Programme eindeutig zu identifizieren.

%Anderseits auch die veränderte Laufzeit-Performance. Die Laufzeit-Performance kann durch eine Übersetzung verschlechtert, wie auch verbessert werden. Somit ist nicht nur die reine Übersetzung Teil der Problemstellung, sondern es gilt auch die Übersetzung zu beurteilen. 

     

% 	 Welches Problem löst das Programm?
%	 Probleme 
%			 1. Nicht auf jedem System läuft PL/I, besonders nicht auf modernen x86 bzw. Cloud.
%			 2. PL/I ist eine weniger verwendete Sprache, Wartung teuer &  Schwer.

%	 (Hinführung zum Problem:
%	 Historisches Kompatibilitätsproblem -> Nicht auf jedem System lief jede Assambler Sprache, Problem: hoher Aufwand und Unflexibel
% 	 Deshalb -> Compiler mit Hochsprache, der Code für das Backend des Compilers, bspw. C's Gcc Compiler
%    in Assambler Sprache des Systems übersetzt.)? **Hier einen Cross Compiler erklären bzw. im Zusammenhang mit dem Historischen Problem.**

%	 Problem mit PL/I -> Pl/I Compiler rar bzw. nur für Großrechner Systeme vorhanden   
%	 Es gibt zwar einen GCC Pl/I Compiler, dieser wird aber seit 2007 nicht mehr weiterentwickelt. Eine Weiterentwiclung könnte auch Interessant %    sein, löst aber nicht das Problem der teuren Wartung von Programmen in PL/I.

% 	 
%	 Lösungsvorschlag zu 1 -> PL/I zu Java Transpiler bauen Java und JVM relativ System unabhängig und damit Ideale Zielsprache für eine 
%	 hohe Kompatibiltätsrate.Um zum Beispiel Pl/I Programm die auf einem Großrechner laufen auch auf einem x86 On-Prem Server oder einer Cloud
%    zu betreiben. **Hier die Frage klären was ein Transpiler ist**
%	 
%    Lösungsvorschlag zu 2 -> Java ist den großteil der Softwareentwickler bekannt und eine Wartung ist leichter.
%
 \pagebreak
\subsection{Zielsetzung}
% Herleitung von der Problemstellung	
Das Ziel dieser Arbeit leitet sich aus der eingeführten Problemstellung in Kapitel 1.1 ab. Allgemein soll ein plattformunabhängiger Transpiler entstehen, der die  Entwicklung und Transformation von PL/I-Quellcode ermöglicht. Die zugrundeliegende Arbeit stellt die Entwicklung, sowie die Gestaltung der Software dar und diskutiert Gestaltungsentscheidungen. 

% @review: Referenz zur Begriffklärung
% Zielgruppen Zusammengefasst	
Diese Arbeit richtet sich an juniore Anwendungsentwickler in den Sprachen PL/I bzw. Java. Für diese Nutzergruppe soll der Transpiler ein Hilfswerkzeug darstellen. Weiterführend werden diese als Benutzer bezeichnet. Eine andere Nutzergruppe sind Administratoren, die den Transpiler selbst anpassen und erweitern möchten. Ermöglicht wird dies durch eine modulare Architektur.
	
% Junior Entwickler die gerade in PL/1 einsteigen.
Juniore Entwickler profitieren von dieser Arbeit als Einstiegspunkt in die Programmiersprache PL/I. Beispielhaft könnten Entwickler den Transpiler als Test-Umgebung für den eigenen entwickelten PL/I-Quellcode verwenden.

% Lernhilfe
Für Benutzer, die mehr Erfahrung mit Java haben, eignet sich der Transpiler als Lernhilfe. Es wird ihnen so erleichtert, PL/I-Quellcode zu analysieren. Sie können bestehende Kenntnisse aus Java anwenden, um Muster in PL/I wiederzuerkennen. Dies kann den Lernprozess beschleunigen.

% Benutzbarkeit
Der Transpiler aus der Projektarbeit-IV konnte bisher über die Kommandozeile, sowie der IDE Eclipse verwendet werden. Diese ursprüngliche Benutzung des Transpilers führte zu einer hohen Fehleranfälligkeit und Dokumentationsbedarf. Die Komplexität der Benutzung wird durch ein Graphical-User-Inferface (GUI) vereinfacht.
%Das Konzept dieser GUI soll dem eines Übersetzers der natürlichen Sprache, wie etwa 'DeepL' oder 'Google-Translate', ähneln. Mit diesen Konzepten sind Benutzer vertraut, erleichtert den Einstieg in die Programmiersprache PL/I, das Testen des PL/I-Quellcode, sowie die schnelle Übersetzung.

%  Entwickler die das Programm eigenständig erweitern, verändern wollen.
Durch die modularisierte Gestaltung des Transpilers können Administratoren selbst Module austauschen und erweitern, etwa durch eine API-Schnittstelle zu externen Übersetzungsbibliotheken. 

%  Zusammenfassung und hinführung zum nächsten zu dem Unterschied Interpreter und Compiler

Der Transpiler soll eine Transformation der grundlegenden Anweisungskategorien implementieren. Die Variablendeklaration sowie -zuweisung, die Ein- und Ausgabesteuerung und allgemeine Kontrollflussanweisungen werden im Zuge der Entwicklung implementiert. Der entstehende Quellcode ist unter Verwendung des mitgelieferten Boilerplate-Codes kompilierbar. Weiterhin wird der PL/I-Quellcode nicht vollständig auf seine Korrektheit überprüft. In der entstandenen Version des Transpilers ist die Mitübersetzung von Fehlern denkbar. Nichtsdestotrotz werden syntaktische Fehler und datentypspezifische semantische Fehler erkannt. Entsprechend wird eine Fehlermeldung ausgegeben und das Programm nicht weiter übersetzt.

Ein Transpiler kann sowohl als Interpreter und als Compiler gestaltet werden. In dem nachfolgenden Kapitel 1.3 werden die Begriffe voneinander abgegrenzt. 
	
% Aufteilung der Zielstellung:
% 1. Allgemein; Ableitung aus der Problemstellung
% 2. Zielgruppen spezfifisch
% 2.1 Einfache und unkomplizierte Lösung
%
% 2.2 Erweiterung des Transpilers bzw. ersetzen von Modulen	
	
% - Wie eine Art JavaScript Minifier oder 
%  Wer ist die Zielgruppe?
%  - Junior Entwickler die gerade in PL/1 einsteigen.
%   - Lernhilfe
%  - Online-Smoketest von PL/I Code
%   - Benutzbarkeit
%   - Entwickler die das Programm eigenständig erweitern, verändern wollen.
 
%  Ziele der Architektur (Zielgruppe Entwickler)
%  - Perspektive des Entwicklers
%  - Perspektive des Benutzers
    \pagebreak

\subsection{Abgrenzung Interpreter und Compiler}
% Wie können Programme ausgeführt werden?
Um das zu entwickelnde Programm von einem Interpreter abzugrenzen, werden in diesem Kapitel die Unterschiede zwischen einem Interpreter und einem Compiler beschrieben. Zusätzlich wird ein Compiler mit einem Transpiler verglichen und Unterschiede dargestellt.
  
% Wie arbeitet ein Compiler?
Ein Compiler besteht aus einem Frontend und einem Backend. Das Frontend umfasst die lexikalische, syntaktische, semantische Analyse und die Symboltabelle.
Das Ergebnis des Frontends ist eine Zwischencodedarstellung, die an das Backend übergeben wird, um daraus Maschinencode zu generieren. Der Maschinencode kann auf dem zugrundeliegenden System ausgeführt werden. \footcite[Vgl. ][S.106ff. ]{aho}
Um weiterhin den Prozess der Übersetzung mithilfe eines Compilers darzustellen, wird Abbildung \ref{fig:compiler} verwendet.

In der ersten Phase teilt der Compiler den eingegebenen String in Tokens auf. Danach entsteht ein Syntaxbaum, der in diesem Beispiel die Zwischencodedarstellung repräsentiert. Ab diesem Punkt beginnt das Backend des Compilers. Zuerst erzeugt das Backend maschinenunabhängigen Code und anschließend maschinenabhängigen Code. Dieser maschinenabhängige Code ist auf dem zugrundeliegenden System ausführbar. \footcite[Vgl. ][S.30 ]{aho}
In jeder Phase wird aus der Symboltabelle gelesen und geschrieben.

%  Warum ein Transpiler?
Es gibt weitere Lösungen die auf einem ähnlichen Konzept basieren.
Ein One-Pass-Compiler etwa erzeugt keinen Zwischencode, sondern führt den Code direkt aus. Diese Methode wurde angewendet, um Speicherplatz zu sparen, da frühe Computer nur begrenzte Kapazitäten hatten und keine Zwischenergebnisse speichern konnten. Ein Beispiel für eine Sprache, die mit einem One-Pass-Compiler kompiliert wird, ist Turbo Pascal. \footcite[Vgl. ][]{onepass}

Eine weitere Ausprägung ist ein Source-to-Source Compiler.
Während ein C-Compiler den C-Code nach der Zwischencodeerzeugung in Assemblersprache und anschließend der Assembler den C-Quellcode in Maschinencode übersetzt, wandelt ein Source-to-Source-Compiler beispielsweise C-Quellcode in Java-Zielcode um. 
Ein Source-to-Source-Compiler wird im Zusammenhang dieser Arbeit als Transpiler bezeichnet und ist deckungsgleich mit dem entwickelten Programm.

Abbildung \ref{fig:compiler} zeigt eine Übersicht und das Ergebnis der einzelnen Compiler-Phasen. Die Abbildung unterteilt den Ablauf wie eingangs beschrieben in Frontend und Backend.

\pagebreak
% @todo: Quelle
\dhgefigure[h]{compiler-ablauf-diagramm.png}[scale=0.75]{Funktionsweise eines Compilers}{fig:compiler}[][]
\pagebreak

Abbildung \ref{fig:transpiler} zeigt die Prozessschritte eines Transpilers.

\pagebreak
\dhgefigure[h]{transpiler-diagramm.png}[scale=0.75]{Funktionsweise eines Transpilers}{fig:transpiler}[][]
\pagebreak

Ein Vergleich von Abbildung \ref{fig:compiler} mit Abbildung \ref{fig:transpiler} zeigt, dass die ersten Phasen bis zur Zwischencodeerzeugung gleich bleiben. In Abbildung \ref{fig:transpiler} sind jedoch die Prozesse des Frontends neben denen des Backends dargestellt. Während in Abbildung \ref{fig:compiler} diese untereinander angeordnet sind. Zurückzuführen ist diese Darstellung auf die verwendeten Sprachebenen.

Ein Compiler übersetzt den Quellcode einer Hochsprache in eine maschinennahe Sprache wie Assembler. Hingegen bleibt der Transpiler, bei der Ein- und Ausgabe, auf der Sprachebene der Quellsprache. In Abbildung \ref{fig:transpiler} werden zudem die Phasen des Backends reduziert, da keine Übersetzung in eine maschinenabhängige Sprache erforderlich ist.

% @review
Ein weiter Unterschied zu einem herkömmlichen Compiler ist die Art der Ausführung des übersetzten Zielcodes.
Das Ergebnis der Übersetzung eines Compilers ist Binärcode der auf einem Zielsystem ausgeführt werden kann. Um hingegen das Ergebnis eines Transpilers auszuführen,
braucht es einen weiteren Compiler. Dieser Compiler muss den Zielcode der Zielsprache in Binärcode übersetzen.
Bei der Übersetzung von PL/I-Quellcode zu Java-Zielcode, bedarf es also einen weiteren Java-Compiler zum ausführen des Zielcodes.

% @review: Cross Compiler? - Hat hier eig nix zu suchen, ist Thema für Boostrapping aber nicht für Transpiler
%Neben den Methoden der Konstruktion, gibt es auch unterschiedliche Verwendungen von Compilern. 
%Etwa existiert der Begriff der Cross-Kompilierung. Hierbei handelt es sich um die Möglichkeit einen Compiler, der sich auf einem externen Computersystem befindet zu verwenden um den Quellcode auf dem lokalen System in Binärcode zu übersetzen. \footcite[Vgl. ][]{guncross}

%Diese Verwendungsweise findet etwa Anwendung beim Bootstrapping. Liegt auf dem System noch kein Compiler für die Sprache vor, in der der Kernel geschrieben wurde, wird diese Methode verwendet um den Kernel-Code zu kompilieren. 
%In dieser Arbeit kommt ein solcher Ansatz bedingt zum Einsatz. Wird der Transpiler in einem Webinterface verwendet, ist die Verhaltensweise ähnlich.
%Da auch hier der Compiler auf einem anderen Host-Computer, den lokalen Quellcode übersetzt.

Zusammenfassend übersetzen sowohl One-Pass-Compiler, Transpiler bzw. Source-to-source Compiler als auch herkömmliche Compiler das Programm basierend auf einer Zwischencodeerzeugung. \footcite[Vgl. ][S. 18ff. ]{assambly}
Eine Alternative ist der Interpreter. Dieser führt den Quellcode direkt Zeile für Zeile aus.

% Wie arbeitet ein Interpreter?
Im Vergleich zu einem Compiler hat der Interpreter weder ein Frontend noch ein Backend. Es gibt keine klare Trennung zwischen einem Frontend, das eine unabhängige Repräsentation des Codes erzeugt, und einem Backend, das diese Repräsentation interpretiert. 

Ein Interpreter wird etwa durch die Shell verwendet um Benutzerbefehle zu verarbeiten. 
In Abbildung \ref{fig:shell} ist der Verarbeitung des Bash Interpreters dargestellt.


\dhgefigure[h]{shell_interpreter.png}[scale=0.75]{Ablauf der Interpretation eines Shell Programms}{fig:shell}[][]
\pagebreak

Die Eingabe des Bash-Skripts wird zeilenweise gelesen.
Das Quoting folgt dem Prinzip der lexikalischen Analyse, bei der alle Sonderzeichen entfernt werden, wie zum Beispiel Kommentare oder Backslashes. Sobald das Quoting abgeschlossen ist, entsteht ein String, der nur aus den Tokens eines Ausdrucks besteht.

Anschließend beginnt das Parsing, das der syntaktischen Analyse im Kompilierprozess ähnelt, jedoch keine Zwischencodeerzeugung beinhaltet. Hier wird lediglich zwischen einfachen Bash-Befehlen wie \verb+wc+ und zusammengesetzten Befehlen wie einem \verb+if+-Ausdruck unterscheiden.

Der Verarbeitungsprozess setzt sich mit der Shell-Expansion fort, bei der in einem Befehl eingebettete relative Ausdrücke durch ihre absoluten Repräsentationen ersetzt werden.
Ab hier nimmt nun das Betriebssystem die Befehle des Shell-Skriptes entgegen und führt das entsprechende Programm aus.
Schließlich wird das Ergebnis in der Standardausgabe ausgegeben. \footcite[Vgl. ][]{gnubash}

% Absatz: Zusammenfassende Unterscheidung zwischen Interpreter und Transpiler, Was sind gemeinsamkeiten und unterschiede von Transpiler und interpreter?

Zusammenfassend zeigen sich sowohl Ähnlichkeiten als auch Unterschiede zwischen einem Interpreter und einem Compiler bzw. Transpiler. Beide durchlaufen die Phasen der lexikalischen und syntaktischen Analyse, wobei sie den Quellcode zunächst um Kommentare, Leerstellen oder andere für die Übersetzung irrelevante Symbole bereinigen. Anschließend erfolgt entweder die direkte Übersetzung des Quellcodes oder die Erzeugung einer unabhängigen Repräsentation.

Um PL/I-Code korrekt in Java zu übersetzen, sind Verbindungen zwischen den Ausdrücken relevant. Diese Verbindungen können in einer Zwischencoderepräsentation des PL/I-Quellcodes, komprimiert dargestellt werden. Eine zeilenweise Übersetzung könnte zu einem Java-Programm führen, das den restlichen Kontext des Programms nicht weiter berücksichtigt.

Um eine Zwischencodeerzeugung zu generieren wird ein Frontend benötigt. Wie schon in den Abbildungen \ref{fig:transpiler} dargestellt sind die ersten Arbeitsschritte des Frontends die lexiklaische und syntaktische Analyse. Für beide Prozessschritte werden ein Parser und Lexer benötigt. Mit einem Compiler-Compiler können automatisiert Programme erzeugt werden die einen PL/I-Quellcode in eine Zwischencodedarstellung transformieren.
Das folgende Kapitel beleuchtet Grammatiken formaler Sprachen wie PL/I und Java genauer um auf die Verwendung eines Compiler-Compilers vorzubereiten.
% Der entscheidende Unterschied liegt darin, dass der Interpreter den Quellcode lediglich zeilenweise direkt übersetzt, während der Compiler das Programm in eine andere Form transformiert und liest. Dabei stehen die verwendeten Ausdrücke des Eingabecodes in Beziehung zueinander, beispielsweise durch die Verschachtelung von Verzweigungen und Schleifen.



% - Erweiterung des Umfangs während der Laufzeit
% - Trennung Laufzeit/Konzeptionsphase

% - Hier erwähnen das eine geminsamkeit die definition von Grammatiken ist, dann überleiten zu Formale Grammatiken.
% - Auch Entscheidung treffen was genau der Transpiler ist, Compiler oder Interpreter
\pagebreak
   
   
\subsection{Formale Sprachen und ihre Grammatiken}
% Formale Sprachen - linearer Ausdruck
Formale Sprachen sind geeignet, Anweisungen an den Computer zu übergeben und gleichzeitig dem Menschen verständlich darzustellen. Dabei erfolgt das Schreiben von formalen Sprachen linear, das Lesen und Schreiben beginnt also von oben nach unten. Um diese lineare Form zu verarbeiten, braucht der Computer eine Regelung, die eine Verarbeitung der einzelnen Ausdrücke zulässt.

Auch wie andere Sprachen besteht eine formale Sprache aus Syntax und Lexemen.
Beide sind abhängig von der Sprache die verwendet wird.
Etwa gibt es in PL/I, das Wort \verb+DECLARE+, während in Java so ein Wort
nicht existiert.

Der Syntax einer formalen Sprache kann durch eine Grammatik beschrieben werden.
Um eine Grammatik für eine formale Sprache zu definieren sind logische präzise Beschreibungen von Ausdrücken notwendig. \footcite[Vgl. ][S. 149ff. ]{automata} Zusammengefasst in:

\begin{center}
	\begin{equation}\label{eqn:grammar}
		G=(V,T,S,P)
	\end{equation}
\end{center}


Hierbei steht \verb+V+ für Variablen bzw. Nicht-Terminalsymbole, \verb+T+ für Terminale, \verb+S+ für Start und \verb+P+ für Produktion. Dabei ist \verb+S+ ein Teil von \verb+V+\footcite[Vgl.][S. 31ff.]{automata}. Die Terminalsymbole sind gleichbedeutend mit Lexemen, und eine Produktion ergibt eine Syntaxregel für die Grammatik. Um eine Grammatik darzustellen, werden Ableitungen von Syntaxregeln verwendet. In der Gleichung 2 bis 6 ist die Syntaxregel einer einfachen \verb+if+ und \verb+else+ Verzweigung dargestellt.

% @todo: PL/I Verwenden und Kontext herstellen
\begin{center}
	\begin{equation}\label{eqn:start}
		S \to \mathbf{if}\: expr\: \mathbf{then}\: stmt\: \mathbf{else}\: stmt\: | \mathbf{if}\: expr\: \mathbf{then}\: stmt;
	\end{equation}
	\begin{equation}
		expr \to expr\: op\: term\: | term
	\end{equation}
	\begin{equation}
		op \to \mathbf{>}\: |\: \mathbf{<}\: |\: \mathbf{=}\: |\: \mathbf{!}
	\end{equation}
	\begin{equation}
		term \to term\: multOp\: factor\:
	\end{equation}
	\begin{equation}
		factor \to \mathbf{id}\: |\: \mathbf{constant}
	\end{equation}
\end{center}

\pagebreak
Mit der beschriebenen Grammatik ist der PL/I-Quellcode in Listing \ref{lst:pliifstatement} zulässig.

\begin{lstlisting}[language=PL/I, caption=PL/I-Verzweigung, label={lst:pliifstatement}]
	IF A > B THEN
		CALL proc_1;
	ELSE
		CALL proc_2;
	END
\end{lstlisting}

Nicht zulässig ist hingegen der Ausdruck in Listing \ref{lst:pliwrongstatement}.

\begin{lstlisting}[language=PL/I, caption=Wrong Statement PL/I, label={lst:pliwrongstatement}]
	CALL IF THEN A > B proc_1;
\end{lstlisting}

Damit der Computer nach einer Syntax-Regel wie in Gleichung 2 bis 6 formale Sprachen, bzw. PL/I, verarbeiten kann, wird ein Parser benötigt. Dabei verarbeitet der Parser den eingegebenen PL/I-Quellcode und überprüft den geschriebenen Ausdruck auf seine Grammatikalisch-Richtigkeit.

Je nach Einschränkung der formalen Sprache kann ein solches Programm sehr komplex sein. Grund dafür sind die unterschiedlichen Kombinationsmöglichkeiten von Ausdrücken, die das Programm berücksichtigen muss.

% Der zu implementierende Parser für PL/I

Mit einem LR-Parser können Syntaxregeln wie die in Gleichung 2 bis 6 dargestellt verarbeitet werden.
Dazu werden Aktionen verwendet um alle  Ausdrücke eines Eingabecodes zu verarbeiten, etwa das schieben zu einem anderen Zustand, dass reduzieren von Syntaxregeln, sowie das akzeptieren des Ausdrucks oder das werfen von Fehlern.
Dabei laufen die Aktionen rekursiv so lange ab, bis keine  weitere Eingabe von Syntax folgt.
Ebenfalls darstellbar in einem Deterministischen-Endlichen-Automaten.

Wird etwa aus der Syntaxregel einer Verzweigung ein Deterministischer-Endlicher-Automat erzeugt, kann
daraufhin eine Syntaxanalysetabelle erzeugt werden, mithilfe
der ein LR-Syntaxanalyseprogramm geschrieben werden kann.
% Hier evlt. Abbildung von DEA

Ein LR-Parser eignet sich für die Verarbeitung von Programmiersprachen, da dieser eine große e von kontextfreien Grammatiken syntaktisch analysieren kann.
Auch wird durch die Verarbeitung von links-nach-rechts eine frühe Fehlererkennung möglich.

Deutlich wird also das ein Computer formale Sprachen verarbeiten kann, wenn ihm präzise beschrieben wird, wie Ausdrücke zu verarbeiten sind. 
Die eigentlich lineare, Lese und Schreibtätigkeit wird damit zu einer rekursiv gesteuerten Verarbeitung durch den Computer.

Einen LR-Parser für PL/I manuell zu implementieren bedarf einen hohen intellektuellen Aufwand. \footcite[Vgl. ][S. 27ff. ]{compibau}
Die verwendeten Algorithmen zur Syntaxanalyse sind häufig komplex, jedoch für jeden Parser verschiedener Programmiersprachen gleich. 
Zusätzlich kann die Grammatik von PL/I Mehrdeutigkeiten aufweisen, welche in den Compiler eingearbeitet werden müssen.
\footcite[Vgl. ][S. 262ff. ]{compibau}

Anstatt den LR-Parser händisch zu implementieren, wurde ein entsprechendes Software-Werkzeug eingesetzt, welches den Parser aus einer kontextfreien Grammatik generiert.
In dem folgenden Kapitel wird der verwendete Parser-Generator, bzw. Compiler-Compiler vorgestellt.

% Hier Grund aus Compilerbau Buch


% TODO Warum 
% Warum braucht ein Compiler eine Grammatik?
% In dem vorangegangen Kapitel wurden unterschiedliche Methoden, Anwendungsgebiete und Formen der Sprachinterpretation eines Computers vorgestellt. Damit die Interpretation von Sprachen korrekt erfolgt, braucht ein Computer Regeln. Grammatiken beinhalten diese Regeln. 

% - Theoretischer Abriss
% - Einordnung der resultate der PA 4
%- PL/1 Syntax Wo zu finden? Welche Version der Sprache? 
%	- Reguläre Ausdrücke Syntax, Beispiel einer Grammatik die ich mit verwende, Typ einer Grammatik
%  - Literatur
%    - Chomsky Hierarchie Bücher
%    - https://www-igm.univ-mlv.fr/~berstel/LivreCodes/Codes.html
%  - Woraus besteht eine Grammatik?
%   - Wie lassen sich Grammatiken der Komplexität nach anordnen?
%  - Chomsky Hierarchie
%  Erst Chomsky Hierachier, dann nach Komplexität einordnen und am Beispiel von Regulären Ausdrücken und PL/I Grammatik einführen.
     
\pagebreak
\subsection{Anwendung von formalen Grammatiken in JavaCC}
% 1. Was ist ein Compiler-Compiler? (Verbindung von formalen Grammatiken zu JavaCC)

In Kapitel 1.4 wurde bereits in die Thematik der formalen Grammatiken eingeführt, in diesem Kapitel wird nun die praktische Implementierung dieser Grammatiken im Zusammenhang mit dem Transpiler beschrieben.
Ein Compiler-Compiler wie JavaCC ist eine Technologie mit der aus einer formalen Beschreibung einer Grammatik ein Lexer und ein Parser erzeugt werden. 

Der Lexer und der Parser wenden die in der Grammatik-Datei definierten Regeln an und verarbeiten in einer Java-Klasse die übergebenen Ausdrücke.
Die Darstellung der Grammatik erfolgt in der Regel in einer Art \ac{ebnf}. 
Beispielhafte Compiler-Compiler sind neben JavaCC, Yacc, Antlr und Lexer.


In Kapitel 1.4 wurde bereits vereinfacht eine Syntaxregel aus der PL/I-Grammatik dargestellt. Ähnlich erfolgt auch die Darstellung in einer Grammatikdatei. Folgendes Beispiel zeigt die Darstellung eines \verb+IF ELSE+ Ausdrucks. 
\footcite[Vgl. ][]{javaccdoku}


\begin{lstlisting}[language=Java, caption=If Statement aus der Grammatikdatei, label={lst:ifstatement}]
	void if_statement() #BRANCH :
	{}
	{
		< IF >bool_expression()
		< THEN >proc_body()
		[else_statement()]
	}
\end{lstlisting}

In JavaCC besteht die Möglichkeit die Beschreibung von Syntaxregeln in Methoden zu Kapseln.
In Zeile 1 ist der Methodenkopf zu sehen. In diesem Fall erzeugt die Methode \verb+if_statement+ keinen Rückgabwert.
Das durch die Raute gekennzeichnete Symbol ist die Repräsentation im Syntaxbaum und zusätzlich auch die Darstellung im Zwischencode.
Im Körper der Methode wird der If-Ausdruck weiter definiert. Terminalsymbole werden in der JavaCC Grammatik mit den größer-als und kleiner-als Zeichne umrandet. Die Nicht-Terminalsymbole hingegen sind wie in Listing \ref{lst:ifstatement} dargestellt weitere Methoden, die wiederum weitere Ausdrücke beschreiben.

Ähnlich wie bei der Syntaxregel \ref{eqn:start}, so lange bis lediglich Terminalsymbole übrig bleiben.
Die Methode \verb+bool_expression+ etwa, beschreibt einen zulässigen Boolschen Ausdruck, der durch einen weiteren boolschen Operator mit einem weiteren booleschen Ausdruck verknüft werden kann.

Weiterhin wird in der Methode \verb+proc_body+ beschrieben welche Ausdrücke weiter zulässig sind. Dazu zählt bspw. auch eine weitere \verb+IF ELSE+ Verzweigung. 

 So werden aus der Grammatikdatei, durch den Compiler-Compiler, nach und nach Java-Klassen erzeugt die Programmroutinen zur Syntaktischen Verarbeitung von PL/I-Ausdrücken beinhalten.
Der Ausschnitt aus der Grammatikdatei in Listing \ref{lst:ifstatement} wird zu dem Java-Quellcode in Listing \ref{lst:ifstatementmethode}.


\begin{lstlisting}[language=Java, caption=Verkürzte If-Statement Methode aus dem Parser, label={lst:ifstatementmethode}]
 final public void if_statement() throws ParseException {
			SimpleNode jjtn000 = new SimpleNode(JJTBRANCH);
			boolean jjtc000 = true;
			jjtree.openNodeScope(jjtn000);
	try {
			jj_consume_token(IF);
			bool_expression();
			jj_consume_token(THEN);
			proc_body();
		
		if (jj_2_30(3)) {
				else_statement();
		} else {
			;
		}
	} catch (Throwable jjte000) {
		if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
		} else {
				jjtree.popNode();
		}
		if (jjte000 instanceof RuntimeException) {
				if (true) throw (RuntimeException)jjte000;
		}
		if (jjte000 instanceof ParseException) {
				if (true) throw (ParseException)jjte000;
		}
				if (true) throw (Error)jjte000;
	}
}	
\end{lstlisting}

In Listing \ref{lst:ifstatementmethode} ist zu erkennen, dass die ebenfalls definierten Methoden in der Grammatikdatei, die repräsentativ für die Nicht-Terminal-Symbole sind, auch in der Methode der generierten Parser-Klasse zu Methodenaufrufen führen. Dies ist in Zeile 7 zu sehen. Weiterhin werden Token, also die Repräsentationen der Terminalsymbole, durch die Methode \verb+jj_consume_token+ verarbeitet. Die restlichen Verzweigungen in der generierten Java-Methode prüfen die verarbeiteten Token auf Fehler.

Außerdem wird mit dem Objekt \verb+SimpleNode+ in der Java-Methode aus Listing \ref{lst:ifstatementmethode} ein Knoten im Syntaxbaum erzeugt. Diese Knoten ermöglichen die Verarbeitung des PL/I-Quellcodes durch die weiteren Module des Transpilers.

% Warum ein Compiler-Compiler verwenden?

Ein Compiler-Compiler generiert einen fertigen Parser. Nun gibt es auch die Möglichkeit einen Parser und Lexer selbst zu programmieren. In der Version aus der Projektarbeit-IV wurde ursprünglich ein selbstgeschriebener Lexer verwendet.

Jedoch birgt dieses Vorgehen einen Nachteil. Die Grammatik für den Transpiler ist an zwei stellen definiert und muss somit auch an zwei Stellen gewartet werden.
Wird in die Grammatikdatei für den Parser ein neuer Ausdruck hinzugefügt, muss dieser Ausdruck auch durch den Lexer verarbeitet werden können.
Das führte zu einem höheren Arbeitsaufwand und Fehleranfälligkeit. Schlussendlich wurde der selbstgeschriebene Lexer entfernt und der von JavaCC generierte Lexer verwendet.
Ein Compiler-Compiler ist gut dazu geeignet den Arbeitsaufwand für die Entwicklung eines Compilers bzw. eines Transpilers zu reduzieren. 
Es lohnt sich auch bei der Entwicklung eines Parsers für andere Sprachen auf bereits definierte Ressourcen zurückzugreifen. 
Grammatiken für Cobol und Java wurden bereits von der JavaCC Community bereitgestellt. \footcite[Vgl. ][]{javaccdoku}
Im Fall von PL/I ist keine Grammatik vorhanden, weshalb bei der Entwicklung des Transpilers die IBM Language Reference für PL/I die Hauptquelle für die Grammatikdatei ist.   

% Wie wird JavaCC in die Entwicklung des Transpiler eingebunden ? (Hinleitung zur Architektur beschreibung)
Durch die Verwendung des JavaCC Jjtree-Moduls, kann global innerhalb des Projekts auf den Parse-Baum zugegriffen werden. 
Der Syntaxbaum wird unter anderem durch die Module verwendet, die die semantische-Analyse und -Synthese repräsentieren.
Erst durch diese wird der Java-Code erzeugt.

Ebenfalls wird für den Parser ein File-Stream benötigt, ein Scanner liefert solchen.
Neben den Parser werden also weitere Module verwendet um schlussendlich den Java-Code für den Benutzer bereitzustellen.
Die gesamte Architektur des Transpilers und dessen weitere Module wird in dem nachfolgenden Kapitel betrachtet. 
Hier werden auch die Technologien vorgestellt die neben JavaCC verwendet werden. 

\section{Technisches Vorgehen}
\subsection{Verwendete Technologien}
%- Compiler Compiler -> JavaCC: Integration in das Projetk, Grund für die Wahl der Technologie
In Kapitel 1.4 wurde bereits mit JavaCC eine verwendete Technologie vorgestellt. Neben JavaCC kommen auch weitere Technologien während der Entwicklung zum Einsatz. In dem folgenden Kapitel werden die weiteren verwendeten Technologien vorgestellt.

%- Programmiersprache -> Java: Integration in das Projekt, Grund für die Wahl.
Allgemein wurde der Transpiler in der Programmiersprache Java, der Version 17 von Oracle entwickelt. 
Java eignet sich  als objekt-Orientierte Hochsprache gut für die Entwicklung des Transpilers. 
Weiterhin zählen die Vorteile die in Kapitel 1.1 für Java erwähnt wurden, ebenso in diesem Fall. Den Administratoren soll die Möglichkeit gegeben werden, Module einfach auszutauschen. Mithilfe von Objektorientierten Programmierparadigmen, lässt sich eine lose Kopplung der Klassen realisieren und damit eine modulare Bauweise des Softwareprojekts.
Einhergehend fiel die Wahl auf JavaCC aufgrund der Entscheidung für die Entwicklung des Transpilers in Java. Ein alternativer Compiler-Compiler für Java, ist Antlr. 

%- IDE -> Eclipse: Integration in das Projekt, Grund für die Wahl.
Der Java-Quellcode des Transpilers wurde in Eclipse geschrieben. Das \ac{ide} Eclipse ermöglicht eine kostenlose Entwicklung, Verwaltung, Überprüfung und Kompilierung von Java Software-Projekten. Weiterhin bietet Eclipse eine breite Software-Repository an Plugins um die Funktionalität der  \ac{ide} zu erweitern. Dadurch ist eine Integration von JavaCC in die  \ac{ide} möglich und erleichtert die Entwicklung des Parser ebenfalls.

%- Maven -> Dependency Management: Integration in das Projetk, Grund für die Wahl der Technologie
Es wurde das Software-Projektmanagement-Werkzeug Maven eingesetzt. Maven löst mithilfe des \ac{pom} Abhängigkeiten. 
Dadurch werden Benutzer und Administratoren bei dem Build-Prozess entlastet.

%- Testing -> JUNit Tests: Integration in das Projetk, Grund für die Wahl der Technologie
Zum Testen der Anwendung wurde das Java-Test Framework JUnit 5 verwendet. Es wurden für jede Klasse zugehörige Testklassen geschrieben. In den Testklassen wurde komplexere Methoden isoliert getestet.
Die Wahl von JUnit ist begründet durch die einfache Handhabung, der Kompatibilität mit der IDE Eclipse und dem Projektmanagement Werkzeug Maven. Weiterhin ist JUnit mit eines der bekanntesten Unit-Test-Frameworks für Java-Quellcode. Alternativen wären etwa gewesen TestNG \footcite[Vgl. ][]{testng} oder Mockito \footcite[Vgl. ][]{mockito}.

%- Platform -> Spring
Für die Entwicklung des Frontends wurde das Java Framework Spring-boot verwendet.
Dabei wurde das Web-Interface mit der CSS-Softwarebibliothek Bootstrap gestaltet.
Spring-Boot wird für das behandeln von REST-Anfragen verwendet und bindet über eine API Schnittstelle den Transpiler ein.
Dadurch wird eine Interaktion über den Browser möglich.

Mithilfe der in diesem Kapitel genannten Software-Werkzeuge, wurde der Transpiler entwickelt. Die Entwicklungsphase folgte jedoch nach der Konzeptionsphase.
In der Konzeptionsphase wurde die Architektur der Anwendung ausgearbeitet und später als Quellcode realisiert. 
Im nächsten Kapitel soll dieses Architekturbild vorgestellt werden.

\pagebreak
\subsection{Architektur} 

Der Transpiler wurde Modular in die Arbetisschritte aus Abbildung \ref{fig:transpiler} unterteilt.
Die Module repräsentieren je einen Arbeitsschritt des Transpilers.
In Abbildung \ref{fig:modules} ist eine Grob-Ansicht der Module des Transpilers dargestellt.

\dhgefigure[h]{AbstraktesUML_1.png}[scale=0.5]{Aufbau des Transpilers}{fig:modules}[][]

% Wie sind die Module momentan gebaut?
% App Modul
Die Verarbeitung des PL/I-Quellcodes beginnt mit dem App-Modul. Das App Modul ist die Schnittstelle für alle weiteren Module. Ein Modul kann durch die Instanziierung der Client-Klasse des zugehörigen Moduls eingefügt werden. Entfernt wird das Modul durch das Löschen der Instanz. Das App-Modul beinhaltet auch die \verb+main+ Methode und ist somit auch der Startpunkt der \ac{jvm}.

Der Scanner wird als erstes Instanziiert. Dieser liest aus der Konfigurations-Datei den Pfad der PL/I Datei, die übersetzt werden soll. Die Datei wird als \verb+InputStream+ an den Parser übergeben.
\pagebreak
Der durch JavaCC erzeugte Parser wird ebenfalls im App-Modul instanziiert. Dieser behandelt den PL/I-Quellcode entsprechend der vorher definierten Grammatik.  Während des Parsings werden Variablen-, Prozeduren-, oder Packagebezeichner des PL/I-Quellcode in die Symboltabelle eingefügt. Das Ergebnis des Parsers ist ein Syntax-Baum. 
In Abbildung \ref{fig:parsetree} is exemplarisch ein Syntaxbaum des Transpilers abgebildet der eine Variablen Deklaration und eine Definition einer Prozedur darstellt.

\dhgefigure[h]{parsetree-example.drawio.png}[scale=0.7]{Beispielhafter Syntaxbaum des PL/I-Parsers}{fig:parsetree}[][]

Ist der Syntaxbaum entsprechend erzeugt, wird dieser durch das Checker-Modul weiterverarbeitet. In diesem Modul wird die semantische Analyse des Quellcodes durchgeführt. In der aktuellen Version erfolgt hauptsächlich eine Typ-Überprüfung der initialisierten Variablen.

% @review: Hier erwähnen wie Configdatei bzw. Scanner den Ausgabe Ordner beeinflussen wenn das implementiert wurde.
Das Mapper-Modul repräsentiert die Synthese des PL/I-Quellcodes in Java-Zielcode. Der Syntaxbaum wird hier Stück für Stück abgearbeitet und mit entsprechenden Java-Ausdrücken übersetzt.

% @todo: Wie sind Module zueinander abhängig?
Um einen Überblick über Abhängigkeiten der Module zu verschaffen, zeigt
Abbildung \ref{fig:modulesdep} aktuell die Beziehungen der Module untereinander.

\dhgefigure[h]{Beziehungen_Modules.png}[scale=0.7]{Die Abhängigkeiten der Module}{fig:modulesdep}[][]
\pagebreak

Zu erkennen ist in Abbildung \ref{fig:modulesdep}, dass die Abhängigkeiten unter den Modulen eine kaskadierende Form aufweisen.
Diese Form hat den Vorteil das Module aus dieser Kette verändert werden können ohne Vertikal verlaufende Module direkt zu beeinträchtigen.
Dennoch ist an dieser Stelle zu erwähnen, dass kein Modul isoliert betrachtet werden darf. Denn eine Veränderung eines Moduls bedeutet, dass auf horizontaler 
Ebene die Verarbeitung verändert wird.

% Wie sind die Module momentan gebaut?
Jedes Modul gibt die Ergebnisse weiter an das nächste Modul bis ein Zielcode entsteht oder eine Fehlermeldung.

% @todo: Wie wird es erweitert?
Der Administrator kann die Module erweitern oder ersetzen.
Dabei sollte jedoch die in Abbildung \ref{fig:modulesdep} dargestellte Kaskade der Module untereinander berücksichtigt werden.
Entscheidet sich der Administrator dazu etwa eine Methode zu entfernen und eine selbst entwickelte zu verwenden, ist lediglich die bisherige 
Referenz zu ersetzen.
%In der vorherigen Version des Transpilers wurde etwa die Lexer-Klasse entfernt und die Klassen des Compiler-Compilers verwendet.
%Der Quellcode des Lexer besteht jedoch und ist lediglich als Deprecated markiert. Die erneute Verwendung des Lexer würde über den Aufruf der Methode in Main erfolgen.
%Hingegen wären hier weitere Schritte notwendig, wie etwa das einfügen einer temporären Datei, die von dem Parser als InputStream entgegen genommen wird und weiter verarbeitet wird.

Nachdem nun ein Überblick über die Architektur gegeben wurde, soll nun in Kapitel 2.3 eine Detailansicht des Transpilers erfolgen.
Ab diesem Punkt soll genauer auf den Quellcode der einzelnen Module eingegangen werden um nachzuvollziehen wie der Transpiler den PL/I-Quellcode
in Java-Zielcode umwandelt.

%Bausteine
%- Software Architektur
	%- Planen mithilfe eines UML
	%- UX Design 
    %    - zweite Diagramm, des Benutzerfluss
    %    - wie Benutzung abläuft
	%	- Website?
	%	- Docker Container?
%- Fehlertracking
%- Struktuierung des Programms, sodass ein Benutzer es selbständig erweitern kann

%\subsection{Aspektorientierte Programmierung}
%- Wie funktioniert Aspektorientiert Programmierung?
%	- Wie Löse ich mit Aspektorientierter Programmierung konkrete Probleme?
%- JavaBeans
%- Spring
%	- Wie setzt Spring Aspektorientierte Programmierkonzepte ein?
 \pagebreak
\subsection{Module des Transpilers}
%Wie in dem vorangegangen Kapitel schon dargestellt, werden in jedem Modul
%die Verarbeitungsschritte aus Abbildung \ref{fig:transpiler} implementiert.
%In diesem Kapitel sollen die Module nach ihrer Verarbeitungsreihenfolge vorgestellt werden.
%Dabei soll ein \ac{uml}-Diagramm je zu beginn der Unterkapitel verdeutlichen wie die Klassen
%in den Modulen zueinander aufgebaut sind. In jedem Diagramm wird auch auf die Einbindung in die App-Klasse eingegangen.
%Die Beschreibung beginnt mit dem Scanner.

\subsubsection{Der Scanner und Parser}
\paragraph{Scanner}
Wie Kapitel 1.5 eingeführt wird der Parser vollständig durch 
JavaCC generiert.
Damit der Parser den PL/I-Quellcode in die Zwischencode Darstellung übersetzen kann,
braucht dieser eine PL/I-Datei, die als Input-Stream übergeben wird.
Den Pfad zu der Datei gibt der Administrator in der Konfigurationsdatei an.
Das Modul Scanner liest die Konfigurationsdatei und versorgt den Parser mit notwendigen Ressourcen.
Abbildung \ref{fig:scannermodul} zeigt das UML-Diagramm des Scanner Moduls.

\dhgefigure[h]{scanner-klasse-uml.drawio.png}[scale=0.8]{Das Scanner-Modul}{fig:scannermodul}[][]

Das Scanner Modul besteht aus der Klasse \verb+InputReader+. 
Die \verb+InputReader+ Klasse liest und verarbeitet die Konfigurationsdatei. Die Methode \verb+getInputFilePath+ gibt den Pfad der PL/I-Quellcode Datei als String zurück.
Dieser String wird beim Aufruf der \verb+getInputFile+ Methode benötigt, um aus der Datei einen \verb+InputStream+ zu erzeugen.
Mithilfe des InputStreams kann die Datei als Parameter an den Parser in der Klasse \verb+App+ im Modul \verb+App+
übergeben werden. 

%\paragraph{Lexer}
%Die Klasse Lexer des Moduls Scanner enthält den ehemals selbst geschriebene Lexer für die lexikalische Analyse. Dadurch das dieser Prozess nun vollständig von dem JavaCC-Parser übernommen wird, wurde die Methode \verb+getToken+ überflüssig. Diese ist als veraltet mit der Kennung 'Deprecated' beschrieben, sie kann im Projekt noch verwendet werden, jedoch mit einem Risiko das die Ergebnisse der Methode nicht korrekt sind. 
%Zu einem späteren Zeitpunkt ist denkbar den selbstgeschriebenen Lexer zu optimieren und erneut einzubinden. Weshalb dieser nicht gelöscht wurde. 
%Weitere Methoden in dieser Klasse werden ebenfalls nicht länger von Klassen aus anderen Modulen verwendet. 

\paragraph{Parser}
Das Parser-Modul deckt die lexikalische und syntaktische Analyse des PL/I-Quellcodes ab.
Wie schon in Kapitel 1.4 erwähnt werden jegliche Klassen des Parsers durch die \verb+.jjt+ Grammatikdatei generiert. Da diese Klassen sehr umfangreich sind, werden diese in Abbildung \ref{fig:moduleparser} lediglich in abgekürzter Form dargestellt. 

\dhgefigure[h]{parser-module-uml.drawio.png}[scale=0.4]{Das Parser-Modul}{fig:moduleparser}[][]
\pagebreak

Der Parser wird über die Klasse \verb+Pl1Parser+ in dem App Modul instanziiert. In der Parser-Klasse sind auch jegliche manuell geschriebenen Methoden aus der Grammatikdatei integriert. 
Dazu gehören etwa die Methode \verb+installId+, sowie weitere. 

Die ebenfalls in der Grammatikdatei definierten Tokens, 
werden in der Klasse \verb+Pl1ParserConstants+ als Konstanten definiert. 
Wobei während der Lexikalischen Analyse, die Klasse Token verwendet wird um Terminalsymbole zu verarbeiten. 
Schlussendlich wird einhergehend mit der Klasse \verb+Pl1Parser+ geprüft ob der PL/I-Quellcode zulässig ist. 
Diese beinhaltet die Methoden der in der Grammatikdatei definierten Nicht-Terminalen Ausdrücke, wie die Methode \verb+if-statement+. 
Hier ist auch der Großteil der Verarbeitungslogik des Parser-Moduls implementiert.

Wird ein Ausdruck während der Verarbeitung in Pl1Parser-Klasse als nicht zulässig  interpretiert wird eine \verb+ParseException+ geworfen, die in der Klasse \verb+ParseException+ definiert ist.

Um den Ausdruck in einem Syntaxbaum zu repräsentieren wird ein Objekt der Klasse \verb+SimpleNode+ erzeugt. Durch die Methoden \verb+clearNodeScope+ und \verb+closeNodeScope+ der Klasse \verb+JJTPl1ParserState+ wird der verarbeitete Ausdruck mit bspw. der Repräsentation \verb+VAR+ in den Syntaxbaum eingefügt. 
Siehe Abbildung \ref{fig:parsetree} So verarbeitet der Praser des Transpilers Stück für Stück den PL/I-Quellcode. 

Hat der Parser ein Nicht-Terminalsymbol gefunden, wird die Methode \verb+installIds+ aufgerufen und der Bezeichner unter bestimmten Bedingungen in die Symboltabelle eingefügt. 
Ein Bezeichner wird nicht eingefügt, 
wenn dieser schon vorhanden ist und den selben Sichtbarkeitswert hat.

Dabei wird das Modul \verb+SymbolTable+ implementiert und mit der Methode \verb+insertId+ ein Bezeichner in die Symboltabelle eingefügt. Im folgenden Unterkapitel wird das Modul der Symboltabelle genauer beschrieben. 

\pagebreak
\subsubsection{Symboltable}
Die Symboltabelle speichert die PL/I-Symbole in einer Hashtable ab. Mit ihr sollen die anderen Module
erkennen können ob es sich bei dem ausgewählten Token um ein PL/I-Symbol handelt, oder um ein Bezeichner.
In Abbildung \ref{fig:symboltable} ist das Modul \verb+symboltable+ als \ac{uml} dargestellt.

\dhgefigure[h]{symboltable-module-uml.drawio.png}[scale=0.7]{Symboltabellen-Modul}{fig:symboltable}
\pagebreak

Das Modul \verb+Symboltable+ enthält die Klasse \verb+SymbolTable+
sowie die Enums \verb+Pl1Symbols+ und \verb+Template+.

% Wie funktioniert SymbolTable und Pl1Smybols?
Die Klasse \verb+SymbolTable+ wird beim instanziieren des Objekts mit den Werten aus dem Enum \verb+Pl1Symbols+ initialisiert. Weshalb ein Singleton Design-Pattern implementiert wurde um sicherzugehen, dass von der Symboltabelle während der Laufzeit nur eine Instanz existiert. 
Über die Methode \verb+getInstance+ können andere Module auf diese Instanz zugreifen.

Wenn ein Bezeichner in die Symboltabelle eingefügt wird, wird ein String für den Bezeichner, ein String für den Typ, ein String für die Sichtbarkeit und ein String für die Hierarchiestufe der Variable hinterlegt. Nur so kann in darauffolgenden Arbeitsschritten wie in der semantischen Analyse, die Werte korrekt verarbeitet werden.

Die restlichen Methoden der Klasse \verb+SymbolTable+ dienen der dezidierten Abfrage von Werten.

Etwa die \verb+getSymbolScope+ Methode wird dazu verwendet den Sichtbarkeitswert eines Bezeichners auszugeben.

% Wie funktioniert Template?
Der weitere Enum \verb+Template+ dient dazu, im Prozessschritt der Synthese den Syntaxbaum in Java-Code umzuwandeln.
In diesem Enum sind Java-Quellcode Ausschnitte hinterlegt die PL/I-Quellcode repräsentieren können. Sie werden in dem Mapper Modul verwendet,
um nach und nach den Java-Zielcode zu erzeugen.

Um den Syntaxbaum zu erzeugen muss der Syntaxbaum Stück für Stück überprüft werden. Dieser Prozess wird als semantische Analyse bezeichnet und erfolgt im Checker Modul.
 
 \pagebreak
\subsubsection{Checker}
Das Checker-Modul prüft den PL/I-Quellcode auf seine Korrektheit. 
Dieses Modul ist repräsentativ für die Semantische-Analyse. 
Eine Aufgabe des Checker-Moduls ist es die Typ-Definition von Variablen mit den Zuweisungen abzugleichen.
Wird beispielsweise dem Decimal-Typ ein alphanumerischer Wert zugewiesen, soll dieses Modul den Benutzer auf einen Syntaxfehler hinweisen. Um solche Semantischen Fehler zu erkennen, wird das Checker-Modul nach dem Vorbild des Composite Design-Patterns implementiert. In Abbildung \ref{fig:checker} ist das \ac{uml} des Checker Modul abgebildet.

\dhgefigure[h]{checker-module-uml.png}[scale=0.58]{Checker Modul}{fig:checker}
\pagebreak

Entsprechend des Composite Design-Patterns, wird der Component; \verb+ITypeExpression+, das Composite; \verb+VarChecker+ und mehrere Leafs wie etwa die \verb+DecimalChecker+ Klasse, definiert.
Die zu überprüfenden PL/I-Datentypen ergeben ein Leaf.
Dabei hilft das Composite-Design Pattern für alle Typ-Klassen, einheitliche Validierungstrukturen zu definieren.
Etwa in Abbildung \ref{fig:checker} ist die Methode \verb+getType+ definiert, um die korrekte Zuweisung von Variablen zu erschließen. 

Weiterhin kann mit dem Design-Pattern die Speicherstruktur, die einer Überprüfung unterzogen wird, in der Composite-Klasse dargestellt werden.
Eine mögliche Erweiterung um weitere Speicherstruktur-Elemente wie einem Array ist somit denkbar.

In dem Checker-Modul wird zum ersten Mal auf den Syntaxbaum, das Ergebnis des Parser Moduls, zugegriffen.
Um auf alle Knoten des Syntaxbaums zuzugreifen, wird eine Methode definiert die zum iterieren des Syntaxbaums benötigt wird.
Diese Methode ist auch für weitere Module brauchbar, weil auch diese durch den Syntaxbaum iterieren sollen.
Dazu wurde in der \verb+DecimalChecker+ Klasse die Methode \verb+iterateTree+ implementiert.
Um den Syntaxbaum erfolgreich zu iterieren wurde der Depth-first Suchalgorhitmus rekursiv in dieser Methode implementiert.
Die Iterationsweise des Algorhitmus im Zusammenhang mit dem Syntaxbaum ist in Abbildung \ref{fig:parsetreealgo} dargestellt.

\dhgefigure[h]{parsetree-example-searchalgo.png}[scale=0.8]{Beispielhafte Iteration des Syntaxbaums}{fig:parsetreealgo}[][]
\pagebreak

So wird es möglich, gezielt nach Knoten zu suchen und die Attribute des Knotens auszulesen.
In dem Checker Modul wird dieser Algorithmus vor allem benutzt, um festzustellen, welche Variablen mit welchem Typ und welchem Bezeichner deklariert wurden und ob dieser Bezeichner in einem \verb+ASSIGN+ Knoten wiederverwendet wurde.

So kann der Syntaxbaum mit seinen Attributen vollständig iteriert und überprüft werden.
Die Überprüfung ist dann abgeschlossen, wenn die Iteration des Suchalgorithmus wieder bei dem Ausgangspunkt angekommen ist. In Abbildung \ref{fig:parsetreealgo} ist das etwa der Knoten \verb+PRORGRAM+.

Wurde kein Fehler entdeckt beginnt die Transformation des Syntaxbaums in Java. Falls jedoch ein Fehler entdeckt wurde, wird eine entsprechende Fehlermeldung angezeigt.

Das Checker Modul bereitet den Syntaxbaum entsprechend so vor, dass dieser weiterhin in der Synthese verarbeitet werden kann.
Die Synthese wird durch das Mapper-Modul implementiert und ist Bestandteil des nächsten Kapitels.
 
 \pagebreak
\subsubsection{Mapper}
% TODO Referenz zu Kapitel 3.2 einbauen
Das Mapper Modul transformiert die Zwischencode Repräsentation in den Java-Zielcode. Dazu wurde das Mapper-Modul nach dem Strategy Desgin-Pattern entworfen.
In Abbildung \ref{fig:mapper} ist das UML des Mapper Moduls zu sehen. 


\dhgefigure[h]{mapper-module-uml.png}[scale=0.7]{Mapper Modul}{fig:mapper}
\pagebreak

Die Klasse \verb+Mapper+ wird in der Main-Methode des Projektes instanziiert. Als Parameter wird der Wurzelknoten des Parssebaums übergegeben.
Woraufhin mithilfe der \verb+iterateTree+ Methode erneut durch den Parsbaum iteriert wird. Hier wurde ebenfalls der Depth-first Suchalgorhitmus implementiert um jeden Knoten zu verarbeiten. 

Jeder Knoten wird über eine Konstante mit einer zugehörigen Identifizierungsnummer überprüft. Die in dem interface \verb+Pl1ParserTreeConstants+ des Parser Moduls definiert sind. 

In der Klasse \verb+AstMapper+ finden sich jegliche Identifikations-variablen der Knoten. Hier werden diese mit den zugehörigen Mapper-Klasse in einer HashMap gespeichert.

Die Mapper Klassen stellen die unterschiedlichen Vorgehensweisen in dem Strategy-Pattern dar. Sie implementieren alle das \path{ITranslationBehavior} interface und aufgrund dessen eine \verb+translate+ Methode, die den übersetzten Ausdruck zurückgibt. 

In der \verb+iterateTree+ Methode wird für jeden Knoten überprüft ob eine solche Mapper-Klasse in der HashMap instanziiert wurde.
Falls eine Klasse vorhanden ist, wird in der TranslationBehavior Klasse das entsprechende Strategie-Objekt
des Typs \path{ITranslationBehavior} in der
Mapper Klasse gesetzt. So wird die Translate-Methode der aktuell gesetzten Klasse aufgerufen und der Syntaxbaum-Knote in Java übersetzt.

% wie funktioniert der PicturemMapper
Eine exemplarische Mapper Klasse ist etwa die \verb+PictureMapper+ Klasse.
Die Klasse \verb+PictureMapper+ enthält Zeichenkettenbeschränkungen des PL/I-Picture Typs und deren Übersetzung als Regulären Ausdruck.
Da die Zeichenkettenbeschränkung aus PL/I nicht in dem Java Zielcode angewendet werden kann, werden die Beschränkungen des Picture-Typs entsprechend in Reguläre Ausdrücke übersetzt.
Mit der \verb+getRegex+ Methode der \verb+PictureMapper+ Klasse wird der übersetzte Reguläre Ausdruck als String zurückgegeben.
Der PL/I-Ausdruck \verb+(4)A+ wird etwa zu dem Regulären Ausdruck \verb+[A-Za-z ]{4}+.   


Neben der PictureMapper Klassen, erzeugen weitere Mapper Klassen Stück für Stück den Java-Zielcode. 
Jegliche Ausdrücke werden am Ende in einer Arraylist mit dem Namen \verb+javaExpression+ der Mapper Eltern-Klasse  gespeichert.
Wenn über jeden Knoten des Parse-Baums iteriert wurde, ist das Programm vollständig übersetzt.


Dabei kann es jederzeit zu Fehlern, durch eine Fehlerhafte Benutzereingabe kommen.
Entsprechend sollte der Benutzer auf die Probleme hingewiesen werden.
In dem Modul Errorhandling, werden Fehlermeldungen definiert und von anderen Modulen implementiert das folgenden Kapitel 2.4 gibt eine Übersicht über Eigen-implementierte Fehlermeldungen und verwendete Fehlermeldungen aus der Standardbibliotheken.

\pagebreak

\subsection{Fehlerbehandlung}
Die Fehlerbehandlung wird über das Modul Errorhandling bereitgestellt.
In diesem wurden Kind-Klassen der Exception Klasse, der Java Standard Bibliothek implementiert.
Allgemein wurde versucht möglichst wenig selbstdefinierte Exception Klassen zu erstellen.
Denn der Erfahrene Java-Entwickler der mit den Standard-Java Exception vertraut ist, kann so schneller die geworfenen Fehler behandeln. In der Tabelle \ref{tab:exceptiontabelle} sind die verwendeten Exception dargestellt.

\begin{table}[h]
	\centering
	
	\label{tab:exceptiontabelle}
\begin{tabular}[h]{|l|l|l|}
	\hline
	\textbf{Exception} & \textbf{Quelle}  \\
	\hline
	\verb+IncorretInputFileException+ & Errorhandling-Modul  \\
	\hline
	\verb+LexicalErrorException+ & Errorhandling-Modul  \\
	\hline
	\verb+TypeMappingException+ & Errorhandling-Modul \\
	\hline
	\verb+ParseException+ & Parser-Modul \\
	\hline
	\verb+MappingException+ & Errorhandling-Modul \\
	\hline
	\verb+IOExcpetion+ & Java-IO-Package \\
	\hline
	\verb+NumberFormateExcpetion+ & Java-Lang-Package \\
	\hline
	\verb+IllegalArgumentException+ & Java-Lang-Package \\
	\hline
	\verb+NullPointerException+ & Java-Lang-Package \\
	\hline
	\verb+DuplicateRequestException+ & Jdi-Request-Package \\
	\hline
	
\end{tabular}
\caption{Liste der verwendeten Exceptions}
\end{table}

Nachfolgenden soll der Kontext der Exceptions näher beschrieben werden.

Die \verb+IncorretInputFileException+ wird immer dann geworfen, wenn
es sich bei der Eingabedatei nicht um eine PL/I-Datei handelt.
Der Transpiler akzeptiert lediglich das Dateiformat \verb+.pli+.

Enthält dabei der zu übersetzende Ausdruck eine Variable des Typs Picture,
soll die \verb+LexicalErrorException+ verhindern das ein fehlerhafter Picture-Ausdruck übersetzt wird.
Diese Fehlermeldung eignet sich auch weiterhin um Lexikalische von Syntaktischen Fehlern zu unterscheiden. Da jedoch in der aktuellen Version des Transpilers die lexikalische Analyse und syntaktische Analyse von dem Parser-Modul übernommen werden, wird auch die \verb+ParseException+ zurückgegriffen.

Der Benutzer wird durch die \verb+ParseException+ darauf hingewiesen wo ein Fehlerauftritt und welche Schritte unternommen werden müssen um den Fehler zu beheben.
Wird etwa ein Syntaktisch falscher Ausdruck an das Parser-Module übergeben, parsed diesen den Ausdruck
bis zu der Stelle in der die definierte Grammatik nicht länger greift.
Der PL/I-Parser wirft die \verb+ParseException+ und gibt in dieser die Zeilen- und Spaltennummer des
entstanden Fehlers an.

Woraufhin das Checker-Modul nochmal die Zwischencode-Erzeugung des Parser überprüft.
Da das Checker-Modul aktuell lediglich einen Typ-Checker implementiert, existiert aktuell nur eine \verb+TypeMappingException+.
Diese wird immer dann geworfen, wenn der Typ einer deklarierten Variable mit einem nicht zugelassenen Wert zugewiesen wird.
Für weitere Semantische Analyse Schritte, sind ebenfalls weitere Exceptions denkbar. Allgemein dient das Checker-Modul lediglich der Fehlererkennung und Unterbrechung des Transformations-Prozesses.

Mithilfe der \verb+MappingException+ wird vor jeder Terminierung der \verb+translate+ Methode des Mapper-Moduls überprüft ob 
die benötigten Werte, wie etwa ein Bezeichner oder ein Parameter auch korrekt aus dem Syntaxbaum verarbeitet wurden.
Es ist zwar zu erwarten das der Parser einen solchen Fehler erkennt, aufgrund der definierten Grammatik, 
dennoch soll nach Möglichkeit vermieden werden das ein Fehlerhaftes Programm Transformiert wird.

Die restlichen Standard Java-Exceptions werden auch in dem zu erwarteten Zusammenhang eingesetzt.

In der aktuellen Version des Transpilers werden auch nicht alle PL/I-Syntaxelemente eingebunden.
Das hat zur folge das es äußerst wahrscheinlich ist, dass der Benutzer auf eine ParseException stoßen wird.
Aufgrund der beschränkten Arbeitszeit, wurden lediglich wesentliche Syntaxelemente einer Programmiersprache implementiert.
Dazu zählen Deklarationen, Kontrollflussanweisungen, sowie Ein- und Ausgabeströme.
In dem nachfolgenden Kapitel werden diese Kernfunktionen vorgestellt und die Übersetzungsentscheidung
diskutiert. 

\pagebreak
\section{Technische Spezifikation}
\subsection{Ausführung des Transpilers}

% Importieren in Eclipse
Für die unterschiedlichen Benutzergruppen werden verschiedene Nutzungsmöglichkeiten des Transpilers angeboten. Diese umfassen die Verwendung über die \ac{ide} Eclipse, die Kommandozeile und das Webinterface. Bei der Benutzung des Transpilers werden erstmals Übersetzungsentscheidungen sichtbar. In diesem Kapitel sollen alle Nutzungsmöglichkeiten und Spezifikationen des Transpilers näher beschrieben werden.

\paragraph{Eclipse}
Die \ac{ide} Eclipse kann verwendet werden, um den Transpiler zu nutzen. Diese Herangehensweise ist besonders interessant für Administratoren, die den Quellcode des Transpilers selbst erweitern möchten.
Zuerst sollte das Projekt aus dem GitHub-Repository mit Git in das lokale Verzeichnis geladen werden.
In Listing \ref{lst:gitclone} ist der Git-Befehl, zum laden des Remote-Repositories dargestellt. 

\begin{lstlisting}[language=bash, caption=Herunterladen der Repository des Transpilers, label={lst:gitclone}]
git clone https://github.com/lhahner/pl1-code-transpiler.git
\end{lstlisting}

Daraufhin ist es möglich, das Maven-Projekt in Eclipse zu Importieren. Unter der Registerkarte "Datei", kann das Projekt importiert werden. %Dabei erscheint das Menüfenster aus Abbildung \ref{fig:importproject}.

%\pagebreak
%\dhgefigure[h]{import-maven-project.png}[scale=0.4]{Importieren eines Maven Projekts}{fig:importproject}

Im nächsten Menüfenster sollte der Ordner ausgewählt werden, in dem die \verb+pom.xml+ Datei liegt. Ist der Ordner korrekt ausgewählt, wird das Projekt in Eclipse importiert. 

Das Verzeichnis \verb+src/main/java/res/pli+ ist das Standard-Eingabeverzeichnis. Hier kann eine PL/I-Datei abgelegt werden, die übersetzt werden soll. Es ist auch möglich, das Standard-Eingabeverzeichnis zu ändern. 
Im Ordner \path{src/main/java/res/config} befindet sich die Konfigurationsdatei 
\verb+config.properties+. In dieser Datei kann die Variable \verb+PATH+ geändert werden, 
um PL/I-Quellcode aus einer anderen Projektstruktur zu transformieren.

\paragraph{Webanwendung}
Um es dem Benutzer leicht zu gestalten den Transpiler zu verwenden wurde mithilfe des Spring-Boot Frameworks eine Webanwendung entwickelt.
Die Webanwendung enthält neben der Integration des Transpilers auch Dokumentationen der bisherigen Versionen.
Um die Webanwendung zu verwenden muss erneut eine GitHub-Repository geladen werden. Verwendet wird der Git-Befehl in Listing
\ref{lst:gitcloneweb}

\begin{lstlisting}[language=bash, caption=Herunterladen der Repository der Web-Schnittstelle, label={lst:gitcloneweb}]
	git clone https://github.com/lhahner/plitra-web.git
\end{lstlisting}

Um die Anwendung zu starten sollte mit der Kommandozeile in den Projektordner navigiert werden.
Daraufhin kann das Spring-Boot Projekt gestartet werden. In Listing \ref{lst:springboot} ist der Befehl beschrieben um die Spring-Boot Anwendung lokal zu starten.

\begin{lstlisting}[language=bash, caption=Build Spring-Boot Projekt, label={lst:springboot}]
	.\mvnw spring-boot:run
\end{lstlisting}

Daraufhin wird die Spring-Boot Anwendung unter dem Port 8080, lokal erreichbar.
Zu sehen ist unter diesem Port die grafische Oberfläche aus Abbildung \ref{fig:homepage}.

\dhgefigure[h]{homepage-plitra-web.png}[scale=0.5]{Startseite der Grafischen Oberfläche}{fig:homepage}[][]

Hier kann entweder unter "Documentation" die Dokumentation der bisherigen Versionen eingesehen werden und unter Transpile
die eigentliche Anwendung aufgerufen werden.
Unter "Transpile" öffnet sich die Grafische Oberflächliche aus Abbildung \ref{fig:translator}.

\dhgefigure[h]{translate-view.png}[scale=0.5]{Grafische Oberfläche des Übersetzers}{fig:translator}[][]

Auf der linken Seite der Grafischen Oberfläche kann der PL/I-Quellcode eingefügt werden und auf der linken Seite erscheint dann, entweder der übersetze Java-Zielcode oder eine Fehlermeldung.
Der Benutzer kann diese Schnittstelle benutzen um einfache PL/I-Programm zu übersetzen, oder um die Java-Repräsentation eines PL/I-Ausdruck anzusehen.

Neben der grafischen Oberfläche hat auch die Gestaltung der Übersetzung einen Einfluss auf die Benutzererfahrung. Eine Transformation des PL/I-Quellcodes in schwer lesbaren und wartbaren Java-Zielcode erreicht zwar das grundlegende Ziel der Übersetzung, ist jedoch für viele Benutzer nicht ausreichend.

In den nachfolgenden Kapiteln werden PL/I-Strukturen beschrieben und die Transformation in Java diskutiert.

\pagebreak





\subsection{Transformationsstrategien}
\subsubsection{Deklarationen und Zuweisungen}
Die erste Version des Transpilers enthielt lediglich die Transformation von PL/I-Datentypen in nicht-primitive Java Datentypen wie etwa die Klasse \verb+DECIMAL+, \verb+CHAR+ oder \verb+PICTURE+.

%In der Version des Transpilers aus der Projektarbeit IV wurden selbst geschriebene, nicht-primitive Datentypen verwendet, um die PL/I-Datentypen in entsprechenden Java-Zielcode zu übersetzen. Dies ist für Deklarationen ausreichend.

Erst bei der Verwendung dieser Datentypen in einer Programmroutine werden jedoch Mängel des Designs sichtbar. Ein Beispiel hierfür ist die \verb+DECIMAL+-Klasse.

Werden in dem PL/I-Quellcode etwa die deklarierten Variablen verwendet um Mathematische Berechnungen zu erstellen, ist dies ohne Probleme mit den Mathematischen Standard Operatoren wie Plus oder Minus möglich.

Wird ein Java-Programm auf der grünen Wiese erzeugt sind solche Ausdrücke ebenfalls möglich, wenn Numerische primitive Datentypen zum Einsatz kommen.

Um solche Ausdrücke auch in Java mit einem \verb+DECIMAL+-Objekt zu ermöglichen, muss die Klasse \verb+DECIMAL+ erweitert werden.
Denn in Java ist es nicht möglich nicht-primitive Datentypen zu verrechnen, ohne vorher eine Methode zu schreiben die diese Operation ermöglicht. 
Bei der Implementierung der Methoden können die Standard-Operatoren nicht überladen werden, wie es in C++ der Fall ist.
Stattdessen müssen ausformulierte Methoden implementiert werden, die den numerischen Wert einer Variable abfragen und mit einer weiteren Verrechnen

Ein Beispiel soll demonstrieren wie die Übersetzung eines Arithmetischen Ausdrucks aussehen könnte.
Angenommen der PL/I-Ausdruck in Listing \ref{lst:pliarithmeticexpression} wird mithilfe des Transpilers in Java übersetzt.
Ist nun in der Klasse \verb+DECIMAL+ für jede Arithmetische Operation eine Methode definiert wäre die Übersetzung wie in Listing \ref{lst:pliarithmeticexpression} denkbar.

%testing Side-by-side
\begin{minipage}[b]{0.48\linewidth}{\newline}
	
	\centering
	\lstset{language=PL/I}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Transformation DECIMAL}, label={lst:pliarithmeticexpression}]
	DCL var_1 FIXED DECIMAL(3) 
	INIT(2);
	DCL var_2 FIXED DECIMAL(3) 
	INIT(2);
	DCL var_3 FIXED DECIMAL(5);
		
	proc_1: PROC;
		var_3 = var_1 + var_2;
	END proc_1;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	DECIMAL var_1 = new DECIMAL(2)
	.INIT(2);
	DECIMAL var_2 = new DECIMAL(2)
	.INIT(2);
	DECIMAL var_3 = new DECIMAL(5);
		
	public void proc_1() {
		var_3.INIT(var_1.add(var_2));
	}
	\end{lstlisting}
\end{minipage}

An diesem Punkt ist anzumerken, dass diese Übersetzung zwangsläufig zu einer komplexen Struktur des Java-Zielcodes führen wird. Für die weitere Übersetzung syntaktischer PL/I-Strukturen könnte die Entscheidung für eine solche Lösung die Lesbarkeit des übersetzten Programms beeinflussen. Beispielsweise würde die Verwendung sowohl arithmetischer als auch boolescher Operatoren in einer Verzweigung den Java-Zielcode komplex wirken lassen. Ein Grund hierfür liegt in der Nutzung implementierter Methoden anstelle mathematischer Operatoren.

Wenn das \verb+DECIMAL+-Objekt durch einen primitiven Datentyp ersetzt werden würde, wäre eine eins-zu-eins Transformation des zugewiesenen arithmetischen Ausdrucks in Listing \ref{lst:pliarithmeticexpression} möglich. Um die Längenbeschränkung aus PL/I auch in Java zu berücksichtigen, könnte die Implementierung einer Validierungs Annotation erwogen werden.

Mithilfe der Jarkarta-Validations Software-Bibliothek kann eine Annotation erzeugt werden, die mit einer Java-Reflection überprüft wird. \footcite[Vgl. ][]{jakarta}
Dazu wird eine Implementierung von Validierungs-Klasse als Boiler-Plate-Code  notwendig. 
Die Übersetzung des Ausdrucks in Listing \ref{lst:pliarithmeticexpression} würde wie in Listing \ref{lst:annotationdecimal} dargestellt erfolgen.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Transformation DECIMAL}, label={lst:annotationdecimal}]
	DCL var_1 FIXED DECIMAL(3)
	INIT(2);
	DCL var_2 FIXED DECIMAL(3) 
	INIT(2);
	DCL var_3 FIXED DECIMAL(5);
		
	proc_1: PROC;
		var_3 = var_1 + var_2;
	END proc_1;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	public @Decimal(3) double 
	var_1 = 2;
	public @Decimal(3) double 
	var_2 = 2;
	public @Decimal(5) double var_3;
		
	public void proc_1() {
		var_3 = var_1 + var_2;
	}
	\end{lstlisting}
\end{minipage}

Durch diese Gestaltung ist auch die Einbindung und Erweiterung des übersetzen PL/I-Quellcode erleichtert.

In diesem Zusammenhang wird in der weiterführenden Entwicklung die Beschränkung der Länge mit Annotationen gelöst. So kann eine semantische nähe zu Java hergestellt werden und gleichzeitig der Wiedererkennungswert von PL/I beibehalten werden.

Da auch weitere PL/I-Datentypen wie etwa der \verb+PICTURE+ oder \verb+BINARY+ Typ mit dieser Lösung leichter implementiert werden können, werden in zukünftigen Versionen des Transpilers auch hier die eigen definierten Klassen ersetzt.
Aktuell ist eine Zuweisung von Werten lediglich mit einer Variable des Typs \verb+CHAR+ und \verb+DECIMAL+ möglich.

Wie schon in Listing \ref{lst:annotationdecimal} und Listing \ref{lst:pliarithmeticexpression}
in Zeile ? bis ? zu sehen, werden in der aktuellen Version auch Prozeduren übersetzt.
In dem folgenden Kapitel werden die Übersetzungsentscheidungen dieser näher diskutiert.

\pagebreak
\subsubsection{Programmstruktur und Programmablauf}
\paragraph{Umwandlung von Programmstrukturen }\label{programstruct}

Mit dieser Version des Transpilers ist es möglich, Prozeduren umzuwandeln.
In PL/I werden Unterprogramm-Routinen in Block-Strukturen definiert. Eine mögliche Block Struktur ist die Prozedur. \footcite[Vgl. ][S. 97ff. ]{pliref}
Eine Prozedur wird durch den Bezeichner, das PL/I-Symbol \verb+PROCEDURE+ und einer Terminierung wie \verb+END+ beschrieben.
Zusätzlich können Parameter, Rückgabetypen und allgemeine Attribut Optionen definiert werden. In Listing \ref{lst:procchar} ist eine beispielhafte Prozedur gelistet.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Prozeduren}, label={lst:procchar}]
	DCL Revenue FIXED DECIMAL(5);

	A10_Revenue: PROC(rev_1) 
		RETURNS(DECIMAL(5)) 
		OPTIONS(INLINE);
			
			RETURN rev_1;
	
	END proc_1;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	public @Decimal(5) double Revenue;
		
	public @Decimal(5) double A10_Revenue (Object rev_1) { 
		
		return (double)rev_1;
	
	}
	\end{lstlisting}
\end{minipage}

Die Prozedur \verb+A10_Revenue+ hat einen Parameter und gibt einen Wert des Typs \verb+DECIMAL+ der L\"ange 5 zur\"uck.
Weiterhin wird die Option \verb+INLINE+ definiert.

Um in Java Unterprogramm-Routinen zu definieren gibt es Methoden. 
Entsprechend sind Methoden ein mögliches äquivalent der Prozeduren. \footcite[Vgl. ][]{oracle}
Eine Methode hat ähnliche Bestandteile wie eine Prozedur.
Es wird ein Modifier, Rückgabetyp, Bezeichner und eine Parameterliste benötigt.
Einige dieser Attribute sind auch in einer Prozedur definiert.
Jedoch gibt es Unterschiede, die zu einer nicht eindeutigen Übersetzung führen können.

Wird etwa versucht die in der PL/I-Prozedur definierten Parameter direkt zu übersetzen, fehlt die explizite Angabe des Typs im Parameter. Dieser wird in PL/I implizit durch die Zuweisung definiert.

Implizit wird hier der Typ \verb+DECIMAL+ zugewiesen. 
In Java muss hingegen explizit der Typ des Parameter angegeben werden.
Eine M\"oglichkeit die Parameterliste zu transformieren, ist über den Typ \verb+Object+.
Da Object die Elternklasse aller Klassen ist, kann während der Zuweisung des Parameters beliebig in den gewünschten Typ umgewandelt werden. \footcite[Vgl. ][]{objectdocs}

In Listing \ref{lst:procchar} wird etwa in den Typ \verb+double+ gecastet.

Weiterhin wird in der Prozedur aus Listing \ref{lst:procassign} ein R\"uckgabewert des Typs \verb+DECIMAL+ der L\"ange f\"unf definiert.

Auch hier eignet sich die Verwendung der in Kapitel \ref{programstruct} beschriebenen Annotationslösung.

Erneut wird auch in Listing \ref{lst:procchar} über die Annotation die Längenbeschränkung definiert und der native Java Typ String verwendet.
Die Validierung des Rückgabewertes erfolgt dann mithilfe von Boiler-plate Code der bei der Transformation bereitgestellt wird.
Über eine Typ-Umwandlung des Parameter kann auch dieser in der Methode zurückgegeben werden. 

Ein weiteres Attribut das in der Prozedur in Listing \ref{lst:procassign} definiert ist, ist das \verb+OPTIONS+
Attribut.
In PL/I werden hier Compiler-Optionen definiert. So wird, wie in Listing \ref{lst:procassign} gezeigt, die Option \verb+INLINE+ verwendet, um den Kontext einer Prozedur zu beschreiben. Ist die Prozedur etwa \verb+INLINE+, ruft der Compiler nicht die Prozedur auf, sondern ersetzt den Aufruf mit dem Körper der Prozedur. \footcite[Vgl.][]{optionsstmt} Diese sogenannte Inline-Expansion ist eine Optimierungsanweisung an den Compiler. Mit diesen Optionen kann der PL/I-Programmierer direkten Einfluss auf die Kompilierung des PL/I-Programms nehmen.

In Java wird der Java-Quellcode und häufig aufgerufene Methoden durch die Inline-Expansion der \ac{JIT} optimiert.

Entsprechend existiert derselbe Optimierungsschritt auch in Java, kann jedoch nur bedingt beeinflusst werden. Die Deaktivierung dieser Optimierung würde zu einer Manipulation der Arbeitsweise des Java-Compilers führen. Es ist fraglich, ob eine solche Anpassung sinnvoll ist, da der Java-Compiler selbst entscheidet, welche Methoden durch die Inline-Expansion optimiert werden sollen. Ein Eingriff entspricht für \verb+javac+ im Allgemeinen keinem Optimierungsprozess.
Aus diesem Grund wird in der Version des Transpilers die Übersetzung dieses Ausdrucks nicht weiter berücksichtigt.


Um nun einen tatsächlichen Programmfluss zu realisieren, sollte der Transpiler ebenfalls in der Lage sein die definierten Routinen auch aufzurufen.
In dem nachfolgenden Paragraf wird die Umwandlung des Aufrufen von Prozeduren beschrieben.
\pagebreak
\paragraph{Umwandlung des Programmablaufs}

In PL/I werden Prozeduren unter anderem mithilfe des \verb+CALL+ Statements aufgerufen. \footcite[Vgl. ][S.133ff. ]{pliref} Um einen Programmfluss, wie er auch in einem nativen Java-Programm vorhanden ist zu erzeugen wird der Call-Ausdruck in einen Methoden-Aufruf transformiert. 
So ergibt sich die Übersetzung aus Listing \ref{lst:callstatement}.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Prozeduraufruf}, label={lst:callstatement}]
	main_proc: PROC;
		CALL proc_1;
	END main_proc;
		
	proc_1: PROC;
		CALL proc_2;
	END proc_1;
		
	proc_2: PROC;
		CALL proc_1;
	END proc_2;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	public void main_proc(){
		proc_1 ();
	}
		
	public void proc_1(){
		proc_2 ();
	}
		
	public void proc_2(){
		proc_1 ();
	}
	\end{lstlisting}
\end{minipage}


Die gleiche Endlosschleife aus PL/I wird somit auch in Java erzeugt.
Dadurch kann ein einfacher Programmablauf von einem PL/I-Programm in ein Java-Programm transformiert werden.
Um nun ein PL/I-Programm wie zusätzlicher Logik zu transformieren, sollten Verzweigungen und Schleifen ebenfalls übersetzt werden.

\pagebreak
\subsubsection{Kontrollflussanweisungen}
\paragraph{Umwandlung von Verzweigungen}

In PL/I werden Verzweigungen mit den Symbolen \verb+IF+ und \verb+ELSE+ implementiert. 
Gepaart mit einem Booleschen Ausdruck kann so ein Wahrheitswert abgefragt werden.
Dabei gibt es Boolesch Operatoren in PL/I die in Java anders repräsentiert werden.
Während in Java ein einfaches Ausrufezeichen eine Negation beschreibt, wird in PL/I das logische Negationszeichen (¬) verwendet. Bei der Transformation wird dieses Zeichen in ein Ausrufezeichen übersetzt.

Weiterhin wird in PL/I ein einzelnes Gleichheitszeichen als logischer Vergleichsoperator verwendet. Da in Java das einzelne Gleichheitszeichen der Zuweisung von Variablen dient, sollte der PL/I-Vergleichsoperator mit den Java-Vergleichsoperator ersetzt werden.

Gleiches gilt für das logische-Und, in PL/I wird lediglich ein Et-Zeichen verwendet. Während in Java zwei als logisches-Und verwendet werden.

Werden diese Zeichen korrekt übersetzt, können Boolesche Ausdrücke in Java überführt werden.
Somit lässt sich der Ausdruck in Listing \ref{lst:branchmapping} in PL/I übersetzen.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Verzweigungen}, label={lst:branchmapping}]	
		IF (var_1 < var_2) THEN;
				ELSE
		END;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
		if(var_1 < var_2){	
			} else {
		}
	\end{lstlisting}
\end{minipage} 

Würden hier erneut der nicht-Primitive Typ, wie das \verb+DECIMAL+ Objekt verwendet, wäre eine solche einfache Vergleichs Operation nicht möglich.
Stattdessen hätten die instanziierten Objekte erst mit einer Art \verb+toNumeric+ Methode in ein Numerisches Format umgewandelt werden müssen.
Was erneut zu mehr Quellcode als nötig führen würde.

Neben den Verzweigungen kann zusätzliche Logik eines Programms auch durch eine Schleife erreicht werden.
Folglich wird die Übersetzung von Schleifen dargestellt.
\pagebreak
\paragraph{Umwandlung von Schleifen}
In PL/I wird in der aktuellen Version des Transpilers, die  While- und Until-Schleife übersetzt.
Weitere Schleifen wie die etwa die \verb+UPTHRU+ oder \verb+DOWNTHRU+ wurden in dieser Version nicht implementiert.

Da Java ebenfalls eine While-Schleife implementiert, kann diese als Übersetzungsmuster verwendet werden.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={While-Schleife}, label={lst:whilecomamnd}]
		DO WHILE(var_1 < var_2);
		END;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
			while(var_1 < var_2){
			}
	\end{lstlisting}
\end{minipage} 

Listing \ref{lst:whilecomamnd} zeigt eine einfache While-Schleife in PL/I.
Dabei wird in PL/I das Symbol \verb+DO+ nicht wie in Java für eine Do-While
Schleife verwendet, sondern leitet lediglich einen Schleifen-Ausdruck ein.

Wird nun in PL/I eine \verb+UNTIL+ Beschränkung definiert, wie etwa in Listing
\ref{lst:untilwhile}.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={While-Until-Schleife}, label={lst:untilwhile}]
		DO 
		  WHILE(var_1 < var_2) 
		  	UNTIL(var_1 = var_2);
		END;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
		while (var_1 < var_2) {
			do {
			} while(!(var_1 == var_2));
		}
	\end{lstlisting}
\end{minipage} 

Sollte in Java eine äquivalente Abbruchbedingung erzeugt werden, wurde in der aktuellen Version des Transpilers das Einfügen einer do-while-Schleife gewählt. Die eigentliche Until-Bedingung wird negiert, um eine zusätzliche Abbruchbedingung zu definieren. 
Da in Java kein Muster existiert, welches das äquivalent zu dem \verb+UNTIL+ bietet, ist die Definition einer zusätzlichen Verzweigung mit der do-while-Schleife.

%Weiterhin ist auch die Position der Verzweigung fraglich. Genauso kann die Abbruchbedingung im Fuß der Schleife definiert werden. Dieser Umstand führt zu einer weiteren Iteration des Schleifenkörpers. 

%Da in PL/I die Bedingung jedoch am Schleifen-Kopf definiert wird, wurde in Java eine Prüfung des Abbruchbedingung ebenfalls im Kopf implementiert. 

Um nun neben einem einfachen Programmablauf, zusätzlicher Logik eines Programms auch Ein- und Ausgabe Operationen von dem PL/I-Quellcode in den Java-Zielcode übersetzen zu können, wird in dem nachfolgenden Kapitel sowohl die Konsolen, als auch die Datei Ein- und Ausgabe diskutiert.

\pagebreak
\subsubsection{Ein- und Ausgabe Befehle}
\paragraph{Konsolen Ein- und Ausgabe}
Um eine Benutzerinteraktion zu ermöglichen wird der Display-Ausdruck transformiert.
In PL/I gibt es sowohl die Möglichkeit mit dem Display-Ausdruck eine Text-Nachricht in der Konsole auszugeben, sowie eine Benutzereingabe abzufragen. \footcite[Vgl. ][S. 264ff.]{pliref}

In Java gibt es verschiedene Implementierungen einer Umleitung der Ausgabe in die Konsole.
Die gängige Methode ist die Verwendung des Ausdrucks \path{System.out.println()}. 
Alternativ könnte auch die Methode \verb+log.trace+ verwendet werden.
Jedoch wird hier eine Abhängigkeit zu der Software-Bibliothek \verb+logger+  erzeugt, weshalb sich gegen diese Methode entschieden wurde.
Eine weitere Alternative würde der \verb+PrintWriter+ bieten, hierbei müsste jedoch zuerst das Objekt \verb+PrintWriter+ erzeugt werden, was zusätzlichen Quellcode erzeugen würde. Diese könnte mit der Implementierung des Sysout-Befehls vermieden werden.
Somit wurde mit dem Sysout-Befehl die gängige Methode gewählt. Entsprechend wird der Ausdruck in Listing \ref{lst:display} übersetzt.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Standardausgabe}, label={lst:display}]
	DISPLAY
	('Hello World');
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	System.out
	.println("Hello World");
	\end{lstlisting}
\end{minipage} 


Um den Display-Ausdruck ebenfalls für das einlesen von Benutzereingaben zu verwenden, wird an den bekannten Display-Ausdruck ein \verb+REPLY+ angefügt. Siehe Listing \ref{lst:displayreply}.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Standardeingabe}, label={lst:displayreply}]
		DISPLAY('Username') 
		REPLY(username)
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	username = 
	System.console().readLine(); 
	\end{lstlisting}
\end{minipage} 

In dem Beispiel in Listing \ref{lst:displayreply} wird die Benutzereingabe in der
Variable \verb+username+ gespeichert.
In PL/I kann die Benutzereingabe nur in einen Bit, Widechar, oder Char gespeichert
werden. 
In Java gibt es verschiedene Lösungen um die Benutzereingabe Abzufragen.
Einerseits über das Scanner oder BufferedReader Objekt.
Jedoch würden beide Lösungen eine Instanziierung der zugehörigen Objekte benötigen und ebenfalls mehr Zeilen Quellcode inanspruchnehmen als nötig.

Stattdessen wird das System Objekt verwendet, welches auch bei der \verb+System.out.println+ verwendet wurde.
Mit \verb+System.console.readLine()+ wird die Benutzereingabe gelesen.
Damit das übersetze Programm neben der Konsole, auch auf das Dateisystem zugreifen kann, wird ebenfalls die Ein- und Ausgabe von Dateien integriert.

\paragraph{Datei Ein- und Ausgabe}
In PL/I gibt es die Möglichkeit über des \verb+READ+-Statement Dateien von dem Dateisystem einzulesen.
In Kapitel 1.1 wurde bereits erwähnt das PL/I-Programme hauptsächlich auf einem Mainframe-System ausgeführt werden.
Auf einem z/OS Betriebssystem wird das Dateisystem \ac{zfs} verwendet.
Hier werden anders als bei herkömmlichen \ac{hfs} Ordner als Datasets und Dateien als Records gespeichert.
Ein Record kann dann von einem Programm, wie einem PL/I-Programm gelesen werden.

Ein PL/I Programm kann einen Record verarbeiten, sowie Ausgaben. In Java ist es gewöhnlich den Dateipfad der zu verarbeitenden Datei über einen gespeicherten Pfad einzulesen.
In PL/I werden spezfische Dateien über die Batch-Verarbeitung definiert, weshalb im Quellcode selbst keine Referenz zu dem eigentlichen Record gegeben ist.

Um den durch die Batchverarbeitung definierten Record in einem PL/I-Programm zu verwenden, kann der Datentyp \verb+FILE+ in Listing \ref{lst:plifiletyp} definiert werden.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Dateityp}, label={lst:plifiletyp}]
	DCL file_1 
	FILE;
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	public File file_1
	= new File("");
	\end{lstlisting}
\end{minipage}  

Bei dem Typ FILE handelt es sich um einen Buffer in dem der Inhalt einer Datei gelesen und für weitere Programmroutinen verfügbar wird. \footcite[Vgl. ][ S.305ff. ]{pliref}

In Java existiert ein ähnlicher nicht-primitiver File-Typ.
Java liest mit der Klasse File eine Datei direkt vom Betriebssystem ein und speichert den Inhalt in einem Buffer. 
Hingegen besteht in Java kaum die Möglichkeit dabei direkt zu beeinflussen wie die Datei eingelesen werden soll. 


Bezüglich Listing \ref{lst:plifiletyp} ist anzumerken das bisher lediglich ein File-Objekt instanziiert wurde.
Es wurde kein Pfad übergeben und somit auch keine Datei eingelesen. 
Die Ausführung dieses Java-Codes wird zu einer Input-Output-Exception führen, da kein Pfad zu einer Datei übergeben wurde.

Hier ist die eigentliche Übersetzung des PL/I-Programms abhängig von der Betriebssystemumgebung, in der das Java-Programm ausgeführt werden soll.

Für den Transpiler ist ohne die Referenz auf die Batch-Verarbeitung eine Einbindung des Dateipfades nicht möglich.

Entsprechend wird in dieser Version des Transpilers dem Benutzer die Verantwortung übergeben, die Referenz zu den ursprünglichen Eingabedateien herzustellen.

In PL/I wird mit einem \verb+READ+-Ausdruck die definierte Datei gelesen und kann in einer Alphanumerischen-Variable gespeichert werden.
Ein mögliches \verb+READ+-Statement aus einem PL/I-Programm ist in Listing \ref{lst:pliread} dargestellt.

Hierbei wird die in Listing \ref{lst:pliread} definierte Datei gelesen.
Transformiert wird diese Dateieingabe mit dem Scanner Objekt.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Dateieingabe}, label={lst:pliread}]
		READ FILE(file_1) 
		INTO (var_1); 
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
		Scanner readFile
		= new Scanner(file_1);
	\end{lstlisting}
\end{minipage}  


Mit dem Scanner Objekt kann die definierte Datei nun Wort für Wort in einen String gelesen werden.

Neben dem einlesen kann ein PL/I-Programm auch mit dem \verb+WRITE+ Befehl in eine Datei schreibe.
Auch hierbei ist zu erwähnen das die eigentliche Steuerung der Ausgabe durch das Batch-Programm vorgenommen wird.
Es wird in der Buffer, der vorher definierten Variable des Typs \verb+FILE+ benutzt um in die Datei bzw. den Record
des Datasets zu schreiben. Dabei wird wie in diesem Fall der Inhalt des Strings \verb+var_1+ gelesen und entsprechend
in den Buffer geschrieben.
Die Übersetzung des PL/I-Quellcode führt zu der Ausgabe in Listing \ref{lst:javawriter}.

\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=PL/I,label=SliceExaple}
	\begin{lstlisting}[frame=single, numbers=left, mathescape,%
		caption={Dateiausgabe}, label={lst:javawriter}]
	WRITE 
		FILE (file_1) 
	FROM (var_1);	
	
	\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.48\linewidth}
	\centering
	\lstset{language=Java,label=SliceExaple}
	\begin{lstlisting}[frame=single, mathescape,%
		title={" "}]
	BufferedWriter writer 
	= new BufferedWriter
	(new FileWriter(file_1)); 
	writer.write(var_1);
	\end{lstlisting}
\end{minipage}  

Hierbei wird ein \verb+BufferedWriter+-Objekt erzeugt, dem ein \verb+FileWriter+ übergeben wird. Dies ist eine mögliche Methode, um in Java eine Datei mit Inhalt zu füllen. Ähnlich wie bei der Standardeingabe können auch weitere Objekte aus ausgewählten Java-Bibliotheken verwendet werden, wie etwa der \verb+FileWriter+, \verb+PrintWriter+ oder beide in Kombination mit dem \verb+DataOutputStream+-Objekt. Es wurde sich hier für den \verb+BufferedWriter+ entschieden, aufgrund der damit verbunden Reduktion des Programmcodes. Bei den anderen Lösungen werden mehr als zwei Objekte für das Schreiben in die Datei benötigt.

Zusammenfassend werden so die grundlegenden Anweisungen der Programmiersprache PL/I in Java übersetzt. Um die Richtigkeit der Übersetzung und des Übersetzungsprozesses zu bestätigen, wurden Unit-Tests definiert. Wie in Kapitel ?.? eingeführt, wurde das Test-Framework JUnit verwendet. Im folgenden Kapitel soll die Integration von neuen Übersetzungs-Routinen beschrieben und die dazugehörigen Tests gezeigt werden.

\pagebreak
\subsection{Test und Integration}
\subsubsection{Unit-Tests}

Um die in Kapitel 3.2 beschriebenen Übersetzungen zu testen, wurden Unit-Tests geschrieben. 
Diese Unit-Tests testen auf der Basis bisher vorgestellter Übersetzungen den Transpiler.

Allgemein erfolgt die Integration von weiteren Übersetzungsstrategien durch die Test-Diven-Development-Vorgehensweise. Somit war während der Entwicklung des Transpilers ein Unit-Test der erste Schritt. Daraufhin folgt die Implementation der Programmroutinen, um den PL/I-Quellcode in einen Java-Zielcode zu übersetzen.
Beispielhaft ist in Listing \ref{lst:javaunittest} eine Test-Methode für das Transformieren von Variablen dargestellt.

\begin{lstlisting}[language=Java, caption=Arithmetic Node Unit-test, label={lst:javaunittest}]
@Test
void mapChildNodes_checkIdentifierMapping() {
	
	DeclarationMapper declarationMapper = new DeclarationMapper();
	String decimalExpression = 
		 "test_1_package: PACKAGE;" 
	   + "	DCL var_3 FIXED DECIMAL(5);" 
	   + "END test_1_package;";
	
	InputStream stream = new ByteArrayInputStream
	(decimalExpression
	.getBytes(StandardCharsets.UTF_8));
	
	Pl1Parser pl1parser = new Pl1Parser(stream);
	SimpleNode varNode = pl1parser.program().jjtGetChild(0)
	.jjtGetChild(1);
		
	declarationMapper.mapChildNodes(varNode);
	declarationMapper.mapArithmetic
	((SimpleNode)varNode
	.jjtGetChild(1).jjtGetChild(0));
		
	assertEquals("var_3", declarationMapper.getIdentifier());
	assertEquals("@Decimal(5) double", declarationMapper.getType());
}
\end{lstlisting} 

% Test-Coverage
In Listing \ref{lst:javaunittest}  wird der Typ \verb+DECIMAL+ getestet. Untersucht werden der resultierende Typ und Bezeichner, die durch die Methoden \verb+mapChildNodes+ und \verb+mapArithmetic+ gesetzt werden.

Es wird erwartet, dass der Bezeichner der PL/I-Variable dem Inhalt der Variable \verb+identifier+ der Klasse \verb+DeclarationMapper+ entspricht.
Weiterhin wird erwartet, dass der Typ \verb+DECIMAL+ zu dem entsprechenden Typ aus Listing \ref{lst:annotationdecimal} übersetzt wird.
Mit jedem Test wird auch ein Parser-Objekt erzeugt, dadurch wird  mit einem Unit-Tests die geschriebene Grammatik überprüft.
Ähnlich wurden  für die weiteren Mapper-Klassen Test-Klassen erzeugt.
Für die restlichen Module, wie etwa der Symboltabelle, wurden ebenfalls Tests geschrieben.
Da die Symboltabelle bereits in der Version der Projektarbeit-IV integriert war, wurden hier  Tests nachträglich geschrieben. 

%Negative Tests
Bei der Implementierung der Tests wurden sowohl Negativ- als auch Positivtests geschrieben.
In Listing \ref{lst:javaunittest} handelt es sich um einen Positiven Test. 

Da die Methode \verb+mapArithmetic+ speziell für die Übersetzung von numerischen Typen geeignet ist, sollte die Methode eine Fehlermeldung ausgeben, wenn eine Übersetzung von einem alphanumerischen Datentyp verlangt wird.  In Listing \ref{lst:javanegativetest} wird dieser Umstand getestet. 

\begin{lstlisting}[language=Java, caption=Arithmetic Node Unit-test, label={lst:javanegativetest}]
@Test
void mapArithmetic_NegativeTest() {
	DeclarationMapper declarationMapper = new DeclarationMapper();
	
	String decimalExpression = 
	"test_1_package: PACKAGE;" 
	+ "	DCL var_3 CHAR(5)" 
	+ "END test_1_package;";
	
	InputStream stream
	= new ByteArrayInputStream(decimalExpression
	.getBytes(StandardCharsets.UTF_8));
		
	Pl1Parser pl1parser = new Pl1Parser(stream);
	SimpleNode program = pl1parser.program();
	SimpleNode varNode = 
	(SimpleNode) program
	.jjtGetChild(0)
	.jjtGetChild(1);
		
	assertThrows(TypeMappingException.class, () -> 
	{
		declarationMapper.mapArithmetic(
		(SimpleNode)varNode.jjtGetChild(1).jjtGetChild(0)
		);
	});
}
\end{lstlisting}

Auch für die restlichen Test-Klassen wurden diese Negativtests ebenfalls implementiert. 
Weiterhin wurden sowohl Negativ- als auch Positivtests für alle weiteren Mapper-Klassen geschrieben. Für Ausdruck \ref{lst:pliarithmeticexpression} ist der Test im Anhang \ref{lst:pliarithmeticexpression_test} dargestellt. Ebenso gilt dies für die folgenden:

\begin{itemize}
	\item Für Listing \ref{lst:procchar} in Anhang \ref{lst:procchar_test}
	\item Für Listing \ref{lst:callstatement} in Anhang \ref{lst:callstatement_test}
	\item Für Listing \ref{lst:branchmapping} in Anhang \ref{lst:branchmapping_test}
	\item Für Listing \ref{lst:untilwhile} in Anhang \ref{lst:untilwhile_test}
	\item Für Listing \ref{lst:displayreply} in Anhang \ref{lst:displayreply_test}
	\item Für Listing \ref{lst:javawriter} in Anhang \ref{lst:javawriter_test}
\end{itemize}

Zusammenfassend wurden so die kleinsten Programm-Einheiten des Transpilers überprüft. Um nun die einzelnen Module mit ihren Klassen zu testen, wurde ein Integrations-Test durchgeführt. Die Protokollierung wird im nächsten Kapitel beschrieben.

\pagebreak
\subsubsection{Integrationstests}
In diesem Kapitel wird die Durchführung eines Integrations-Tests aller Komponenten beschrieben. Der Integrations-Test beschreibt, wie der Transpiler benutzt und durch den Java-Compiler kompiliert werden kann.
In diesem Kapitel wird die vollumfängliche Implementation des Transpilers, mit dem Frontend und der zum Kompilieren benötigte Codebase protokolliert. Dazu wird ein Beispiel PL/I-Programm übersetzt. Für die Berechnung einer Primzahl wurde hier der Probedivisions-Algorithmus implementiert. In Anhang \ref{lst:pliprobedivision} ist die Implementation des Algorithmus in PL/I zu sehen. Dieses Programm soll während des Integrations-Tests in Java-Zielcode übersetzt und durch den Java-Compiler kompiliert werden.
Eine Ausführung des Algorithmus ist nicht vorgesehen, lediglich die Transformation und Kompilieren durch den PL/I-Transpiler sowie des Java-Compilers
soll getestet werden.

Die Hardware-Spezifikationen des Systems, auf dem der Integrations-Test durchgeführt wird. Sind in Tabelle \ref{tab:hardwartable} beschrieben.

\begin{table}[h]\label{tab:hardwartable}
	\centering
	\begin{tabular}[h]{|l|l|l|}
		\hline
		\textbf{Spezfikation} & \textbf{Beschreibung}  \\
		\hline
		Betriebssystem & Ubuntu 20.04.6 LTS x86_64 \\
		\hline
		Kernel & 5.15.0-113-generic  \\
		\hline
		CPU & Intel i3-9100F (4) @ 3.600GHz \\
		\hline
		GPU & NVIDIA GeForce GTX 970  \\
		\hline
		Arbeitsspeicher & 8217MiB / 15932MiB \\
		\hline
		
	\end{tabular}
	\caption{Hardwarespezifikation des Test-Systems}
\end{table}

Das System verwendet die Version 17.0.11 des Java-Compilers. Sowie Version 5.0 des Parser-Generators-JavaCC und Apache Maven der Version 3.6.3.

% Transpiler aus Github Repo holen
Der Integrationstest beginnt damit, das Transpiler-Projekt aus dem Remote-Repository zu laden.

\begin{lstlisting}[language=Bash, caption=Laden des Transpilers, label={lst:inttest1}]
git clone -b integration https://github.com/lhahner/pl1-code-transpiler.git
\end{lstlisting} 

Es wird in das Projektverzeichnis des Transpilers navigiert. Worauf hin die JAR-Datei mit dem Maven-Kommando in \ref{lst:inttest2} Listing erzeugt wird.

% Transpiler kompilieren
\begin{lstlisting}[language=Bash, caption=Erzeugen der JAR, label={lst:inttest2}]
mvn install
\end{lstlisting}

% Frontend aus Github repo holen
Jetzt kann das Projekt in das Frontend eingebunden werden. Dazu wird erneut das Frontend-Projekt aus dem Remote-Repository geladen. In Listing \ref{lst:inttest3} ist der Befehl dazu gelistet.

\begin{lstlisting}[language=Bash, caption=Laden des Frontend-Projekts, label={lst:inttest3}]
git clone https://github.com/lhahner/plitra-web.git
\end{lstlisting}

% Server stareten
Nun wird in die Projektstruktur des Frontendprojektes navigiert. Der Spring-Boot-Server wird lokal mit dem Befehl in Listing \ref{lst:inttest4} gestartet.

\begin{lstlisting}[language=Bash, caption=Starten des Spring-Boot-Servers, label={lst:inttest4}]
mvn spring-boot:run
\end{lstlisting}

Die Adresse \path{http://localhost:8080/} wird in Firefox geöffnet. Es wird über den "Transpile"-Button auf die Seite \path{http://localhost:8080/trans} navigiert. Hier wird in das linke Testfeld der PL/I-Quellcode aus Anhang \ref{lst:pliprobedivision} eingefügt. In Anhang \ref{lst:javaprobedivision} ist das Ergebnis, welches auf der linken Seite ausgegeben wurde, dargestellt.

% Code base Repository aus Github holen
Um nun das ausgegebene Projekt zu kompilieren, sollte eine bereitgestellte Code-Basis verwendet werden. Es wird das Code-Basis-Projekt aus der Remote-Repository in Listing \ref{lst:inttest5} geladen.

\begin{lstlisting}[language=Bash, caption=Laden der Code-Basis, label={lst:inttest5}]
git clone https://github.com/lhahner/plitra-codebase.git
\end{lstlisting}

% Code integration des Übersetzen Codes in Repositry
Der Code innerhalb der Klasse aus Anhang \ref{lst:javaprobedivision} wurde kopiert und in die Klasse TranspiledExamplePliProgram eingefügt. Dazu wurde in den Ordner \path{/src/main/java/org/plitra/codebase} innerhalb des Codebasis-Projektes navigiert und mit Eclipse der Java-Zielcode eingefügt.

% kompilieren des Übersetzen Codes
Das Casten des Parameters wird aktuell nicht unterstützt, weshalb der Objekttyp händisch
in \verb+double+ geändert wurde. Weiterhin wurden alle Fehler, die von der \ac{IDE} erkannt wurden, automatisch durch das Akzeptieren, des Änderungsvorschlags der  \ac{IDE}  verbessert.
Das Projekt wird nun erneut mithilfe des in Listing \ref{lst:inttest6} dargestellten Maven-Kommandos kompiliert.

\begin{lstlisting}[language=Bash, caption=Kompilieren des Projekts, label={lst:inttest6}]
mvn install -Dmaven.test.skip=true
\end{lstlisting}

Das Projekt wurde erfolgreich kompiliert, womit der Integrations-Test erfolgreich war.

Um nun weitergehend auch die Laufzeit des Java-Zielcodes zu überprüfen,
wird in dem nächsten Kapitel die Performance des PL/I-Quellcodes und des Java-Zielcodes überprüft und verglichen. 
\pagebreak

\subsection{Performance und Benchmarks}
Um vergleichen zu können, wie sich die Laufzeit der Implementierung des Probedivisions-Algorithmus in PL/I und Java unterscheidet, wird in diesem Kapitel die Performance verglichen. 
Dazu wird den Beiden Programmen die Primzahl 2.147.483.647 übergeben.
Für die Berechnung wurde das Programm aus dem Anhang \ref{lst:pliprobedivision}, auf einem z/OS-Mainframe-System kompiliert und ausgeführt. 
Die allgemeinen System-Spezifikationen des Mainframes sind in Abbildung \ref{fig:mainframesysteminfo} dargestellt.

\dhgefigure[h]{mainframe-system-info.png}[scale=0.47]{Mainframe System Informationen}{fig:mainframesysteminfo}[][]

Unter CPU ist der Maschinen-Typ 3931 gelistet. Bei dem Mainframe, handelt es sich um einen IBM z16 A02, mit
einer maximalen Prozessorkern Kapazität von 16. Sowie Maximal 4 TB Arbeitsspeicher. (IBM z16 Model A02, S. 1, https://www.ibm.com/downloads/cas/EGJE0PGO)
Damit wird das Programm auf der neusten Hardware von IBM kompiliert und ausgeführt.

% PL/I-Benchmark Test mit System Spezifikationen
Um ein PL/I-Programm auf einem z/Os Betriebssystem eines IBM-Mainframes zu starten, muss das Programm zuerst erfolgreich kompiliert und mit einem Batchjob-Programm
ausgeführt werden. Das Batchjob-Programm wurde in der Job-Control-Language (JCL) geschrieben.
Der Batch-Job ist neben dem ausführen des Programms, auch verantwortlich für die Ein- und Ausgabesteuerung des Programms.
Wie schon in Kapitel 3.2 angemerkt, werden in dem PL/I-Quellcode selbst keine Dateipfade angegeben, lediglich in dem JCL-Job sind die benötigten Dateien angegeben.

% Ab hier erstmal hypothetische annahme
Ein Vergleichbarer Job der ein PL/I-Programm ausführt weißt eine Laufzeit von 2 Millisekunden auf, in Abbildung \ref{fig:joblogs}
ist das Ergebnis des Log-Programms zu sehen.

\dhgefigure[h]{job-logs.png}[scale=0.47]{Job Logs z/Os}{fig:joblogs}[][]

Bei diesem Job wurden mehr als 2 Milliarden Datensätze verarbeitet, was diesen Job ungefähr vergleichbar
mit der Berechnung der Primzahl 2.147.483.647 macht. Dabei ist jedoch anzumerken, das in dieser Verarbeitung
auch die Ein- und Ausgabesteuerung mit in die Performance einspielen. Weiterhin ist ungewiss, welche Ressourcen 
zur Bearbeitung des Jobs verwendet wurden. Weiterhin wird davon ausgegangen das dieser Job nicht bei einer Vollauslastung lief.

% Java-Benchmark Test mit System Spezifikationen
Das während des Integration-Test übersetzte Programm aus Anhang \ref{lst:javaprobedivision} wird ebenfalls für die Berechnung der Primzahl
2.147.483.647 getestet.
Das Programm wurde insgesamt 6 mal ausgeführt und erzielte dabei eine durchschnittliche Laufzeit von 1.44 Sekunden.
Während der Laufzeit nahm das Programm 8 Kerne und 0,132 GB Arbeitsspeicher inanspruch.
Somit auch hier nicht bei der Vollauslastung des System.

% Umrechnung & Vergleich
Um nun die Verarbeitung Vergleichbar zu machen sollte die Laufzeit umgerechnet werden.
Der z16 hat viermal so viele Kerne wie der Rechner auf dem das Java Programm ausgeführt wird.
Weiterhin hat der z16 umgerechnet 32.000 Gigabit Arbeitsspeicher (4TB * 8000 = 32.000).


\section{Fazit}
