%--> Je Subsection Punkt Fragen formulieren.

%-------------------------------------------
% HEADER

% Roterfade der Einleitung:

% 1. Problem -> Kompatibilität
% 2. Ziel -> Lösung mit Übersetzungsprogramm
% 3. Abgrenzung Interpreter & Compiler -> Übersetzungsprogramm als Transpiler
% 4. Formale Grammatike -> Formale Grammatik als Vorrausetzung des Transpilers
% 5. JavaCC -> Implementierung der Formalen Grammtik mit JavaCC und damit des Transpilers

%-------------------------------------------

\section{Theoretische Grundlagen}
\subsection{Problemstellung}
	
Es gibt zwei Probleme die eine PL/I zu Java Übersetzung lösen soll. 
Einerseits ein Portabilitätsproblem von PL/I-Programmen, die auf modernen Plattformen laufen sollen, wie etwa Cloud-Instanzen, oder Linux-Server. Andererseits die mit einem hohen Aufwand verbundene Wartung von bestehenden PL/I-Programmen. 
	
Die bestehende Auswahl von PL/I Compilern führen zu einem Portabilitätsproblem. Der PL/I Compiler, der auf den meisten Computer-Systemen im Einsatz ist, wird von IBM entwickelt und vermarktet. Hierbei handelt es sich um einen Compiler der für, dass von IBM entwickelte Betriebssystem z/Os geschrieben wurde. Eine Kompilierung von PL/I auf einem herkömmlichen x86-Desktop Computer oder ähnlichen ist mit diesem Compiler nicht möglich. \footcite[Vgl. ][]{plicomp}


Eine mögliche Alternative bietet die Organisation GNU mit der \ac{GCC}. Der Softwareentwickler Henrick Sorensen entwickelte Teile des Frontends für einen PL/I Compiler. Dabei verwendete er das Backend, dass die \ac{GCC} zu Verfügung stellt. Jedoch gab es bei diesem Projekt seit 2007 keine weiteren Neuerungen mehr. Der Entwickler gibt an, das bisher keine Zwischencode Erzeugung stattfindet, was diesen Compiler bisher unbrauchbar macht. \footcite[Vgl. ][]{pligcc} 
Heutzutage ist die gängige Möglichkeit, ein IBM 3270 Terminal zu emulieren, das eine Verbindung zu einem z/Os System herstellt, um den PL/I Code auf diesem zu kompilieren.


Neben technischen Problemen, existiert auch ein Personalproblem. PL/I ist eine Altsprache, die seit den 1960er Jahren im Einsatz ist und durch den Generationenwechsel an Entwicklern verliert. Wartung und Entwicklung werden so häufig schwer und teuer.\footcite[Vgl. ][S. 227ff.]{histopli} 

Java hingegen ist auf nahezu allen modernen Systemen durch die plattformunabhängige Java Virtual Machine (JVM) kompilierbar. \footcite[Vgl. ][]{jvm}
Insbesondere ist eine Kompilierung auch auf einem IBM-Großrechner mit z/Os möglich. \footcite[Vgl. ][]{zos} 
Das macht Java zu einer flexibel einsetzbaren Sprache. 

Weiterhin is Java die mit am meisten verwendete Programmiersprache in der heutigen Zeit. \footcite[Vgl. ][]{tiobe} Das führt zu einer höheren Anzahl an Entwickler, die in der Lage sind Java Programme zu warten.

% Was ist ein Transpiler?
Um die Programmiersprache Java zur Lösung der eingangs beschriebenen Probleme zu verwenden, wird ein Transpiler benötigt, der PL/I-Quellcode in Java-Zielcode übersetzt. Ein solcher Transpiler verarbeitet den Quellcode der Sprache PL/I und generiert daraus entsprechenden Quellcode in der Sprache Java. Dabei hat der Benutzer die Möglichkeit, selbst zu bestimmen, wie bestimmte Ausdrücke übersetzt werden sollen. Sobald der Programmcode in Java übersetzt ist, kann der Java-Zielcode von dem Java-Compiler kompiliert werden und durch die \ac{jvm} ausgeführt werden.

% Weiterführung
Erst ab diesem Punkt ist die Qualität des Transpilers zu erkennen. Faktoren wie Lesbarkeit und Erweiterbarkeit des Java-Zielcodes gehen in die Beurteilung mit ein. 
Die Beurteilung der Qualität des Transpilers ist auch von Zielaspekten der Benutzer abhängig. In dieser Arbeit wurden Zielgruppen definiert die im nachfolgenden Kapitel 1.2 weiter erläutert werden sollen. Diese Zielgruppen sind für weitere Gestaltungsentscheidungen in der Entwicklung des Transpilers wichtig.

% @review: Begriffswahl
In den folgenden Kapiteln wird zwischen dem Transpiler, dem Eingabeprogramm (PL/I-Quellcode) und dem Ausgabeprogramm (Java-Zielcode) unterschieden. Diese Begriffe helfen dabei, die verschiedenen Programme eindeutig zu identifizieren.

%Anderseits auch die veränderte Laufzeit-Performance. Die Laufzeit-Performance kann durch eine Übersetzung verschlechtert, wie auch verbessert werden. Somit ist nicht nur die reine Übersetzung Teil der Problemstellung, sondern es gilt auch die Übersetzung zu beurteilen. 

     

% 	 Welches Problem löst das Programm?
%	 Probleme 
%			 1. Nicht auf jedem System läuft PL/I, besonders nicht auf modernen x86 bzw. Cloud.
%			 2. PL/I ist eine weniger verwendete Sprache, Wartung teuer &  Schwer.

%	 (Hinführung zum Problem:
%	 Historisches Kompatibilitätsproblem -> Nicht auf jedem System lief jede Assambler Sprache, Problem: hoher Aufwand und Unflexibel
% 	 Deshalb -> Compiler mit Hochsprache, der Code für das Backend des Compilers, bspw. C's Gcc Compiler
%    in Assambler Sprache des Systems übersetzt.)? **Hier einen Cross Compiler erklären bzw. im Zusammenhang mit dem Historischen Problem.**

%	 Problem mit PL/I -> Pl/I Compiler rar bzw. nur für Großrechner Systeme vorhanden   
%	 Es gibt zwar einen GCC Pl/I Compiler, dieser wird aber seit 2007 nicht mehr weiterentwickelt. Eine Weiterentwiclung könnte auch Interessant %    sein, löst aber nicht das Problem der teuren Wartung von Programmen in PL/I.

% 	 
%	 Lösungsvorschlag zu 1 -> PL/I zu Java Transpiler bauen Java und JVM relativ System unabhängig und damit Ideale Zielsprache für eine 
%	 hohe Kompatibiltätsrate.Um zum Beispiel Pl/I Programm die auf einem Großrechner laufen auch auf einem x86 On-Prem Server oder einer Cloud
%    zu betreiben. **Hier die Frage klären was ein Transpiler ist**
%	 
%    Lösungsvorschlag zu 2 -> Java ist den großteil der Softwareentwickler bekannt und eine Wartung ist leichter.
%
 \pagebreak
\subsection{Zielsetzung}
% Herleitung von der Problemstellung	
Das Ziel dieser Arbeit leitet sich aus der eingeführten Problemstellung in Kapitel 1.1 ab. Allgemein soll ein plattformunabhängiger Transpiler entstehen, der die  Entwicklung und Transformation von PL/I-Quellcode ermöglicht. Die zugrundeliegende Arbeit stellt die Entwicklung, sowie die Gestaltung der Software dar und diskutiert Gestaltungsentscheidungen. 

% @review: Referenz zur Begriffklärung
% Zielgruppen Zusammengefasst	
Diese Arbeit richtet sich an juniore Anwendungsentwickler in den Sprachen PL/I bzw. Java. Für diese Nutzergruppe soll der Transpiler ein Hilfswerkzeug darstellen. Weiterführend werden diese als Benutzer bezeichnet. Eine andere Nutzergruppe sind Administratoren, die den Transpiler selbst anpassen und erweitern möchten. Ermöglicht wird dies durch eine modulare Architektur.
	
% Junior Entwickler die gerade in PL/1 einsteigen.
Juniore Entwickler profitieren von dieser Arbeit als Einstiegspunkt in die Programmiersprache PL/I. Beispielhaft könnten Entwickler den Transpiler als Test-Umgebung für den eigenen entwickelten PL/I-Quellcode verwenden.

% Lernhilfe
Für Benutzer, die mehr Erfahrung mit Java haben, eignet sich der Transpiler als Lernhilfe. Es wird ihnen so erleichtert, PL/I-Quellcode zu analysieren. Sie können bestehende Kenntnisse aus Java anwenden, um gleiche Muster in PL/I wiederzuerkennen. Dies kann den Lernprozess beschleunigen.

% Benutzbarkeit
Der Transpiler aus der Projektarbeit-IV konnte bisher über die Kommandozeile, sowie der IDE Eclipse verwendet werden. Diese ursprüngliche Benutzung des Transpilers führte zu einer erhöhten Fehleranfälligkeit und Dokumentationsbedarf. Die Komplexität der Benutzung wird durch ein Graphical-User-Inferface (GUI) vereinfacht.
%Das Konzept dieser GUI soll dem eines Übersetzers der natürlichen Sprache, wie etwa 'DeepL' oder 'Google-Translate', ähneln. Mit diesen Konzepten sind Benutzer vertraut, erleichtert den Einstieg in die Programmiersprache PL/I, das Testen des PL/I-Quellcode, sowie die schnelle Übersetzung.

%  Entwickler die das Programm eigenständig erweitern, verändern wollen.
Durch die modularisierte Gestaltung des Transpilers können Administratoren selbst Module austauschen und erweitern, etwa durch eine API-Schnittstelle zu externen Übersetzungsbibliotheken und Services. 

%  Zusammenfassung und hinführung zum nächsten zu dem Unterschied Interpreter und Compiler
Neben den Nebenzielen der unterschiedlichen Zielgruppen, bleibt das Hauptziel die automatisierte Übersetzung von PL/I-Quellcode in Java Zielcode.

Der Transpiler soll eine Transformation der grundlegenden Anweisungskategorien implementieren. Die Variablendeklaration sowie -zuweisung, die Ein- und Ausgabesteuerung und allgemeine Kontrollflussanweisungen werden im Zuge der Entwicklung implementiert. Der entstehende Quellcode ist mit der Verwendung des mitgegebenen Boilerplate-Codes kompilierbar. Weiterhin wird der PL/I-Quellcode nicht vollständig auf seine Korrektheit überprüft. In der entstandenen Version des Transpilers ist die Mitübersetzung von Fehlern denkbar. Nichtsdestotrotz werden syntaktische Fehler und datentypspezifische semantische Fehler erkannt. Entsprechend wird eine Fehlermeldung geworfen und das Programm nicht weiter übersetzt.

Ein Transpiler kann sowohl als Interpreter und als Compiler gestaltet werden. In dem nachfolgenden Kapitel 1.3 werden die Begriffe voneinander abgegrenzt. 
	
% Aufteilung der Zielstellung:
% 1. Allgemein; Ableitung aus der Problemstellung
% 2. Zielgruppen spezfifisch
% 2.1 Einfache und unkomplizierte Lösung
%
% 2.2 Erweiterung des Transpilers bzw. ersetzen von Modulen	
	
% - Wie eine Art JavaScript Minifier oder 
%  Wer ist die Zielgruppe?
%  - Junior Entwickler die gerade in PL/1 einsteigen.
%   - Lernhilfe
%  - Online-Smoketest von PL/I Code
%   - Benutzbarkeit
%   - Entwickler die das Programm eigenständig erweitern, verändern wollen.
 
%  Ziele der Architektur (Zielgruppe Entwickler)
%  - Perspektive des Entwicklers
%  - Perspektive des Benutzers
    \pagebreak

\subsection{Abgrenzung Interpreter und Compiler}
% Wie können Programme ausgeführt werden?
Um das zu entwickelnde Programm von einem Interpreter abzugrenzen, werden in diesem Kapitel die Unterschiede zwischen einem Interpreter und einem Compiler beschrieben. Zusätzlich wird ein Compiler mit einem Transpiler verglichen und Unterschiede dargestellt.
  
% Wie arbeitet ein Compiler?
Ein Compiler besteht aus einem Frontend und einem Backend. Das Frontend umfasst die lexikalische, syntaktische, semantische Analyse und die Symboltabelle.
Das Ergebnis des Frontends ist eine Zwischencodedarstellung, die an das Backend übergeben wird, um daraus Maschinencode zu generieren. Der Maschinencode kann auf dem zugrundeliegenden System ausgeführt werden. \footcite[Vgl. ][S.106ff. ]{aho}
Um weiterhin den Prozess der Übersetzung mithilfe eines Compilers darzustellen, wird Abbildung \ref{fig:compiler} verwendet.

\pagebreak
% @todo: Quelle
\dhgefigure[h]{compiler-ablauf-diagramm.png}[scale=0.75]{Funktionsweise eines Compilers}{fig:compiler}[][]

\pagebreak
Abbildung \ref{fig:compiler} zeigt eine Übersicht und das Ergebnis der einzelnen Compiler-Phasen. Die Abbildung unterteilt den Ablauf wie eingangs beschrieben in Frontend und Backend.

In der ersten Phase teilt der Compiler den eingegebenen String in Tokens auf. Danach entsteht ein Syntaxbaum, der in diesem Beispiel die Zwischencodedarstellung repräsentiert. Ab diesem Punkt beginnt das Backend des Compilers. Zuerst erzeugt das Backend maschinenunabhängigen Code und anschließend maschinenabhängigen Code. Dieser maschinenabhängige Code ist auf dem zugrundeliegenden System ausführbar. \footcite[Vgl. ][S.30 ]{aho}
In jeder Phase wird aus der Symboltabelle gelesen und geschrieben.

%  Warum ein Transpiler?
Neben den Eingangs beschriebenen Compiler, gibt es weitere Lösungen die auf einem ähnlichen Konzept basieren.
Ein One-Pass-Compiler etwa erzeugt keinen Zwischencode, sondern führt den Code direkt aus. Diese Methode wurde angewendet, um Speicherplatz zu sparen, da frühe Computer nur begrenzte Kapazitäten hatten und keine Zwischenergebnisse speichern konnten. Ein Beispiel für eine Sprache, die mit einem One-Pass-Compiler kompiliert wird, ist Turbo Pascal. \footcite[Vgl. ][]{onepass}

Eine weitere Ausprägung ist ein Source-to-Source Compiler.
Während ein C-Compiler den C-Code nach der Zwischencodeerzeugung in Assemblersprache und anschließend der Assembler den C-Quellcode in Maschinencode übersetzt, wandelt ein Source-to-Source-Compiler beispielsweise C-Quellcode in Java-Zielcode um. 
Ein Source-to-Source-Compiler wird im Zusammenhang dieser Arbeit als Transpiler bezeichnet und ist deckungsgleich mit dem entwickelten Programm.

Abbildung \ref{fig:transpiler} zeigt die Prozessschritte eines Transpilers.

\pagebreak
\dhgefigure[h]{transpiler-diagramm.png}[scale=0.75]{Funktionsweise eines Transpilers}{fig:transpiler}[][]
\pagebreak

Ein Vergleich von Abbildung \ref{fig:compiler} mit Abbildung \ref{fig:transpiler} zeigt, dass die ersten Phasen bis zur Zwischencodeerzeugung gleich bleiben. In Abbildung \ref{fig:transpiler} sind jedoch die Prozesse des Frontends neben denen des Backends dargestellt. Während in Abbildung \ref{fig:compiler} diese untereinander angeordnet sind. Zurückzuführen ist diese Darstellung auf die verwendeten Sprachebenen.

Ein Compiler übersetzt den Quellcode einer Hochsprache in eine maschinennahe Sprache wie Assembler. Hingegen bleibt der Transpiler auf der Sprachebene der Quellsprache. In Abbildung \ref{fig:transpiler} werden zudem die Phasen des Backends reduziert, da keine Übersetzung in eine maschinenabhängige Sprache erforderlich ist.

% @review
Ein weiter Unterschied zu einem herkömmlichen Compiler ist die Art der Ausführung des übersetzten Zielcodes.
Das Ergebnis der Übersetzung eines Compilers ist Binärcode der auf einem Zielsystem ausgeführt werden kann. Um hingegen das Ergebnis eines Transpilers auszuführen,
braucht es einen weiteren Compiler. Dieser Compiler muss den Zielcode der Zielsprache in Binärcode übersetzen.
Bei der Übersetzung von PL/I-Quellcode zu Java-Zielcode, bedarf es also einen weiteren Java-Compiler zum ausführen des Zielcodes.

% @review: Cross Compiler? - Hat hier eig nix zu suchen, ist Thema für Boostrapping aber nicht für Transpiler
%Neben den Methoden der Konstruktion, gibt es auch unterschiedliche Verwendungen von Compilern. 
%Etwa existiert der Begriff der Cross-Kompilierung. Hierbei handelt es sich um die Möglichkeit einen Compiler, der sich auf einem externen Computersystem befindet zu verwenden um den Quellcode auf dem lokalen System in Binärcode zu übersetzen. \footcite[Vgl. ][]{guncross}

%Diese Verwendungsweise findet etwa Anwendung beim Bootstrapping. Liegt auf dem System noch kein Compiler für die Sprache vor, in der der Kernel geschrieben wurde, wird diese Methode verwendet um den Kernel-Code zu kompilieren. 
%In dieser Arbeit kommt ein solcher Ansatz bedingt zum Einsatz. Wird der Transpiler in einem Webinterface verwendet, ist die Verhaltensweise ähnlich.
%Da auch hier der Compiler auf einem anderen Host-Computer, den lokalen Quellcode übersetzt.

Zusammenfassend übersetzen sowohl One-Pass-Compiler, Transpiler bzw. Source-to-source Compiler als auch herkömmliche Compiler das Programm basierend auf einer Zwischencodeerzeugung. \footcite[Vgl. ][S. 18ff. ]{assambly}
Eine Alternative ist der Interpreter. Dieser führt den Quellcode direkt Zeile für Zeile aus.

% Wie arbeitet ein Interpreter?
Im Vergleich zu einem Compiler hat der Interpreter weder ein Frontend noch ein Backend. Es gibt keine klare Trennung zwischen einem Frontend, das eine unabhängige Repräsentation des Codes erzeugt, und einem Backend, das diese Repräsentation interpretiert. 

Ein Interpreter wird etwa durch die Shell verwendet um Benutzerbefehle zu verarbeiten. 
In Abbildung \ref{fig:shell} ist der Verarbeitung des Bash Interpreters dargestellt.


\dhgefigure[h]{shell_interpreter.png}[scale=0.75]{Ablauf der Interpretation eines Shell Programms}{fig:shell}[][]
\pagebreak

Die Eingabe des Bash-Skripts wird zeilenweise gelesen.
Das Quoting folgt dem Prinzip der lexikalischen Analyse, bei der alle Sonderzeichen entfernt werden, wie zum Beispiel Kommentare oder Backslashes. Sobald das Quoting abgeschlossen ist, entsteht ein String, der nur aus den Tokens eines Ausdrucks besteht.

Anschließend beginnt das Parsing, das der syntaktischen Analyse im Kompilierprozess ähnelt, jedoch keine Zwischencodeerzeugung beinhaltet. Hier wird lediglich zwischen einfachen Bash-Befehlen wie \verb+wc+ und zusammengesetzten Befehlen wie einem \verb+if+-Ausdruck unterscheiden.

Der Verarbeitungsprozess setzt sich mit der Shell-Expansion fort, bei der in einem Befehl eingebettete relative Ausdrücke durch ihre absoluten Repräsentationen ersetzt werden.
Ab hier nimmt nun das Betriebssystem die Befehle des Shell-Skriptes entgegen und führt das entsprechende Programm aus.
Schließlich wird das Ergebnis in der Kommandozeile ausgegeben. \footcite[Vgl. ][]{gnubash}

% Absatz: Zusammenfassende Unterscheidung zwischen Interpreter und Transpiler, Was sind gemeinsamkeiten und unterschiede von Transpiler und interpreter?

Zusammenfassend zeigen sich sowohl Ähnlichkeiten als auch Unterschiede zwischen einem Interpreter und einem Compiler bzw. Transpiler. Beide durchlaufen die Phasen der lexikalischen und syntaktischen Analyse, wobei sie den Quellcode zunächst um Kommentare, Leerstellen oder andere für die Übersetzung irrelevante Symbole bereinigen. Anschließend erfolgt entweder die direkte Übersetzung des Quellcodes oder die Erzeugung einer unabhängigen Repräsentation.

Um PL/I-Code korrekt in Java zu übersetzen, sind Verbindungen zwischen den Ausdrücken relevant. Eine zeilenweise Übersetzung könnte zu einem Java-Programm führen, das den restlichen Kontext des Programms nicht weiter berücksichtigt. Der Transpiler sollte eine solche Repräsentation berücksichtigen können.

Um eine Zwischencodeerzeugung zu generieren wird ein Frontend benötigt. Wie schon in den Abbildungen \ref{fig:transpiler} dargestellt sind die ersten Arbeitsschritte des Frontends die lexiklaische und syntaktische Analyse. Für beide Prozessschritte werden ein Parser und Lexer benötigt. Mit einem Compiler-Compiler können automatisiert Programme erzeugt werden die einen PL/I-Quellcode in eine Zwischencodedarstellung transformieren.
Das folgende Kapitel beleuchtet Grammatiken formaler Sprachen wie PL/I und Java genauer um auf die Verwendung eines Compiler-Compilers vorzubereiten.
% Der entscheidende Unterschied liegt darin, dass der Interpreter den Quellcode lediglich zeilenweise direkt übersetzt, während der Compiler das Programm in eine andere Form transformiert und liest. Dabei stehen die verwendeten Ausdrücke des Eingabecodes in Beziehung zueinander, beispielsweise durch die Verschachtelung von Verzweigungen und Schleifen.



% - Erweiterung des Umfangs während der Laufzeit
% - Trennung Laufzeit/Konzeptionsphase

% - Hier erwähnen das eine geminsamkeit die definition von Grammatiken ist, dann überleiten zu Formale Grammatiken.
% - Auch Entscheidung treffen was genau der Transpiler ist, Compiler oder Interpreter
\pagebreak
   
   
\subsection{Formale Sprachen und ihre Grammatiken}
% Warum braucht ein Compiler eine Grammatik?
% In dem vorangegangen Kapitel wurden unterschiedliche Methoden, Anwendungsgebiete und Formen der Sprachinterpretation eines Computers vorgestellt. Damit die Interpretation von Sprachen korrekt erfolgt, braucht ein Computer Regeln. Grammatiken beinhalten diese Regeln. 

Damit der Transpiler korrekt arbeitet wird eine definierte Grammatik benötigt. Nur so können die Prozessschritte der Lexikalischen- und der Syntaktischen Analyse korrekt erfolgen. Denn diese Schritte prüfen den eingegeben Quellcode auf seine grammatikalische Richtigkeit. Bevor also die Sprachliche Analyse erfolgen kann, sollte eine Grammatik definiert und angewendet werden. Um eine Grammatik für eine formale Sprache, wie einer Programmiersprache zu definieren sind logische präzise Beschreibungen von Ausdrücken notwendig. \footcite[Vgl. ][S. 149ff. ]{automata} 
Eine Grammatik einer formalen Sprache besteht aus Variablen, Terminalsymbolen, einen Startsymbol und einer Syntaxregel. Zusammengefasst in:

\begin{center}
\begin{equation}\label{eqn:grammar}
G=(V,T,S,P)
\end{equation}
\end{center}

Hierbei \verb+V+ für Variablen bzw. Nicht-Terminalsymbole, \verb+T+ für Terminale, \verb+S+ für Start und \verb+P+ für Produktion bzw. Syntaxregel steht. Dabei ist \verb+S+ ein Teil von \verb+V+.  \footcite[Vgl. ][S. 31ff. ]{automata}

% @review: Keine Hierachie Einordnung, ledilgich nennen das es sie gibt.
% Welche Typen von Grammatiken gibt es? Chomsky Hierarchie
Grammatiken lassen sich weiter durch die Chomsky Hierarchie spezifizieren. Noam Chomsky unterteilt Grammatiken in vier Ebenen. Ebene null beschreibt unbeschränkte-, Ebene eins kontextsensitive-, Ebene zwei kontextfreie- und Ebene drei reguläre Grammatiken.\footcite[Vgl. ][]{chomsky}

\pagebreak

Um eine Grammatik darzustellen werden Ableitungen von Syntaxregeln verwendet. In Listing \ref{eqn:start} ist die Syntaxregel einer einfachen \verb+if+ und \verb+else+ Verzweigung dargestellt.

% @todo: PL/I Verwenden und Kontext herstellen
\begin{center}
\begin{equation}\label{eqn:start}
S \to \mathbf{if}\: expr\: \mathbf{then}\: stmt\: \mathbf{else}\: stmt\: | \mathbf{if}\: expr\: \mathbf{then}\: stmt;
\end{equation}
\begin{equation}
expr \to expr\: op\: term\: | term
\end{equation}
\begin{equation}
op \to \mathbf{>}\: |\: \mathbf{<}\: |\: \mathbf{=}\: |\: \mathbf{!}
\end{equation}
\begin{equation}
term \to term\: multOp\: factor\:
\end{equation}
\begin{equation}
factor \to \mathbf{id}\: |\: \mathbf{constant} 
\end{equation}
\end{center}
 
Mit der beschriebenen Grammatik ist folgender Ausdruck zulässig.

\begin{lstlisting}[language=PL/I, caption=If Statement PL/I, label={lst:pliifstatement}]
IF A > B THEN 
	CALL proc_1;
ELSE 
	CALL proc_2;
END
\end{lstlisting}

Nicht zulässig ist hingegen.

\begin{lstlisting}[language=PL/I, caption=Wrong Statement PL/I, label={lst:pliwrongstatement}]
CALL IF THEN A > B proc_1;
\end{lstlisting}

Weil das Wort \verb+CALL+ in Listing \ref{lst:pliwrongstatement} nicht in dem Kontext stehen darf.

% @todo: Beispiel-Parsebaum analyse, https://en.wikipedia.org/wiki/LR_parser 
	
% Wie werden Grammtiken in einem Transpiler Programm verwendet?
Grammatiken sind für den Transpiler von Bedeutung, weil die Lexikalische und Syntaktische Analyse aus einer solchen Grammatik erzeugt werden. Mithilfe eines Compiler-Compilers kann aus einer Repräsentation einer formalen Grammatik ein Parser definiert werden.
 
Die aktuellste Grammatik wird durch IBM, in der PL/I Language Referenz definiert. Aus dieser wird mithilfe von JavaCC ein Parser erzeugt. Weshalb in dem folgenden Kapitel 1.5 der Compiler-Compiler und die dazugehörige Grammatik näher beschrieben wird.

% - Theoretischer Abriss
% - Einordnung der resultate der PA 4
%- PL/1 Syntax Wo zu finden? Welche Version der Sprache? 
%	- Reguläre Ausdrücke Syntax, Beispiel einer Grammatik die ich mit verwende, Typ einer Grammatik
%  - Literatur
%    - Chomsky Hierarchie Bücher
%    - https://www-igm.univ-mlv.fr/~berstel/LivreCodes/Codes.html
%  - Woraus besteht eine Grammatik?
%   - Wie lassen sich Grammatiken der Komplexität nach anordnen?
%  - Chomsky Hierarchie
%  Erst Chomsky Hierachier, dann nach Komplexität einordnen und am Beispiel von Regulären Ausdrücken und PL/I Grammatik einführen.
     
\pagebreak
\subsection{Anwendung von Formalen Grammatiken in JavaCC}
% 1. Was ist ein Compiler-Compiler? (Verbindung von formalen Grammatiken zu JavaCC)

In Kapitel 1.4 wurde bereits in die Thematik der formalen Grammatiken eingeführt, in diesem Kapitel wird nun die praktische Implementation dieser Grammatiken im Zusammenhang mit dem Transpiler beschrieben.
Ein Compiler-Compiler wie JavaCC ist eine Technologie mit der aus einer formalen Beschreibung einer Grammatik ein Lexer und ein Parser erzeugt werden. 

Der Lexer und der Parser wenden die in der Grammatik-Datei definierten Regeln an und verarbeiten in einer Java-Klasse die übergebenen Ausdrücke.
Die Darstellung der Grammatik erfolgt in der Regel in einer Art \ac{ebnf}. 
Beispielhafte Compiler-Compiler sind neben JavaCC, Yacc, Antlr und Lexer.


In Kapitel 1.4 wurde bereits vereinfacht eine Syntaxregel aus der PL/I-Grammatik dargestellt. Ähnlich erfolgt auch die Darstellung in einer Grammatikdatei. Folgendes Beispiel zeigt die Darstellung eines \verb+IF ELSE+ Ausdrucks. 
\footcite[Vgl. ][]{javaccdoku}


\begin{lstlisting}[language=Java, caption=If Statement aus der Grammatikdatei, label={lst:ifstatement}]
	void if_statement() #BRANCH :
	{}
	{
		< IF >bool_expression()
		< THEN >proc_body()
		[else_statement()]
	}
\end{lstlisting}

In JavaCC besteht die Möglichkeit die Beschreibung von Syntaxregeln in Methoden zu Kapseln.
In Zeile 1 ist der Methodenkopf zu sehen. In diesem Fall erzeugt die Methode \verb+if_statement+ keinen Rückgabwert.
Das durch die Raute gekennzeichnete Symbol ist die Repräsentation im Syntaxbaum und zusätzlich auch die Darstellung im Zwischencode.
Im Körper der Methode wird der If-Ausdruck weiter definiert. Terminalsymbole werden in der JavaCC Grammatik mit den größer-als und kleiner-als Zeichne umrandet. Die Nicht-Terminalsymbole hingegen sind wie in Listing \ref{lst:ifstatement} dargestellt weitere Methoden, die wiederum weitere Ausdrücke beschreiben.

Ähnlich wie bei der Syntaxregel aus Listing \ref{lst:ifstatement}, so lange bis lediglich Terminalsymbole übrig bleiben.
Die Methode \verb+bool_expression+ etwa, beschreibt einen zulässigen Boolschen Ausdruck, der durch einen weiteren boolschen Operator mit einem weiteren booleschen Ausdruck verknüft werden kann.

Weiterhin wird in der Methode \verb+proc_body+ beschrieben welche Ausdrücke weiter zulässig sind. Dazu zählt bspw. auch eine weitere \verb+IF ELSE+ Verzweigung. 

 So werden aus der Grammatikdatei, durch den Compiler-Compiler, nach und nach Java-Klassen erzeugt die Programmroutinen zur Syntaktischen Verarbeitung von PL/I-Ausdrücken beinhalten.
Der Ausschnitt aus der Grammatikdatei in Listing \ref{lst:ifstatement} wird zu dem Java-Quellcode in Listing \ref{lst:ifstatementmethode}.


\begin{lstlisting}[language=Java, caption=Verkürzte If-Statement Methode aus dem Parser, label={lst:ifstatementmethode}]
 final public void if_statement() throws ParseException {
			SimpleNode jjtn000 = new SimpleNode(JJTBRANCH);
			boolean jjtc000 = true;
			jjtree.openNodeScope(jjtn000);
	try {
			jj_consume_token(IF);
			bool_expression();
			jj_consume_token(THEN);
			proc_body();
		
		if (jj_2_30(3)) {
				else_statement();
		} else {
			;
		}
	} catch (Throwable jjte000) {
		if (jjtc000) {
				jjtree.clearNodeScope(jjtn000);
				jjtc000 = false;
		} else {
				jjtree.popNode();
		}
		if (jjte000 instanceof RuntimeException) {
				if (true) throw (RuntimeException)jjte000;
		}
		if (jjte000 instanceof ParseException) {
				if (true) throw (ParseException)jjte000;
		}
				if (true) throw (Error)jjte000;
	}
}	
\end{lstlisting}

In Listing \ref{lst:ifstatementmethode} ist zu erkennen, dass die ebenfalls definierten Methoden in der Grammatikdatei, die repräsentativ für die Nicht-Terminal-Symbole sind, auch in der Methode der generierten Parser-Klasse zu Methodenaufrufen führen. Dies ist in Zeile 7 zu sehen. Weiterhin werden Token, also die Repräsentationen der Terminalsymbole, durch die Methode \verb+jj_consume_token+ verarbeitet. Die restlichen Verzweigungen in der generierten Java-Methode prüfen die verarbeiteten Token auf Fehler.

Außerdem wird mit dem Objekt \ver+SimpleNode+ in der Java-Methode aus Listing \ref{lst:ifstatementmethode} ein Knoten im Syntaxbaum erzeugt. Diese Knoten ermöglichen die Verarbeitung des PL/I-Quellcodes durch die weiteren Module des Transpilers.

% Warum ein Compiler-Compiler verwenden?

Ein Compiler-Compiler generiert somit einen fertigen Parser. Nun gibt es auch die Möglichkeit einen Parser und Lexer selbst zu programmieren. In der Version aus der Projektarbeit-IV wurde ursprünglich ein selbstgeschriebener Lexer verwendet.

Jedoch birgt dieses Vorgehen einen Nachteil. Die Grammatik für den Transpiler ist an zwei stellen definiert und muss somit auch an zwei Stellen gewartet werden.
Wird in die Grammatikdatei für den Parser ein neuer Ausdruck hinzugefügt, muss dieser Ausdruck auch durch den Lexer verarbeitet werden können.
Ursprünglich musste so der Lexer angepasst werden und die Grammatikdatei für den Parser. 
Das führte zu einem erhöhten Arbeitsaufwand und Fehleranfälligkeit. Schlussendlich wurde der selbstgeschriebene Lexer entfernt und der von JavaCC definierte Lexer verwendet.
Somit ist ein Compiler-Compiler gut dazu geeignet den Arbeitsaufwand für die Entwicklung eines Compilers, bzw. eines Transpilers zu reduzieren. 
Es lohnt sich auch bei der Entwicklung eines Parser für andere Sprachen auf bereits definierte Ressourcen zurückzugreifen. 
Grammatiken für Cobol und Java wurden bereits von der JavaCC Community bereitgestellt. \footcite[Vgl. ][]{javaccdoku}
Im Fall von PL/I ist keine Grammatik vorhanden. Weshalb bei der Entwicklung des Transpilers, die IBM Language Reference für PL/I die Hauptquelle für die Grammatikdatei ist.   

% Wie wird JavaCC in die Entwicklung des Transpiler eingebunden ? (Hinleitung zur Architektur beschreibung)
Durch die Verwendung des JavaCC Jjtree-Moduls, kann global innerhalb des Projekts auf den Parse-Baum zugegriffen werden. 
Der Prase-Baum wird unteranderem durch die Module verwendet, die die Semantische-Analyse und -Synthese repräsentieren.
Erst durch diese wird der Java-Code erzeugt.

Ebenfalls wird für den Parser ein File-Stream benötigt, ein Scanner liefert solchen.
Neben den Parser werden also weitere Module verwendet um schlussendlich den Java-Code für den Benutzer bereitzustellen.
Die gesamte Architektur des Transpilers und dessen weitere Module wird in dem nachfolgenden Kapitel betrachtet. 
Hier werden auch die Technologien vorgestellt die neben JavaCC verwendet werden. 

\section{Technisches Vorgehen}
\subsection{Verwendete Technologien}
%- Compiler Compiler -> JavaCC: Integration in das Projetk, Grund für die Wahl der Technologie
In Kapitel 1.4 wurde bereits mit JavaCC eine verwendete Technologie vorgestellt. Neben JavaCC kommen auch weitere Technologien während der Entwicklung zum Einsatz. In dem folgenden Kapitel werden die weiteren verwendeten Technologien vorgestellt.

%- Programmiersprache -> Java: Integration in das Projekt, Grund für die Wahl.
Allgemein wurde der Transpiler in der Programmiersprache Java entwickelt. 
Java eignet sich  als Objekt-Orientierte Hochsprache gut für die Entwicklung des Transpilers. 
Weiterhin zählen die Vorteile die in Kapitel 1.1 für Java erwähnt wurden, ebenso in diesem Fall. Den Administratoren soll die Möglichkeit gegeben werden, Module einfach auszutauschen. Mithilfe von Objektorientierten Programmierparadigmen, lässt sich eine lose Kopplung der Klassen realisieren und damit eine Modulare Bauweise des Softwareprojekts.
Einhergehend fiel die Wahl auf JavaCC aufgrund der Entscheidung für die Entwicklung des Transpilers in Java. Eine alternativer Compiler-Compiler für Java, ist Antlr. 

%- IDE -> Eclipse: Integration in das Projekt, Grund für die Wahl.
Der Java-Quellcode des Transpilers wurde in Eclipse geschrieben. Das \ac{ide} Eclipse ermöglicht eine kostenlose Entwicklung, Verwaltung, Überprüfung und Kompilierung von Java Software-Projekten. Weiterhin bietet Eclipse eine breite Software-Repository an Plugins um die Funktionalität der  \ac{ide} zu erweitern. Dadurch ist eine Integration von JavaCC in die  \ac{ide} möglich und erleichtert die Entwicklung des Parser ebenfalls.

%- Maven -> Dependency Management: Integration in das Projetk, Grund für die Wahl der Technologie
Die Version aus der Projektarbeit-IV des Transpilers verwendete die Native Projektstruktur von Eclipse als Vorlage. Diese Projektvorlage brachte jedoch negative Aspekte mit sich. Es war nötig JavaCC manuell zu installieren und einzurichten. Zusätzlich mussten Pfadvariablen im Quellcode angepasst werden. 
Das erschwerte den Benutzern den Zugang zu dem eigentlichen Projekt.
Zurückzuführen ist dies auf die fehlenden Software-Abhängigkeitsverwaltung. In der Ursprünglichen Version des Transpilers musste der Benutzer selbst herausfinden welche Software dieser benötigt um das Programm zu starten

Dieses Problem wurde gelöst in dem das Software-Projektmanagement-Werkzeug Maven eingesetzt wurde. Maven löst mithilfe des \ac{pom} Abhängigkeiten. 
Dadurch werden Benutzer und Administratoren bei dem Build-Prozess entlastet.
Ein weiterer Vorteil den Maven liefert ist die vordefinierte Projektstruktur, in den sich vertraute Administratoren zurecht finden.

%- Testing -> JUNit Tests: Integration in das Projetk, Grund für die Wahl der Technologie
Zum Testen der Anwendung wurde das Java-Test Framework JUnit 5 verwendet. Es wurden für jede Klasse zugehörige Test-Klassen geschrieben. In den Test-Klassen wurde komplexere Methoden isoliert getestet.
Die Wahl von JUnit ist begründet durch die einfache Handhabung, der Kompatibilität mit der IDE Eclipse und dem Projektmanagement Werkzeug Maven. Weiterhin ist JUnit mit eines der bekanntesten Unit-Test-Frameworks für Java-Quellcode. Alternativen wären etwa gewesen TestNG \footcite[Vgl. ][]{testng} oder Mockito \footcite[Vgl. ][]{mockito}.

%- Platform -> Spring
Für die Entwicklung des Frontends wurde das Java Framework Spring-boot verwendet.
Dabei wurde das Web-Interface mit der CSS-Softwarebibliothek Bootstrap gestaltet.
Spring-Boot wird für das behandeln von REST-Anfragen verwendet und bindet über eine API Schnittstelle den Transpiler ein.
Dadurch wird eine Interaktion über den Browser möglich.

Mithilfe der, in diesem Kapitel genannten Software-Werkzeuge, wurde der Transpiler entwickelt. Die Entwicklungsphase folgte jedoch nach der Konzeptionsphase.
In der Konzeptionsphase wurde die Architektur der Anwendung ausgearbeitet und später als Quellcode realisiert. 
In dem nächsten Kapitel soll dieses Architekturbild vorgestellt werden.

\pagebreak
\subsection{Architektur} 

Der Transpiler wurde Modular in die Arbetisschritte aus Abbildung \ref{fig:transpiler} unterteilt.
Die Module repräsentieren je einen Arbeitsschritt des Transpilers.
In Abbildung \ref{fig:modules} ist eine Grob-Ansicht der Module des Transpilers dargestellt.

\dhgefigure[h]{AbstraktesUML_1.png}[scale=0.5]{Aufbau des Transpilers}{fig:modules}[][]

% Wie sind die Module momentan gebaut?
% App Modul
Die Verarbeitung des PL/I-Quellcodes beginnt mit dem App-Modul. Das App Modul ist die Schnittstelle für alle weiteren Module. Ein Modul kann durch die Instanziierung der Client-Klasse des zugehörigen Moduls eingefügt werden. Entfernt wird das Modul durch das Löschen der Instanz. Das App-Modul beinhaltet auch die \verb+main+ Methode und ist somit auch der Startpunkt für den Java-Compilers.

Der Scanner wird als erstes Instanziiert. Dieser liest aus der Konfigurations-Datei den Pfad der PL/I Datei, die übersetzt werden soll. Die Datei wird als \verb+InputStream+ an den Parser übergeben.
\pagebreak
Der durch JavaCC erzeugte Parser wird ebenfalls in dem App-Modul instanziiert. Dieser behandelt den PL/I-Quellcode entsprechend der vorher definierten Grammatik.  Während des parsings werden Variablen-, Prozeduren-, oder Packagebezeichner des PL/I-Quellcode, in die Symboltabelle eingefügt. Das Ergebnis des Parsers ist ein Syntax-Baum. 
In Abbildung \ref{fig:parsetree} is exemplarisch ein Syntaxbaum des Transpilers abgebildet der eine Variablen Deklaration und eine Definition einer Prozedur darstellt.

\dhgefigure[h]{parsetree-example.drawio.png}[scale=0.7]{Beispielhafter Syntaxbaum des PL/I-Parsers}{fig:parsetree}[][]

Ist der Syntaxbaum entsprechend erzeugt, wird dieser weiterhin durch das Checker-Modul verarbeitet. In diesem Modul wird die semantische Analyse des Quellcodes durchgeführt. In der aktuellen Version erfolgt hauptsächlich eine Typ-Überprüfung der initialisierten Variablen.

% @review: Hier erwähnen wie Configdatei bzw. Scanner den Ausgabe Ordner beeinflussen wenn das implementiert wurde.
Das Mapper-Modul repräsentiert die Synthese des PL/I-Quellcodes in Java-Zielcode. Der Syntaxbaum wird hier Stück für Stück abgearbeitet und mit entsprechenden Java-Ausdrücken übersetzt.

% @todo: Wie sind Module zueinander abhängig?
Um einen Überblick über Abhängigkeiten der Module zu verschaffen, zeigt
Abbildung \ref{fig:modulesdep} aktuell die Beziehungen der Module untereinander.

\dhgefigure[h]{Beziehungen_Modules.png}[scale=0.7]{Die Abhängigkeiten der Module}{fig:modulesdep}[][]
\pagebreak

Zu erkennen ist in Abbildung \ref{fig:modulesdep} das die Abhängigkeiten unter den Modulen eine Kaskade Form aufweisen.
Diese Form hat den Vorteil das Module aus dieser Kette verändert werden können ohne Vertikal verlaufende Module direkt zu beeinträchtigen.
Dennoch ist an dieser Stelle zu erwähnen das kein Modul isoliert betrachtet werden darf. Denn eine Veränderung eines Moduls bedeutet das auf Horizontaler 
Ebene die Verarbeitung verändert wird.

% Wie sind die Module momentan gebaut?
Jedes Modul gibt die Ergebnisse weiter an das nächste bis ein Zielcode entsteht, oder eine Fehlermeldung.

% @todo: Wie wird es erweitert?
Der Administrator kann die Module erweitern oder ersetzen.
Dabei sollte jedoch die in Abbildung \ref{fig:modulesdep} dargestellte Kaskade der Module untereinander berücksichtigt werden.
Entscheidet sich der Administrator dazu etwa eine Methode zu entfernen und eine selbst entwickelte zu verwenden, ist lediglich die bisherige 
Referenz zu ersetzen.
%In der vorherigen Version des Transpilers wurde etwa die Lexer-Klasse entfernt und die Klassen des Compiler-Compilers verwendet.
%Der Quellcode des Lexer besteht jedoch und ist lediglich als Deprecated markiert. Die erneute Verwendung des Lexer würde über den Aufruf der Methode in Main erfolgen.
%Hingegen wären hier weitere Schritte notwendig, wie etwa das einfügen einer temporären Datei, die von dem Parser als InputStream entgegen genommen wird und weiter verarbeitet wird.

Nachdem nun ein Überblick über die Architektur gegeben wurde, soll nun in Kapitel 2.3 eine Detailansicht des Transpilers erfolgen.
Ab diesem Punkt soll genauer auf den Quellcode der einzelnen Module eingegangen werden um nachzuvollziehen wie der Transpiler den PL/I-Quellcode
in Java-Zielcode umwandelt.

%Bausteine
%- Software Architektur
	%- Planen mithilfe eines UML
	%- UX Design 
    %    - zweite Diagramm, des Benutzerfluss
    %    - wie Benutzung abläuft
	%	- Website?
	%	- Docker Container?
%- Fehlertracking
%- Struktuierung des Programms, sodass ein Benutzer es selbständig erweitern kann

%\subsection{Aspektorientierte Programmierung}
%- Wie funktioniert Aspektorientiert Programmierung?
%	- Wie Löse ich mit Aspektorientierter Programmierung konkrete Probleme?
%- JavaBeans
%- Spring
%	- Wie setzt Spring Aspektorientierte Programmierkonzepte ein?
 \pagebreak
\subsection{Module des Transpilers}
%Wie in dem vorangegangen Kapitel schon dargestellt, werden in jedem Modul
%die Verarbeitungsschritte aus Abbildung \ref{fig:transpiler} implementiert.
%In diesem Kapitel sollen die Module nach ihrer Verarbeitungsreihenfolge vorgestellt werden.
%Dabei soll ein \ac{uml}-Diagramm je zu beginn der Unterkapitel verdeutlichen wie die Klassen
%in den Modulen zueinander aufgebaut sind. In jedem Diagramm wird auch auf die Einbindung in die App-Klasse eingegangen.
%Die Beschreibung beginnt mit dem Scanner.

\subsubsection{Der Scanner und Parser}
\paragraph{Scanner}
Wie Kapitel 1.5 eingeführt wird der Parser vollständig durch JavaCC generiert.
Damit der Parser den PL/I-Quellcode in die Zwischencode Darstellung übersetzen kann,
braucht dieser eine PL/I-Datei, die als Input-Stream übergeben wird.
Den Pfad zu der Datei gibt der Administrator in der Konfigurationsdatei an.
Das Modul Scanner liest die Konfigurationsdatei und versorgt den Parser mit notwendigen Ressourcen.
Abbildung \ref{fig:scannermodul} zeigt das UML-Diagramm des Scanner Moduls.

\dhgefigure[h]{scanner-klasse-uml.drawio.png}[scale=0.8]{Das Scanner-Modul}{fig:scannermodul}[][]

Das Scanner Modul besteht aus der Klasse \verb+InputReader+. 
Die \verb+InputReader+ Klasse liest und verarbeitet die Konfigurationsdatei. Die Methode \verb+getInputFilePath+ gibt den Pfad der PL/I-Quellcode Datei als String zurück.
Dieser String wird beim Aufruf der \verb+getInputFile+ Methode benötigt, um aus der Datei einen \verb+InputStream+ zu erzeugen.
Mithilfe des InputStreams kann die Datei als Parameter an den Parser in der Klasse \verb+App+ im Modul \verb+App+
übergeben werden. 

%\paragraph{Lexer}
%Die Klasse Lexer des Moduls Scanner enthält den ehemals selbst geschriebene Lexer für die lexikalische Analyse. Dadurch das dieser Prozess nun vollständig von dem JavaCC-Parser übernommen wird, wurde die Methode \verb+getToken+ überflüssig. Diese ist als veraltet mit der Kennung 'Deprecated' beschrieben, sie kann im Projekt noch verwendet werden, jedoch mit einem Risiko das die Ergebnisse der Methode nicht korrekt sind. 
%Zu einem späteren Zeitpunkt ist denkbar den selbstgeschriebenen Lexer zu optimieren und erneut einzubinden. Weshalb dieser nicht gelöscht wurde. 
%Weitere Methoden in dieser Klasse werden ebenfalls nicht länger von Klassen aus anderen Modulen verwendet. 

\paragraph{Parser}
Das Parser-Modul deckt die lexikalische und syntaktische Analyse des PL/I-Quellcodes ab.
Wie schon in Kapitel 1.4 erwähnt werden jegliche Klassen des Parsers durch die \verb+.jjt+ Grammatikdatei generiert. Da diese Klassen sehr umfangreich sind, werden diese in Abbildung \ref{fig:moduleparser} lediglich in Abgekürzter Form dargestellt. 

\dhgefigure[h]{parser-module-uml.drawio.png}[scale=0.4]{Das Parser-Modul}{fig:moduleparser}[][]
\pagebreak

Der Parser wird über die Klasse \verb+Pl1Parser+ in dem App Modul instanziiert. In der Parser-Klasse sind auch jegliche manuell geschriebenen Methoden aus der Grammatikdatei integriert. 
Dazu gehören etwa die Methode \verb+installId+, sowie weitere. 

Die ebenfalls in der Grammatikdatei definierten Tokens, 
werden in der Klasse \verb+Pl1ParserConstants+ als Konstanten definiert. 
Wobei während der Lexikalischen Analyse, die Klasse Token verwendet wird um Terminalsymbole zu verarbeiten. 
Schlussendlich wird einhergehend mit der Klasse \verb+Pl1Parser+ geprüft ob der PL/I-Quellcode zulässig ist. 
Diese beinhaltet die Methoden der in der Grammatikdatei definierten Nicht-Terminalen Ausdrücke, wie die Methode \verb+if-statement+. 
Hier ist auch der Großteil der Verarbeitungslogik des Parser-Moduls implementiert.

Wird ein Ausdruck während der Verarbeitung in Pl1Parser-Klasse als nicht zulässig  interpretiert wird eine \verb+ParseException+ geworfen, die in der Klasse \verb+ParseException+ definiert ist.

Um den Ausdruck in einem Syntaxbaum zu repräsentieren wird ein Objekt der Klasse \verb+SimpleNode+ erzeugt. Durch die Methoden \verb+clearNodeScope+ und \verb+closeNodeScope+ der Klasse \verb+JJTPl1ParserState+ wird der verarbeitete Ausdruck mit bspw. der Repräsentation \verb+VAR+ in den Syntaxbaum eingefügt. 
Siehe Abbildung \ref{fig:parsetree} So verarbeitet der Praser des Transpilers Stück für Stück den PL/I-Quellcode. 

Hat der Parser ein Nicht-Terminalsymbol gefunden, wird die Methode \verb+installIds+ aufgerufen und der Bezeichner unter bestimmten Bedingungen in die Symboltabelle eingefügt. 
Ein Bezeichner wird nicht eingefügt, 
wenn dieser schon vorhanden ist und den selben Sichtbarkeitswert hat.

Dabei wird das Modul \verb+SymbolTable+ implementiert und mit der Methode \verb+insertId+ ein Bezeichner in die Symboltabelle eingefügt. In dem folgenden Unterkapitel wird das Modul der Symboltabelle genauer beschrieben. 

\pagebreak
\subsubsection{Symboltable}
Die Symboltabelle speichert die PL/I-Symbole in einem Hashtable ab. Mit ihr sollen die anderen Module
erkennen können ob es sich bei dem ausgewählten Token um ein PL/I-Symbol handelt, oder um ein Bezeichner.
In Abbildung \ref{fig:symboltable} ist das Modul \verb+symboltable+ als \ac{uml} dargestellt.

\dhgefigure[h]{symboltable-module-uml.drawio.png}[scale=0.7]{Symboltabellen-Modul}{fig:symboltable}
\pagebreak

Das Modul \verb+Symboltable+ enthält die Klasse \verb+SymbolTable+
sowie die Enums \verb+Pl1Symbols+ und \verb+Template+.

% Wie funktioniert SymbolTable und Pl1Smybols?
Die Klasse \verb+SymbolTable+ wird beim instanziieren des Objekts mit den Werten aus dem Enum \verb+Pl1Symbols+ initialisiert. Weshalb ein Singleton Design-Pattern implementiert wurde um sicherzugehen, dass von der Symboltabelle während der Laufzeit nur eine Instanz existiert. 
Über die Methode \verb+getInstance+ können andere Module auf diese Instanz zugreifen.

Wenn ein Bezeichner in die Symboltabelle eingefügt wird, wird ein String für den Bezeichner, ein String für den Typ, ein String für die Sichtbarkeit und ein String für die Hierarchiestufe der Variable hinterlegt. Nur so kann in darauffolgenden Arbeitsschritten wie in der semantischen Analyse, die Werte korrekt verarbeitet werden.

Die restlichen Methoden der Klasse \verb+SymbolTable+ dienen der dezidierten Abfrage von Werten.

Etwa die \verb+getSymbolScope+ Methode wird dazu verwendet den Sichtbarkeitswert eines Bezeichners auszugeben.

% Wie funktioniert Template?
Der weitere Enum \verb+Template+ dient, in dem Prozessschritt der Synthese den Syntaxbaum in Java-Code umzuwandeln.
In diesem Enum sind Java-Quellcode Ausschnitte hinterlegt die PL/I-Quellcode repräsentieren können. Sie werden in dem Mapper Modul verwendet
um nach und nach den Java-Zielcode zu erzeugen.

Um den Syntaxbaum zu erzeugen muss der Syntaxbaum Stück für Stück überprüft werden. Dieser Prozess wird als semantische Analyse bezeichnet und erfolgt im Checker Modul.
 
 \pagebreak
\subsubsection{Checker}
Das Checker-Modul prüft den PL/I-Quellcode auf seine Korrektheit. 
Dieses Modul ist repräsentativ für die Semantische-Analyse. 
Eine Aufgabe des Checker-Moduls ist es die Typ-Definition von Variablen mit den Zuweisungen abzugleichen.
Wird beispielsweise dem Decimal-Typ ein Alphanumerischer Wert zugewiesen, soll dieses Modul den Benutzer auf einen Syntaxfehler hinweisen. Um solche Semantischen Fehler zu erkennen, wird das Checker-Modul nach dem Vorbild des Composite Design-Patterns implementiert. In Abbildung \ref{fig:checker} ist das \ac{uml} des Checker Modul abgebildet.

\dhgefigure[h]{checker-module-uml.png}[scale=0.58]{Checker Modul}{fig:checker}
\pagebreak

Entsprechend des Composite Design-Patterns, wird der Component; \verb+ITypeExpression+, das Composite; \verb+VarChecker+ und mehrere Leafs wie etwa die \verb+DecimalChecker+ Klasse, definiert.
Die zu überprüfenden PL/I-Datentypen ergeben ein Leaf.
Dabei hilft das Composite-Design Pattern für alle Typ-Klassen, einheitliche Validierungstrukturen zu definieren.
Etwa in Abbildung \ref{fig:checker} ist die Methode \verb+getType+ definiert, um die korrekte Zuweisung von Variablen zu erschließen. 

Weiterhin kann mit dem Design-Pattern die Speicherstruktur, die einer Überprüfung unterzogen wird, in der Composite-Klasse dargestellt werden.
Eine mögliche Erweiterung um weiter Speicherstruktur-Elemente wie einem Array ist somit denkbar.

In dem Checker-Modul wird zum ersten Mal auf den Syntaxbaum, das Ergebnis des Parser Moduls, zugegriffen.
Um auf alle Knoten des Syntaxbaums zuzugreifen, wird eine Methode definiert die zum iterieren des Syntaxbaums benötigt wird.
Diese Methode ist auch für weitere Module brauchbar, weil auch diese durch den Syntaxbaum iterieren sollen.
Dazu wurde in der \verb+DecimalChecker+ Klasse die Methode \verb+iterateTree+ implementiert.
Um den Syntaxbaum erfolgreich zu iterieren wurde der Depth-first Suchalgorhitmus rekursiv in dieser Methode implementiert.
Die Iterationsweise des Algorhitmus im Zusammenhang mit dem Syntaxbaum ist in Abbildung \ref{fig:parsetreealgo} dargestellt.

\dhgefigure[h]{parsetree-example-searchalgo.png}[scale=0.8]{Beispielhafte Iteration des Syntaxbaums}{fig:parsetreealgo}[][]
\pagebreak

So wird es möglich gezielt nach Knoten zu suchen und die Attribute des Knotens auszulesen.
In dem Checker Modul wird dieser Algorithmus vor allem benutzt um festzustellen welche Variablen, mit welchem Typ und welchen Bezeichner deklariert wurde und ob dieser Bezeichner in einem \verb+ASSIGN+ Knoten wiederverwendet wurde.

So kann der Syntaxbaum mit seinen Attributen vollständig iteriert und überprüft werden.
Die Überprüfung ist dann abgeschlossen, wenn die Iteration des Suchalgorithmus wieder bei dem Ausgangspunkt angekommen ist. In Abbildung \ref{fig:parsetreealgo} ist das etwa der Knoten \verb+PRORGRAM+.

Wurde kein Fehler entdeckt beginnt die Transformation des Syntaxbaums in Java. Falls jedoch ein Fehler entdeckt wurde, wird eine entsprechende Fehlermeldung angezeigt.

Das Checker Modul bereitet den Syntaxbaum entsprechend so vor, dass dieser weiterhin in der Synthese verarbeitet werden kann.
Die Synthese wird durch das Mapper-Modul implementiert und ist Bestandteil des nächsten Kapitels.
 
 \pagebreak
\subsubsection{Mapper}
Das Mapper Modul transformiert die Zwischencode Repräsentation in den Java-Zielcode. Dazu wurde das Mapper-Modul nach dem Strategy Desgin-Pattern entworfen.
In Abbildung \ref{fig:mapper} ist das UML des Mapper Moduls zu sehen. 


\dhgefigure[h]{mapper-module-uml.png}[scale=0.7]{Mapper Modul}{fig:mapper}
\pagebreak

Die Klasse \verb+Mapper+ wird in der Main-Methode des Projektes instanziiert. Als Parameter wird der Wurzelknoten des Parssebaums übergegeben.
Woraufhin mithilfe der \verb+iterateTree+ Methode erneut durch den Parsbaum iteriert wird. Hier wurde ebenfalls der Depth-first Suchalgorhitmus implementiert um jeden Knoten zu verarbeiten. 

Jeder Knoten wird über eine Konstante mit einer zugehörigen Identifizierungsnummer überprüft. Die in dem interface \verb+Pl1ParserTreeConstants+ des Parser Moduls definiert sind. 

In der Klasse \verb+AstMapper+ finden sich jegliche Identifikations-variablen der Knoten. Hier werden diese mit den zugehörigen Mapper-Klasse in einer HashMap gespeichert.

Die Mapper Klassen stellen die unterschiedlichen Vorgehensweisen in dem Strategy-Pattern dar. Sie implementieren alle das \path{ITranslationBehavior} interface und aufgrund dessen eine \verb+translate+ Methode, die den übersetzten Ausdruck zurückgibt. 

In der \verb+iterateTree+ Methode wird für jeden Knoten, überprüft ob eine solche Mapper-Klasse in der HashMap instanziiert wurde.
Falls eine Klasse vorhanden ist, wird in der TranslationBehavior Klasse das entsprechende Strategie-Objekt
des Typs \path{ITranslationBehavior} in der
Mapper Klasse gesetzt. So wird die Translate-Methode der aktuell gesetzten Klasse aufgerufen und der Syntaxbaum-Knote in Java übersetzt.

% wie funktioniert der PicturemMapper
Eine exemplarische Mapper Klasse ist etwa die \verb+PictureMapper+ Klasse.
Die Klasse \verb+PictureMapper+ enthält Zeichenkettenbeschränkungen des PL/I-Picture Typs und deren Übersetzung als Regulären Ausdruck.
Da die Zeichenkettenbeschränkung aus PL/I nicht in dem Java Zielcode angewendet werden kann, werden die Beschränkungen des Picture-Typs entsprechend in Reguläre Ausdrücke übersetzt.
Mit der \verb+getRegex+ Methode der \verb+PictureMapper+ Klasse wird der übersetzte Reguläre Ausdruck als String zurückgegeben.
Der PL/I-Ausdruck \verb+(4)A+ wird etwa zu dem Regulären Ausdruck \verb+(A-Za-z ){4}+.   


Neben der PictureMapper Klassen, erzeugen weitere Mapper Klassen Stück für Stück den Java-Zielcode. 
Jegliche Ausdrücke werden am Ende in einer Arraylist mit dem Namen \verb+javaExpression+ der Mapper Eltern-Klasse  gespeichert.
Wenn über jeden Knoten des Parse-Baums iteriert wurde, ist das Programm vollständig übersetzt.


Dabei kann es jederzeit zu Fehlern, durch eine Fehlerhafte Benutzereingabe kommen.
Entsprechend sollte der Benutzer auf die Probleme hingewiesen werden.
In dem Modul Errorhandling, werden Fehlermeldungen definiert und von anderen Modulen implementiert das folgenden Kapitel 2.4 gibt eine Übersicht über Eigen-implementierte Fehlermeldungen und verwendete Fehlermeldungen aus der Standardbibliotheken.

\pagebreak

\subsection{Fehlerbehandlung}
Die Fehlerbehandlung wird über das Modul Errorhandling bereitgestellt.
In diesem wurden Kind-Klassen der Exception Klasse, der Java Standard Bibliothek implementiert.
Allgemein wurde versucht möglichst wenig selbstdefinierte Exception Klassen zu erstellen.
Denn der Erfahrene Java-Entwickler der mit den Standard-Java Exception vertraut ist, kann so schneller die geworfenen Fehler behandeln. In der Tabelle \ref{tab:exceptiontabelle} sind die verwendeten Exception dargestellt.

\begin{table}[h]
	\centering
	
	\label{tab:exceptiontabelle}
\begin{tabular}[h]{|l|l|l|}
	\hline
	\textbf{Exception} & \textbf{Quelle}  \\
	\hline
	\verb+IncorretInputFileException+ & Errorhandling-Modul  \\
	\hline
	\verb+LexicalErrorException+ & Errorhandling-Modul  \\
	\hline
	\verb+TypeMappingException+ & Errorhandling-Modul \\
	\hline
	\verb+ParseException+ & Parser-Modul \\
	\hline
	\verb+MappingException+ & Errorhandling-Modul \\
	\hline
	\verb+IOExcpetion+ & Java-IO-Package \\
	\hline
	\verb+NumberFormateExcpetion+ & Java-Lang-Package \\
	\hline
	\verb+IllegalArgumentException+ & Java-Lang-Package \\
	\hline
	\verb+NullPointerException+ & Java-Lang-Package \\
	\hline
	\verb+DuplicateRequestException+ & Jdi-Request-Package \\
	\hline
	
\end{tabular}
\caption{Liste der verwendeten Exceptions}
\end{table}

Nachfolgenden soll der Kontext der Exceptions näher beschrieben werden.

Die \verb+IncorretInputFileException+ wird immer dann geworfen, wenn
es sich bei der Eingabedatei nicht um eine PL/I-Datei handelt.
Der Transpiler akzeptiert lediglich das Dateiformat \verb+.pli+.

Enthält dabei der zu übersetzende Ausdruck eine Variable des Typs Picture,
soll die \verb+LexicalErrorException+ verhindern das ein fehlerhafter Picture-Ausdruck übersetzt wird.
Diese Fehlermeldung eignet sich auch weiterhin um Lexikalische von Syntaktischen Fehlern zu unterscheiden. Da jedoch in der aktuellen Version des Transpilers die lexikalische Analyse und syntaktische Analyse von dem Parser-Modul übernommen werden, wird auch die \verb+ParseException+ zurückgegriffen.

Der Benutzer wird durch die \verb+ParseException+ darauf hingewiesen wo ein Fehlerauftritt und welche Schritte unternommen werden müssen um den Fehler zu beheben.
Wird etwa ein Syntaktisch falscher Ausdruck an das Parser-Module übergeben, parsed diesen den Ausdruck
bis zu der Stelle in der die definierte Grammatik nicht länger greift.
Der PL/I-Parser wirft die \verb+ParseException+ und gibt in dieser die Zeilen- und Spaltennummer des
entstanden Fehlers an.

Woraufhin das Checker-Modul nochmal die Zwischencode-Erzeugung des Parser überprüft.
Da das Checker-Modul aktuell lediglich einen Typ-Checker implementiert, existiert aktuell nur eine \verb+TypeMappingException+.
Diese wird immer dann geworfen, wenn der Typ einer deklarierten Variable mit einem nicht zugelassenen Wert zugewiesen wird.
Für weitere Semantische Analyse Schritte, sind ebenfalls weitere Exceptions denkbar. Allgemein dient das Checker-Modul lediglich der Fehlererkennung und Unterbrechung des Transformations-Prozesses.

Mithilfe der \verb+MappingException+ wird vor jeder Terminierung der \verb+translate+ Methode des Mapper-Moduls überprüft ob 
die benötigten Werte, wie etwa ein Bezeichner oder ein Parameter auch korrekt aus dem Syntaxbaum verarbeitet wurden.
Es ist zwar zu erwarten das der Parser einen solchen Fehler erkennt, aufgrund der definierten Grammatik, 
dennoch soll nach Möglichkeit vermieden werden das ein Fehlerhaftes Programm Transformiert wird.

Die restlichen Standard Java-Exceptions werden auch in dem zu erwarteten Zusammenhang eingesetzt.

In der aktuellen Version des Transpilers werden auch nicht alle PL/I-Syntaxelemente eingebunden.
Das hat zur folge das es äußerst wahrscheinlich ist, dass der Benutzer auf eine ParseException stoßen wird.
Aufgrund der beschränkten Arbeitszeit, wurden lediglich wesentliche Syntaxelemente einer Programmiersprache implementiert.
Dazu zählen Deklarationen, Kontrollflussanweisungen, sowie Ein- und Ausgabeströme.
In dem nachfolgenden Kapitel werden diese Kernfunktionen vorgestellt und die Übersetzungsentscheidung
diskutiert. 

\pagebreak
\section{Technische Spezifikation}
\subsection{Ausführung des Transpilers}

% Importieren in Eclipse
Für die unterschiedlichen Benutzergruppen werden verschiedene Nutzungsmöglichkeiten des Transpilers angeboten. Diese umfassen die Verwendung über die \ac{ide} Eclipse, die Kommandozeile und das Webinterface. Bei der Benutzung des Transpilers werden erstmals Übersetzungsentscheidungen sichtbar. In diesem Kapitel sollen alle Nutzungsmöglichkeiten und Spezifikationen des Transpilers näher beschrieben werden.

\paragraph{Eclipse}
Die \ac{ide} Eclipse kann verwendet werden, um den Transpiler zu nutzen. Diese Herangehensweise ist besonders interessant für Administratoren, die den Quellcode des Transpilers selbst erweitern möchten. Neben Eclipse wird hierfür auch Git benötigt. 

Zuerst sollte das Projekt aus dem GitHub-Repository mit Git in das lokale Verzeichnis geladen werden.
In Listing \ref{lst:gitclone} ist der Git-Befehl, zum laden des Remote-Repositories dargestellt. 

\begin{lstlisting}[language=bash, caption=Herunterladen der Repository des Transpilers, label={lst:gitclone}]
git clone https://github.com/lhahner/pl1-code-transpiler.git
\end{lstlisting}

Daraufhin ist es möglich, das Maven-Projekt in Eclipse zu importieren. Unter der Registerkarte "Datei", kann das Projekt importiert werden. %Dabei erscheint das Menüfenster aus Abbildung \ref{fig:importproject}.

%\pagebreak
%\dhgefigure[h]{import-maven-project.png}[scale=0.4]{Importieren eines Maven Projekts}{fig:importproject}

Im nächsten Menüfenster sollte der Ordner ausgewählt werden, in dem die \verb+pom.xml+ Datei liegt. Ist der Ordner korrekt ausgewählt, wird das Projekt in Eclipse importiert. 

Das Verzeichnis \verb+src/main/java/res/pli+ ist das Standard-Eingabeverzeichnis. Hier kann eine PL/I-Datei abgelegt werden, die übersetzt werden soll. Es ist auch möglich, das Standard-Eingabeverzeichnis zu ändern. 
Im Ordner \path{src/main/java/res/config} befindet sich die Konfigurationsdatei 
\verb+config.properties+. In dieser Datei kann die Variable \verb+PATH+ geändert werden, 
um PL/I-Quellcode aus einer anderen Projektstruktur zu transformieren.

\paragraph{Webanwendung}
Um es dem Benutzer leicht zu gestalten den Transpiler zu verwenden wurde mithilfe des Spring-Boot Frameworks eine Webanwendung entwickelt.
Die Webanwendung enthält neben der Integration des Transpilers auch Dokumentationen der bisherigen Versionen.
Um die Webanwendung zu verwenden muss erneut eine GitHub-Repository geladen werden. Verwendet wird der Git-Befehl in Listing
\ref{lst:gitcloneweb}

\begin{lstlisting}[language=bash, caption=Herunterladen der Repository der Web-Schnittstelle, label={lst:gitcloneweb}]
	git clone https://github.com/lhahner/plitra-web.git
\end{lstlisting}

Um die Anwendung zu starten sollte mit der Kommandozeile in den Projektordner navigiert werden.
Daraufhin kann das Spring-Boot Projekt gestartet werden. In Listing \ref{lst:springboot} ist der Befehl beschrieben um die Spring-Boot Anwendung lokal zu starten.

\begin{lstlisting}[language=bash, caption=Build Spring-Boot Projekt, label={lst:springboot}]
	.\mvnw spring-boot:run
\end{lstlisting}

Daraufhin wird die Spring-Boot Anwendung unter dem Port 8080, lokal erreichbar.
Zu sehen ist unter diesem Port die grafische Oberfläche aus Abbildung \ref{fig:homepage}.

\dhgefigure[h]{homepage-plitra-web.png}[scale=0.5]{Startseite der Grafischen Oberfläche}{fig:homepage}[][]

Hier kann entweder unter "Documentation" die Dokumentation der bisherigen Versionen eingesehen werden und unter Transpile
die eigentliche Anwendung aufgerufen werden.
Unter "Transpile" öffnet sich die Grafische Oberflächliche aus Abbildung \ref{fig:translator}.

\dhgefigure[h]{translate-view.png}[scale=0.5]{Grafische Oberfläche des Übersetzers}{fig:translator}[][]

Auf der linken Seite der Grafischen Oberfläche kann der PL/I-Quellcode eingefügt werden und auf der linken Seite erscheint dann, entweder der übersetze Java-Zielcode oder eine Fehlermeldung.
Der Benutzer kann diese Schnittstelle benutzen um einfache PL/I-Programm zu übersetzen, oder um die Java-Repräsentation eines PL/I-Ausdruck anzusehen.

Neben der grafischen Oberfläche hat auch die Gestaltung der Übersetzung einen Einfluss auf die Benutzererfahrung. Eine Transformation des PL/I-Quellcodes in schwer lesbaren und wartbaren Java-Zielcode erreicht zwar das grundlegende Ziel der Übersetzung, ist jedoch für viele Benutzer nicht ausreichend.

In den nachfolgenden Kapiteln werden PL/I-Strukturen beschrieben und die Transformation in Java diskutiert.

\pagebreak





\subsection{Transformation nach Anweisungskategorien}
\subsubsection{Deklarationen und Zuweisungen}
Die erste Version des Transpilers enthielt lediglich die Transformation von PL/I-Datentypen in nicht-primitive Java Datentypen wie etwa die Klasse \verb+DECIMAL+, \verb+CHAR+ oder \verb+PICTURE+.

%In der Version des Transpilers aus der Projektarbeit IV wurden selbst geschriebene, nicht-primitive Datentypen verwendet, um die PL/I-Datentypen in entsprechenden Java-Zielcode zu übersetzen. Dies ist für Deklarationen ausreichend.

Erst bei der Verwendung dieser Datentypen in einer Programmroutine werden jedoch Mängel des Designs sichtbar. Ein Beispiel hierfür ist die \verb+DECIMAL+-Klasse.

Werden in dem PL/I-Quellcode etwa die deklarierten Variablen verwendet um Mathematische Berechnungen zu erstellen, ist dies ohne Probleme mit den Mathematischen Standard Operatoren wie Plus oder Minus möglich.

Wird ein Java-Programm auf der grünen Wiese erzeugt sind solche Ausdrücke ebenfalls möglich, wenn numerische primitive Datentypen zum Einsatz kommen.

Um solche Ausdrücke auch in Java mit einem \verb+DECIMAL+-Objekt zu ermöglichen, muss die Klasse \verb+DECIMAL+ erweitert werden.
Denn in Java ist es nicht möglich nicht-primitive Datentypen zu verrechnen, ohne vorher eine Methode zu schreiben die diese Operation ermöglicht. 
Bei der Implementierung der Methoden können die Standard-Operatoren nicht überladen werden, wie es in C++ der Fall ist.
Stattdessen müssen ausformulierte Methoden implementiert werden, die den numerischen Wert einer Variable abfragen und mit einer weiteren Verrechnen

Ein Beispiel soll demonstrieren wie die Übersetzung eines Arithmetischen Ausdrucks aussehen könnte.
Angenommen der PL/I-Ausdruck in Listing \ref{lst:pliarithmeticexpression} wird mithilfe des Transpilers in Java übersetzt.

\begin{lstlisting}[language=PL/I, caption=Arithmetischer Ausdruck in PL/I, label={lst:pliarithmeticexpression}]
	DCL var_1 DECIMAL(2);
	DCL var_2 DECIMAL (2);
	
	DCL var_3 = var_1 * 2 + var_2 * 3;
\end{lstlisting}
\pagebreak 
 
Ist nun in der Klasse \verb+DECIMAL+ für jede Arithmetische Operation eine Methode definiert wäre die Übersetzung in Listing \ref{lst:javapliarithmeticexpression} äquivalent zu Listing \ref{lst:pliarithmeticexpression}.

\begin{lstlisting}[language=PL/I, caption=Arithmetischer Ausdruck aus PL/I in Java, label={lst:javapliarithmeticexpression}]
	DECIMAL var_1 = new DECIMAL(2);
	DECIMAL var_2 = new DECIMAL(2);
	
	DECIMAL var_3.init(var_1.multiply("2").add(var_2.multiply("3")));
\end{lstlisting}

An diesem Punkt ist anzumerken, dass diese Übersetzung zwangsläufig zu einer komplexen Struktur des Java-Zielcodes führen wird. Für die weitere Übersetzung syntaktischer PL/I-Strukturen könnte die Entscheidung für eine solche Lösung die Lesbarkeit des übersetzten Programms beeinflussen. Beispielsweise würde die Verwendung sowohl arithmetischer als auch boolescher Operatoren in einer Verzweigung den Java-Zielcode komplex wirken lassen. Ein Grund hierfür liegt in der Nutzung implementierter Methoden anstelle mathematischer Operatoren.

Wenn das \verb+DECIMAL+-Objekt durch einen primitiven Datentyp ersetzt werden würde, wäre eine eins-zu-eins Transformation des zugewiesenen arithmetischen Ausdrucks in Listing \ref{lst:pliarithmeticexpression} möglich. Um die Längenbeschränkung aus PL/I auch in Java zu berücksichtigen, könnte die Implementierung einer Validierungs Annotation erwogen werden.

Mithilfe der Jarkarta-Validations Software-Bibliothek kann eine Annotation erzeugt werden, die mit einer Java-Reflection überprüft wird. \footcite[Vgl. ][]{jakarta}
Dazu wird eine Implementierung von Validierungs-Klasse als Boiler-Plate-Code  notwendig. 
Die Übersetzung des Ausdrucks in Listing \ref{lst:pliarithmeticexpression} würde wie in Listing \ref{lst:annotationdecimal} dargestellt erfolgen.

\begin{lstlisting}[language=Java, caption=Annotations Lösung des DECIMAL-Typs, label={lst:annotationdecimal}]
	@Decimal(10)
	double var_1;
	
	@Decimal(10)
	double var_2);

	double var_3 = (var_1 * 2) + (var_2 * 3);
\end{lstlisting}

Durch diese Gestaltung ist auch die Einbindung und Erweiterung des übersetzen PL/I-Quellcode erleichtert.

In diesem Zusammenhang wird in weiterführenden Entwicklung die Beschränkung der Länge mit Annotationen gelöst. So kann eine semantische nähe zu Java hergestellt werden und gleichzeitig der Wiedererkennungswert von PL/I beibehalten werden.

Die beschriebene Version des Transpilers implementiert bisher lediglich die \verb+@Decimal+ Annotation.
Weshalb in den nachfolgenden Kapiteln weiterhin Klassen wie etwa die Klasse \verb+CHAR+ eingebunden werden.

\pagebreak
\subsubsection{Programmstruktur und Programmablauf}
\paragraph{Umwandlung von Programmstrukturen }\label{programstruct}

Mit dieser Version des Transpilers ist es möglich Prozeduren umzuwandeln.
In PL/I werden Unterprogramm-Routinen in Block-Strukturen definiert. Eine mögliche Block Struktur ist die Prozedur. \footcite[Vgl. ][S. 97ff. ]{pliref}
Eine Prozedur wird durch den Bezeichner, das PL/I-Symbol \verb+PROCEDURE+ und einer Terminierung wie \verb+END+ beschrieben.
Zusätzlich können Parameter, Rückgabetypen und allgemeine Attribut Optionen definiert werden. In Listing \ref{lst:procchar} ist eine beispielhafte Prozedur gelistet.

\begin{lstlisting}[language=PL/I, caption=Deklaration einer Prozedur des Typs Char, label={lst:procchar}]
empty_proc: PROC(para_1, para_2) RETURNS(CHAR(5)) OPTION(INLINE);
	...
END empty_proc;
\end{lstlisting}

Die Prozedur \verb+empty_proc+ hat zwei Parameter und gibt einen Wert des Typs \verb+CHAR+ der L\"ange 5 zur\"uck.
Weiterhin wird die Option \verb+INLINE+ definiert.

Um in Java Unterprogramm-Routinen zu definieren gibt es Methoden. 
Entsprechend sind Methoden ein mögliches äquivalent der Prozeduren. \footcite[Vgl. ][]{oracle}
Eine Methode hat ähnliche Bestandteile wie eine Prozedur.
Es wird ein Modifier, Rückgabetyp, Bezeichner und eine Parameterliste benötigt.
Einige dieser Attribute sind auch in einer Prozedur definiert.
Jedoch gibt es Unterschiede, die zu einer nicht eindeutigen Übersetzung führen können.

Wird etwa versucht die in der PL/I-Prozedur definierten Parameter direkt zu übersetzen, fehlt die explizite Angabe des Typs im Parameter.

Dieser wird in PL/I implizit durch die Zuweisung definiert, etwa wie in Listing \ref{lst:procassign} dargestellt

\begin{lstlisting}[language=PL/I, caption=Zuweisung von Variablen in einer Prozedur, label={lst:procassign}]
empty_proc: PROC(para_1, para_2) RETURNS(CHAR(5)) OPTION(INLINE);
	para_1 = 'foo';
	para_2 = 'baa';
END empty_proc;
\end{lstlisting}

Implizit wird hier der Typ \verb+CHAR+ zugewiesen. 
In Java muss hingegen explizit der Typ des Parameter definiert werden.
Eine M\"oglichkeit die Parameterliste zu transformieren, ist über den Typ \verb+Object+.
Da Object die Elternklasse aller Klassen ist, kann während der Zuweisung des Parameters beliebig in den gewünschten Typ umgewandelt werden. \footcite[Vgl. ][]{objectdocs}

In Listing \ref{lst:metassign} ist die Prozedur aus Listing \ref{lst:procassign} als Methode dargestellt.

\begin{lstlisting}[language=Java, caption=\"Ubersetzung der Prozedur, label={lst:metassign}]
public CHAR empty_proc(Object, para_1, Object para_2){
	para_1 = "foo";
	para_2 = "baa";
	return new CHAR(5);
}
\end{lstlisting} 

Weiterhin wird in der Prozedur aus Listing \ref{lst:procassign} ein R\"uckgabewert des Typs \verb+CHAR+ der L\"ange f\"unf definiert.
Aktuell wird \"uber eine Objektinstantiierung des Typs \verb+CHAR+ im Return Ausdruck die L\"ange definiert.

Auch hier würde sich die Verwendung der in Kapitel \ref{programstruct} beschriebenen Annotationslösung eignen. Anstatt die Methode in Listing \ref{lst:metassign} vom Typ des nicht-primitiven Objektes \verb+CHAR+ zu transformieren, könnte das native Java äquivalent \verb+String+ verwendet werden.
Eine denkbare Alternative ist in Listing \ref{lst:javaannotationproc} dargestellt.

\begin{lstlisting}[language=Java, caption=Java-Annotation für übersetze Prozeduren, label={lst:javaannotationproc}]
@Char(5)
public String empty_proc(Obeject para_1, Object para_2){
	para_1 = "foo";
	para_2 = "baa";
	return "";
}
\end{lstlisting} 

Erneut wird auch hier über die Annotation die Längenbeschränkung definiert und der native Java Typ String verwendet.
Die Validierung des Rückgabewertes erfolgt dann mithilfe von Boiler-plate Code der bei der Transformation bereitgestellt wird.
Über eine Typ-Umwandlung des Parameter kann auch dieser in der Methode zurückgegeben werden. 

\begin{lstlisting}[language=Java, caption=\"Ubersetzung der Prozedur, label={lst:metassign}]
@Char(5)
public String empty_proc(Obeject para_1){
	return (String)para_1;
}
\end{lstlisting} 

Ein weiteres Attribut das in der Prozedur in Listing \ref{lst:procassign} definiert ist, ist das \verb+OPTIONS+
Attribut.
In PL/I werden hier Compiler Optionen definiert. So wird wie in Listing \ref{lst:procassign}, die Option \verb+INLINE+ verwendet um den Kontext einer Prozedur zu beschreiben. \footcite[Vgl. ][]{optionsstmt}

In der Version des Transpilers wird die Übersetzung dieses Ausdrucks nicht weiter berücksichtigt.
Es ist auch fraglich ob eine solche Option in Java simuliert werden kann, da so das verhalten der \ac{jvm} beeinflusst werden müsste.

Um nun einen tatsächlichen Programmfluss zu realisieren, sollte der Transpiler ebenfalls in der Lage sein die definierten Routinen auch aufzurufen.
In dem nachfolgenden Paragraf wird die Umwandlung des Aufrufen von Prozeduren beschrieben.

\paragraph{Umwandlung des Programmablaufs}

In PL/I werden Prozeduren unter anderem mithilfe des \verb+CALL+ Statements aufgerufen. \footcite[Vgl. ][S.133ff. ]{pliref} Um einen Programmfluss, wie er auch in einem nativen Java-Programm, vorhanden ist zu erzeugen wird der Call-Ausdruck in einen Methoden-Aufruf transformiert. Wird also das Programm aus Listing \ref{lst:callsproc} dem Transpiler übergeben.

\begin{lstlisting}[language=PL/I, caption=\"Ubersetzung der Prozedur, label={lst:callsproc}]

	main_proc: PROC;
		CALL proc_1;
	END main_proc;

	proc_1: PROC;
		CALL proc_1;
	END proc_1;

	proc_2: PROC;
		CALL proc_2;
	END proc_2;

\end{lstlisting} 

Ergibt die Transformation, den Code-Ausschnitt aus Listing \ref{lst:callsproc}.

\begin{lstlisting}[language=Java, caption=\"Ubersetzung des Call-Statments, label={lst:javacallsproc}]
	public void main_proc (){
		proc_1();
	}

	public void proc_1 (){
		proc_2();
	}
	public void proc_2 (){
		proc_1();
	}
\end{lstlisting} 

Die gleiche Endlosschleife aus PL/I wird somit auch in Java erzeugt.
Dadurch kann ein einfacher Programmablauf von einem PL/I-Programm in ein Java-Programm transformiert werden.

% TODO Beispiel mit Parametern

Um nun ein PL/I-Programm wie zusätzlicher Logik zu transformieren, sollten Verzweigungen und Schleifen ebenfalls übersetzt werden.

\pagebreak
\subsubsection{Kontrollflussanweisungen}
\paragraph{Umwandlung von Verzweigungen}

In PL/I werden Verzweigungen mit den Symbolen \verb+IF+ und \verb+ELSE+ implementiert. 
Gepaart mit einem Booleschen Ausdruck kann so ein Wahrheitswert abgefragt werden.
Dabei gibt es Boolesch Operatoren in PL/I die in Java anders repräsentiert werden.
Während in Java ein einfaches Ausrufezeichen eine Negation beschreibt, wird in PL/I das logische Negationszeichen (¬) verwendet. Dieses ist nicht UTF-8 Codiert und wird in Java nicht verwendet. Bei der Transformation wird dieses Zeichen in ein Ausrufezeichen übersetzt.

Weiterhin wird in PL/I ein einzelnes Gleichheitszeichen als logischer Vergleichsoperator verwendet. Da in Java das einzelne Gleichheitszeichen der Zuweisung von Variablen dient, sollte der PL/I-Vergleichsoperator mit den Java-Vergleichsoperator ersetzt werden.

Gleiches gilt für das logische-Und, in PL/I wird lediglich ein Et-Zeichen verwendet. Während in Java zwei als logisches-Und verwendet werden.

Werden diese Zeichen korrekt übersetzt, können Boolesche Ausdrücke in Java überführt werden.
Somit lässt sich der Ausdruck in Listing \ref{lst:javacallsproc} in PL/I übersetzen.

\begin{lstlisting}[language=PL/I, caption=PL/I if-statements, label={lst:javacallsproc}]
IF (var_1 < var_2) THEN;
	DISPLAY('smaller');
ELSE
	DISPLAY('Not smaller');
END;
\end{lstlisting} 

Bei der Transformation des Verzweigungskörpers erfolgt die Orientierung an dem \verb+THEN+ und \verb+END+.
So entsteht der Java Ausdruck in Listing \ref{lst:javaifstatement}.

\begin{lstlisting}[language=Java, caption=Java if-statements, label={lst:javaifstatement}]
if (var_1 < var_2) {
	System.out.println ("smaller");
}
else {
	System.out.println ("Not smaller");
}
\end{lstlisting} 

Würden hier erneut der nicht-Primitive Typ, wie das \verb+DECIMAL+ Objekt verwendet, wäre eine solche einfache Vergleichs Operation nicht möglich.
Stattdessen hätten die instanziierten Objekte erst mit einer Art \verb+toNumeric+ Methode in ein Numerisches Format umgewandelt werden müssen.
Was erneut zu mehr Quellcode als nötig führen würde.

Eine Else-if Verzweigung existiert in PL/I der Form eines verschachtelten If-Else Ausdrucks wie es in Listing \ref{lst:pliifelsestatement} dargestellt ist.

\begin{lstlisting}[language=PL/I, caption=PL/I IF-ELSE Statement, label={lst:pliifelsestatement}]
IF (var_1 < var_2) THEN;
	DISPLAY('smaller');
ELSE
	IF (var_1 = var_2) THEN;
		DISPLAY('Not smaller');
	END;
END;
\end{lstlisting} 
 
 Entsprechend wird in Java auch nur ein verschachtelter If-Else Ausdruck, wie in Listing \ref{lst:javaelseifstatement} dargestellt übersetzt.
 
 \begin{lstlisting}[language=Java, caption=Java If-Else Statement, label={lst:javaelseifstatement}]
 if (var_1 < var_2){
 	System.out.println ("smaller");
 } else {
 	if(var_1 == var_2){
 		System.out.println("Not smaller");
 	}
 }
 \end{lstlisting} 

Neben den Verzweigungen kann zusätzliche Logik eines Programms auch durch eine Schleife erreicht werden.

\paragraph{Umwandlung von Schleifen}
In PL/I wird in der aktuellen Version des Transpilers, die  While- und Until-Schleife übersetzt.
Da Java ebenfalls eine While-Schleife implementiert, kann diese als Übersetzungsmuster verwendet werden.

\begin{lstlisting}[language=PL/I, caption=PL/I IF-Else Statement, label={lst:whilecomamnd}]
DO 
	WHILE(var_1 < var_2);
		DISPLAY('smaller');
END;
\end{lstlisting} 

Listing \ref{lst:whilecomamnd} zeigt eine einfache While-Schleife in PL/I.
Dabei wird in PL/I das Symbol \verb+DO+ nicht wie in Java für eine Do-While
Schleife verwendet, sondern leitet lediglich einen Schleifen-Ausdruck ein.

Die Übersetzung der Schleife folgt in Listing \ref{lst:javawhilecommand}.

\begin{lstlisting}[language=Java, caption=Java While-Statement, label={lst:javawhilecommand}]
while(var_1 < var_2){
	System.out.println("smaller");
}
\end{lstlisting} 

Wird nun in PL/I eine \verb+UNTIL+ Beschränkung definiert, wie etwa in Listing
\ref{lst:untilwhile}.

\begin{lstlisting}[language=PL/I, caption=PL/I IF-ELSE Statement, label={lst:untilwhile}]
DO 
	WHILE(var_1 < var_2) UNTIL(var_1 = var_2);
		DISPLAY('smaller');
END;
\end{lstlisting} 

Sollte in Java eine äquivalente Abbruchbedingung erzeugt werden.
In der aktuellen Version des Transpilers wurde sich für das Einfügen einer If-Verzweigung entschieden, die bei Eintritt die Schleife mit einem \verb+break+ beendet. Diese Lösung folgt in Listing \ref{lst:javauntilwhile}.

\begin{lstlisting}[language=Java, caption=Java Until-Statement, label={lst:javauntilwhile}]
while (var_1 < var_2)){
	if (var_1) == var_2){
		break; 
	}
	System.out.println ("smaller");
}

\end{lstlisting} 

Wobei zu erwähnen ist das hier Java Bad-Practices angewendet werden. Ein \verb+break+ in einer While-Schleife macht in den meisten Fällen den Quellcode schwerer Lesbar, je nach Komplexität der Codestruktur.
In diesem Zusammenhang ist die Verwendung des \verb+break+ Befehls weniger komplex. 

Da in Java kein Muster existiert, welches das äquivalent zu dem \verb+UNTIL+ bietet, ist die Definition einer zusätzlichen Verzweigung mit einer Abbruchbedingung die bisher einzige Lösung.

Weiterhin ist auch die Position der Verzweigung fraglich. Genauso kann die Abbruchbedingung im Fuß der Schleife definiert werden. Dieser Umstand führt zu einer weiteren Iteration des Schleifenkörpers. 

Da in PL/I die Bedingung jedoch am Schleifen-Kopf definiert wird, wurde in Java eine Prüfung des Abbruchbedingung ebenfalls im Kopf implementiert. 

Um nun neben einem einfachen Programmablauf, zusätzlicher Logik eines Programms auch Ein- und Ausgabe Operationen von dem PL/I-Quellcode in den Java-Zielcode übersetzen zu können, wird in dem nachfolgenden Kapitel sowohl die Konsolen, als auch die Datei Ein- und Ausgabe diskutiert.

\pagebreak
\subsubsection{Ein- und Ausgabe Befehle}
\paragraph{Konsolen Ein- und Ausgabe}
Um eine Benutzerinteraktion zu ermöglichen wird der Display-Ausdruck transformiert.
In PL/I gibt es sowohl die Möglichkeit mit dem Display-Ausdruck eine Text-Nachricht in der Konsole auszugeben, sowie eine Benutzereingabe abzufragen. \footcite[Vgl. ][S. 264ff.]{pliref}

In Java gibt es verschiedene Implementierungen einer Umleitung der Ausgabe in die Konsole.
Die gängige Methode ist die Verwendung des Ausdrucks \path{System.out.println()}. 
Alternativ könnte auch die Methode \verb+log.trace+ verwendet werden.
Jedoch wird hier eine Abhängigkeit zu der Software-Bibliothek \verb+logger+  erzeugt, weshalb sich gegen diese Methode entschieden wurde.
Eine weitere Alternative würde der \verb+PrintWriter+ bieten, hierbei müsste jedoch zuerst das Objekt \verb+PrintWriter+ erzeugt werden, was zusätzlichen Quellcode erzeugen würde. Diese könnte mit der Implementierung des Sysout-Befehls vermieden werden.
Somit wurde mit dem Sysout-Befehl die gängige Methode gewählt. Entsprechend wird der Ausdruck in Listing \ref{lst:display} Zu Listing \ref{lst:sysout}

\begin{lstlisting}[language=PL/I, caption=Display-Statments, label={lst:display}]
DISPLAY('Hello World');
\end{lstlisting} 

\begin{lstlisting}[language=Java, caption=\"Ubersetzung des Display-Statments, label={lst:sysout}]
System.out.println("Hello World");
\end{lstlisting} 

Um den Display-Ausdruck ebenfalls für das einlesen von Benutzereingaben zu verwenden, wird an den bekannten Display-Ausdruck ein \verb+REPLY+ angefügt. Siehe Listing \ref{lst:displayreply}.

\begin{lstlisting}[language=PL/I, caption=Display-Reply-Statments, label={lst:displayreply}]
DISPLAY('Username') REPLY(var_1)
\end{lstlisting} 

In dem Beispiel in Listing \ref{lst:displayreply} wird die Benutzereingabe in der
Variable \verb+var_1+ gespeichert.
In PL/I kann die Benutzereingabe nur in einen Bit, Widechar, oder Char gespeichert
werden. 
In Java gibt es verschiedene Lösungen um die Benutzereingabe Abzufragen.
Einerseits über das Scanner oder BufferedReader Objekt.
Jedoch würden beide Lösungen eine Instanziierung der zugehörigen Objekte benötigen und ebenfalls mehr Zeilen Quellcode inanspruchnehmen als nötig.

Stattdessen wird das System Objekt verwendet, welches auch bei der \verb+System.out.println+ verwendet wurde.
Mit \verb+System.console.readLine()+ wird die Benutzereingabe gelesen.
Listing \ref{lst:javadisplay} zeigt die Übersetzung des PL/I Ausdrucks aus Listing \ref{lst:diplay}.

\begin{lstlisting}[language=Java, caption=Java übersetzung des Display-Reply-Statments, label={lst:javadisplay}]
username.init(System.console().readLine()); 
\end{lstlisting} 

Damit das übersetze Programm neben der Konsole, auch auf das Dateisystem zugreifen kann, wird ebenfalls die Ein- und Ausgabe von Dateien integriert.

\paragraph{Datei Ein- und Ausgabe}
In PL/I gibt es die Möglichkeit über des \verb+READ+-Statement Dateien von dem Dateisystem einzulesen.
In Kapitel 1.1 wurde bereits erwähnt das PL/I-Programme hauptsächlich auf einem Mainframe-System ausgeführt werden.
Dieser Umstand ist in diesem Kapitel relevant, da auf einem Betriebssystem wie z/Os andere Formen von Dateien existieren wie etwa auf eine x86-Linux System.

Auf einem z/Os Betriebssystem werden die Dateien als Data-Sets gespeichert.
Ein Data-Set unterscheidet sich in der Speicherung von einer herkömmlichen Datei, da ein Data-Set die eigentlichen Informationen in einem Record speichert. 
Ein Record kann dann von einem Programm, wie einem PL/I-Programm gelesen werden.
Für die weitere Übersetzung von PL/I-Syntax ist dies wichtig, da es in PL/I im zusammenhang mit herkömmlichen Dateien irreführende Datentyp-Bezeichner wie den Typ \verb+FILE+ gibt.

In PL/I kann der Datentyp FILE in Listing \ref{lst:plifiletyp} definiert werden.

\begin{lstlisting}[language=PL/I, caption=FILE Typ in PL/I, label={lst:plifiletyp}]
DCL file_1 FILE ENVIRONMENT STREAM INPUT SEQUENTIAL BUFFERED KEYED PRINT;
\end{lstlisting} 

In diesem Kontext handelt es sich hier um ein logisches Abbild des Inhalts also der Records eines physisch gespeicherten Data-Sets.
Indirekt kann der Typ FILE etwa mit einem Buffer verglichen werden in dem der Inhalt einer Datei gelesen und für weitere Programmroutinen verfügbar wird.
\footcite[Vgl. ][ S.305ff. ]{pliref}

In Java existiert ein ähnlicher nicht-primitiver File-Typ.
Java liest mit der Klasse File eine Datei direkt vom Betriebssystem ein und speichert den Inhalt in einem Buffer. 
Hingegen besteht in Java kaum die Möglichkeit dabei direkt zu beeinflussen wie die Datei eingelesen werden soll. 
In PL/I müssen Attribute für den Typ \verb+FILE+ angegeben werden die 
In Listing \ref{lst:plifiletyp} angegeben sind. 
Diese Attribute sind ähnliche wie auch das \verb+OPTIONS+ Attribut aus Kapitel \ref{programstruct} Compiler-Optionen, die dazu verwendet werden die Durchführung des Programms möglichst Effizienz zu gestalten.

Dabei sind diese Attribute in Java nicht von Relevanz und können ignoriert werden.

Wird nun Listing \ref{lst:plifiletyp} dem Transpiler als Eingabe übergeben entsteht der Java-Zielcode in Listing \ref{lst:javafiletpye}.

\begin{lstlisting}[language=Java, caption=File Objekt in Java, label={lst:javafiletpye}]
public File file_1 = new File("");
\end{lstlisting} 


Bezüglich Listing \ref{lst:javafiletpye} ist anzumerken das bisher lediglich ein File Objekt instanziiert wurde.
Es wurde kein Pfad übergeben und somit auch keine Datei eingelesen.
Allgemein ist Fraglich wie das einlesen von Dateien mit dem Transformierten PL/I Programm erfolgen wird, da die Organisation von Dateien auf einem z/Os-System anders aufgeteilt ist wie die eine Linux oder Windows Desktop Computer.

In dieser Version des Transpilers, wird dem Benutzer die Verantwortung übergeben die Referenz zu den ursprünglichen Eingabedateien herzustellen.

In PL/I wird mit einem \verb+READ+-Ausdruck definierte Datei gelesen und kann in einer Variable gespeichert werden
Ein mögliches \verb+READ+-Statement ist in Listing \ref{lst:pliread} dargestellt.

\begin{lstlisting}[language=PL/I, caption=READ Statement in PL/I, label={lst:pliread}]
READ FILE(file_1); 
\end{lstlisting} 

Hierbei wird die definierte Datei gelesen.
Transformiert wird diese Dateieingabe mit dem Scanner Objekt. Zu sehen in Listing \ref{lst:scannerjava}

\begin{lstlisting}[language=Java, caption=Scanner Objekt in Java, label={lst:scannerjava}]
Scanner readFile = new Scanner(file_1);
\end{lstlisting} 

Mit dem Scanner Objekt kann die definierte Datei nun Wort für Wort in einen String gelesen werden.

%\subsection{Optimierung}
% online-Smoketest von PL/I Code -> %todo: Verschieben nach Erweiterbarkeit (Schlusskapitel), weil momentan noch nicht vollstaendige Grammatik realisiert.
\pagebreak
\subsection{Test und Integration}
%1. transpiler wird getestet
%1.1 testen der methoden von Lexer, Parser usw. (Bsp.: Kann dieses Zeichen verarbeitet werden?)
%1.2 baum testen auf Korrektheit

%2. transpilieren wird getestet
%2.1 output des transpilierten Pl/1 Codes im Verhältnis zum Pl/1 Code testen.

%3. der transpilierte Code wird getestet
%- wie wird pl/1 Code Native getestet
%- funktioniert der Java Code richtig

%4. performance test (erst am ende)
\subsection{Performance und Benchmarks}

\section{Fazit}
